<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring 知识 -- BeanFactory 和 FactoryBean</title>
    <link href="/2020/8/28/Spring-%E7%9F%A5%E8%AF%86-BeanFactory-%E5%92%8C-FactoryBean/"/>
    <url>/2020/8/28/Spring-%E7%9F%A5%E8%AF%86-BeanFactory-%E5%92%8C-FactoryBean/</url>
    
    <content type="html"><![CDATA[<p>先说结论，他们的区别是：</p><p>FactoryBean 是一个接口，可以用于解决使用第三方依赖时，用户需要配置过多依赖的问题。<br>具体来说，它主要是第三方为了向使用方提供 Bean，然后使用方再去生成并配置好这个 FactoryBean 实例交给 Spring 管理，然后通过这个工厂 Bean 就能生成这个第三方需要使用的真正的 Bean 并交给 Spring 去管理了。</p><p>BeanFactory 是 Spring 容器产生 Bean 的顶层工厂接口，Spring IOC 容器中的 Bean 都由这个 BeanFactory 产生。</p><a id="more"></a><p>对于 FactoryBean，具体来说就是：如果你是第三方提供了某些功能能够让其他人使用你写的 jar 包，但是这些功能可能需要用户配置，例如 MyBatis 的数据库连接配置等。而且，配置好之后还需要去交给 Spring 去管理，那么用户就需要提供一个配置类来去定制他自己的功能或者使这个 jar 包真正产生作用。但是，用户需要去生成这个配置类，而这个配置类可能依赖了很多成员变量，它们可能是字符串，各种数组，甚至你写的配置类，你提供的功能依赖的第三方配置类等等，这样全都交给用户来去配置就会非常麻烦。那么，更好的办法是，你自己维护这个配置类并封装成一个 FactoryBean，用户只需要手动生成这个 FactoryBean，再自己制定一些必须的配置，然后可以用这个配置类注入到那个 FactoryBean 实例里面，就完成了功能的定制，最后用户只需要在这个函数上面加上 @Bean 注解即可把这个 FactoryBean 交给 Spring IOC 容器，而 Spring 就可以根据 FactoryBean 的特性来去真正生产出第三方需要的 Bean。</p><p>例如：</p><p>MyBatis 需要一个 SqlSessionFactory，而这个类有一些数据源的配置，但是，要生成这个配置类不仅仅需要配置数据源，还有一些其他的配置，如果都交给用户来去手动管理就会变得非常麻烦。</p><p>而 MyBatis 提供了一个 SqlSessionFactoryBean 的类，在这个类里面已经做了相关配置的设置，使用者只需要生成这个 SqlSessionFactoryBean 的实例，在注入配置实例就可以完成这个 FactoryBean 的生成，进而交给 Spring 管理从而真正生成 SqlSessionFactory。</p><div class="hljs"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactory</span><span class="hljs-params">()</span> </span>&#123;  SqlSessionFactoryBean factoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();  factoryBean.setDataSource(dataSource());  <span class="hljs-keyword">return</span> factoryBean.getObject();&#125;</code></pre></div><p>注意：</p><ol><li><p>根据 FactoryBean 的名称从 BeanFactory 中获取的实际上是 FactoryBean 的 getObject() 返回的对象，而不是 FactoryBean 本身，如果要获取 FactoryBean 对象，请使用 <code>&amp;BeanName</code> 来获取。</p></li><li><p>FactoryBean 的第三方实现类生成时必须足够简单，因为如果过于复杂那就还不如用户自己手动直接生成第三方所需 Bean 对象了。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- Spring AOP</title>
    <link href="/2020/8/26/Spring-%E7%9F%A5%E8%AF%86-Spring-AOP/"/>
    <url>/2020/8/26/Spring-%E7%9F%A5%E8%AF%86-Spring-AOP/</url>
    
    <content type="html"><![CDATA[<h2 id="相关概念"><a class="header-anchor" href="#相关概念">⚡</a>相关概念</h2><h3 id="Aop是什么"><a class="header-anchor" href="#Aop是什么">⚡</a>Aop是什么</h3><p>与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。</p><h3 id="好处"><a class="header-anchor" href="#好处">⚡</a>好处</h3><p>对比oop,aop 能够将横切性的问题和业务逻辑解偶，减少模板代码，提高可维护性和开发效率</p><h3 id="使用场景"><a class="header-anchor" href="#使用场景">⚡</a>使用场景</h3><ol><li>日志记录</li><li>权限验证</li><li>效率检查</li><li>事务管理</li><li>exception</li></ol><h3 id="AOP-底层技术"><a class="header-anchor" href="#AOP-底层技术">⚡</a>AOP 底层技术</h3><p>Spring 默认使用 JDK 动态代理，也可以使用 CGLib，二者都是动态代理，在运行时初始化时期进行织入。</p><p><a href="https://www.cnblogs.com/echola/p/11004069.html#popular" target="_blank" rel="noopener">博客</a></p><ul><li><p>区别</p><p><img src="/img/aop.jpeg" srcset="/img/loading.gif" alt=""></p></li><li><p>JDK 动态代理是通过接口反射得到 byte 数组，存放代理类的字节码，然后通过 native 方法把字节码转化成 class 对象。</p></li></ul><h3 id="Spring-AOP-和-AspectJ"><a class="header-anchor" href="#Spring-AOP-和-AspectJ">⚡</a>Spring AOP 和 AspectJ</h3><p>AOP 是一种概念，Spring AOP 和 AspectJ，Javassist 等都是具体实现。</p><p>Spring 仅仅是借用 AspectJ 的注解语法而已，Spring 使用 JDK 动态代理或者 CGLib 动态代理，是结合 Spring IOC 容器的动态织入；而 AspectJ 是一个 AOP 框架，是使用静态织入的方式。</p><p><a href="https://juejin.im/post/6844903549172711437" target="_blank" rel="noopener">博客</a></p><h3 id="术语解释"><a class="header-anchor" href="#术语解释">⚡</a>术语解释</h3><ol><li><p>aspect:切面，一定要给spring去管理</p><p>切面抽象为类</p></li><li><p>pointcut:切点表示连接点的集合</p><p>PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量</p></li><li><p>Joinpoint:连接点</p><p>目标对象中的方法<br>JoinPoint是要关注和增强的方法，也就是我们要作用的点</p></li><li><p>Weaving :织入</p><p>把代理逻辑加入到目标对象上的过程叫做织入</p></li><li><p>target 目标对象，原始对象</p></li><li><p>aop Proxy 代理对象，包含了原始对象的代码和增加后的代码的那个对象</p></li><li><p>advice:通知</p><p>增加的逻辑和加入到原方法的位置</p><ol><li><p>advice通知类型:</p></li><li><p>Before：连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</p></li><li><p>After：连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</p></li><li><p>After throwing：执行抛出异常的时候</p></li><li><p>After (finally)：无论连接点是正常退出还是异常退出，都会执行</p></li><li><p>Around advice：围绕连接点执行，例如方法调用。</p><p>这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</p></li><li><p>ProceedingJoinPoint 和JoinPoint的区别:</p><p>ProceedingJoinPoint 继承了JoinPoint,proceed()这个是aop代理链执行的方法。并扩充实现了proceed()方法，用于继续执行连接点。JoinPoint仅能获取相关参数，无法执行连接点。</p></li><li><p>JoinPoint的方法</p><ol><li><p>java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；</p></li><li><p>Signature getSignature() ：获取连接点的方法签名对象；</p></li><li><p>java.lang.Object getTarget() ：获取连接点所在的目标对象；</p></li><li><p>java.lang.Object getThis() ：获取代理对象本身；</p></li><li><p>proceed()有重载,有个带参数的方法,可以在 AOP 的实现逻辑中修改目标方法的的参数，再通过 proceed(Object[] object) 方法传入修改的参数。</p></li></ol></li></ol></li></ol><h2 id="Spring-AOP-使用步骤"><a class="header-anchor" href="#Spring-AOP-使用步骤">⚡</a>Spring AOP 使用步骤</h2><h3 id="基本步骤"><a class="header-anchor" href="#基本步骤">⚡</a>基本步骤</h3><h4 id="开启-AspectJ-注解支持"><a class="header-anchor" href="#开启-AspectJ-注解支持">⚡</a>开启 @AspectJ 注解支持</h4><div class="hljs"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAspectJAutoProxy</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;&#125;</code></pre></div><h4 id="声明切面-aspect"><a class="header-anchor" href="#声明切面-aspect">⚡</a>声明切面 aspect</h4><div class="hljs"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> org.xyz;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotVeryUsefulAspect</span> </span>&#123;&#125;</code></pre></div><h4 id="声明切点-pointcut"><a class="header-anchor" href="#声明切点-pointcut">⚡</a>声明切点 pointcut</h4><div class="hljs"><pre><code class="hljs Java"><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* transfer(..))"</span>) <span class="hljs-comment">// the pointcut expression</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anyOldTransfer</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// the pointcut signature</span></code></pre></div><h4 id="声明通知-advice"><a class="header-anchor" href="#声明通知-advice">⚡</a>声明通知 advice</h4><p>例如：声明一个 before advice</p><div class="hljs"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeforeExample</span> </span>&#123;    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"com.xyz.myapp.CommonPointcuts.dataAccessOperation()"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAccessCheck</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><h3 id="Introductions-引入"><a class="header-anchor" href="#Introductions-引入">⚡</a>Introductions 引入</h3><blockquote><p>Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implementation of that interface on behalf of those objects.</p><p>引入（在AspectJ中称为类型间声明）使切面可以声明通知对象（目标对象）实现给定的接口，并且使切面提供该接口的实现给那些对象。</p></blockquote><div class="hljs"><pre><code class="hljs Java"><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsageTracking</span> </span>&#123;    <span class="hljs-comment">// 使用这个注解使得 service 包下面所有的类都加入了 TestDao 接口的方法声明，并且加入了实现类 TestDaoImpl 中的逻辑</span>    <span class="hljs-comment">// 相当于加入了父类扩展</span>    <span class="hljs-meta">@DeclareParents</span>(value=<span class="hljs-string">"com.xzy.myapp.service.*+"</span>,    defaultImpl=TestDaoImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">TestDao</span> <span class="hljs-title">dao</span></span>;&#125;</code></pre></div><h3 id="Aspect-Instantiation-Models-切面实例化模型"><a class="header-anchor" href="#Aspect-Instantiation-Models-切面实例化模型">⚡</a>Aspect Instantiation Models 切面实例化模型</h3><blockquote><p>By default, there is a single instance of each aspect within the application context. AspectJ calls this the singleton instantiation model. It is possible to define aspects with alternate lifecycles. Spring supports AspectJ’s <code>perthis</code> and pertarget instantiation models; percflow, percflowbelow, and pertypewithin are not currently supported.</p><p>默认情况下，应用程序上下文中每个切面都有一个实例。AspectJ将此称为单例实例化模型。也可以使用备用生命周期来定义方面。Spring支持AspectJ的perthis和pertarget实例化模型；目前不支持percflow，percflowbelow和pertypewithin。</p></blockquote><ul><li><p>要求：</p><ol><li>AspectJ对象的注入类型为prototype</li><li>目标对象也必须是prototype的</li></ol><p>原因为：只有目标对象是原型模式的，每次getBean得到的对象才是不一样的，由此针对每个对象就会产生新的切面对象，才能产生不同的切面结果。</p></li><li><p>场景：</p><p>不常用，当有共享变量的时候，并且目标对象是 prototype 每次需要产生不同切面时使用。</p>  <div class="hljs"><pre><code class="hljs Java"> <span class="hljs-comment">// 使用方式如下：</span><span class="hljs-meta">@Aspect</span>(<span class="hljs-string">"perthis(this(com.chenss.dao.IndexDaoImpl))"</span>)</code></pre></div></li></ul><h3 id="支持的-Pointcut-类型"><a class="header-anchor" href="#支持的-Pointcut-类型">⚡</a>支持的 Pointcut 类型</h3><ol><li><p>execution: For matching method execution join points. This is the primary pointcut designator to use when working with Spring AOP.</p><p>用于匹配方法执行 join points连接点，最小粒度方法，在aop中主要使用。</p><p>格式： execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</p><p>这里问号表示当前项可以有也可以没有，其中各项的语义如下</p><p>modifiers-pattern：方法的可见性，如public，protected；<br>ret-type-pattern：方法的返回值类型，如int，void等；<br>declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；<br>name-pattern：方法名类型，如buisinessService()；<br>param-pattern：方法的参数类型，如java.lang.String；<br>throws-pattern：方法抛出的异常类型，如java.lang.Exception；</p><ul><li><p>example:</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.*.*(..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的任意方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public * com.chenss.dao.*.*(..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的public方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public * com.chenss.dao.*.*())"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.*.*(java.lang.String, ..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.*.*(java.lang.String))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.*.*(java.lang.String))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public * *(..))"</span>)<span class="hljs-comment">//匹配任意的public方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* te*(..))"</span>)<span class="hljs-comment">//匹配任意的以te开头的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.IndexDao.*(..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao.IndexDao接口中任意的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao..*.*(..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包及其子包中任意的方法</span></code></pre></div><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples</a></p></li></ul></li><li><p>within: Limits matching to join points within certain types (the execution of a method declared within a matching type when using Spring AOP).</p><p>表达式的最小粒度为类</p> <div class="hljs"><pre><code class="hljs Java"><span class="hljs-comment">// within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"within(com.chenss.dao.*)"</span>)<span class="hljs-comment">//匹配com.chenss.dao包中的任意方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"within(com.chenss.dao..*)"</span>)<span class="hljs-comment">//匹配com.chenss.dao包及其子包中的任意方法</span></code></pre></div></li><li><p>this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.</p><p>表示代理对象</p><p>使用 JDK 动态代理时，指向接口和继承的父类proxy<br>使用 CGLib 动态代理时，指向接口和子类(没有继承proxy)</p></li><li><p>target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.</p><p>指向接口和子类<br>表示目标对象</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/* 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理</span><span class="hljs-comment">* JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。</span><span class="hljs-comment">* 而CGLIB继承被代理的类来实现。</span><span class="hljs-comment">* 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。</span><span class="hljs-comment">* 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"target(com.chenss.dao.IndexDaoImpl)"</span>)<span class="hljs-comment">//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"this(com.chenss.dao.IndexDaoImpl)"</span>)<span class="hljs-comment">//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"@target(com.chenss.anno.Chenss)"</span>)<span class="hljs-comment">//具有@Chenss的目标对象中的任意方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"@within(com.chenss.anno.Chenss)"</span>)<span class="hljs-comment">//等同于@target</span></code></pre></div></li><li><p>args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.</p><p>args表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关</p> <div class="hljs"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><span class="hljs-comment">* args同execution不同的地方在于：</span><span class="hljs-comment">* args匹配的是运行时传递给方法的参数类型</span><span class="hljs-comment">* execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"args(java.io.Serializable)"</span>)<span class="hljs-comment">//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"@args(com.chenss.anno.Chenss)"</span>)<span class="hljs-comment">//接受一个参数，并且传递的参数的运行时类型具有@Classified</span></code></pre></div></li><li><p>@target: Limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type.</p><p>@target(里面是一个注解类xx,表示所有加了xx注解的类,和包名无关)</p></li><li><p>@args: Limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given types.</p></li><li><p>@within: Limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP).</p></li><li><p>@annotation: Limits matching to join points where the subject of the join point (the method being run in Spring AOP) has the given annotation.</p></li></ol><h2 id="其他注意要点"><a class="header-anchor" href="#其他注意要点">⚡</a>其他注意要点</h2><h3 id="通知注解执行顺序"><a class="header-anchor" href="#通知注解执行顺序">⚡</a>通知注解执行顺序</h3><ul><li><p>正常情况执行执行顺序：</p><p><img src="/img/aop2.png" srcset="/img/loading.gif" alt=""></p></li><li><p>异常情况：</p><p><img src="/img/aop3.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="声明式事务-Transactional-注解"><a class="header-anchor" href="#声明式事务-Transactional-注解">⚡</a>声明式事务 @Transactional 注解</h3><p>声明式事务和普通 AOP 有些区别，后者对于代理逻辑的增强可以是在目标方法调用之前(@Before)，或者目标方法调用之后(@After)，或者目标方法的前后(@Around)，而对于声明式事务，则是在目标方法的里面某一段或者某些部分加入代理逻辑。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bug记录 -- MyBaits 报错 -- Cannot get Configuration as configuration factory was not set</title>
    <link href="/2020/8/14/Bug%E8%AE%B0%E5%BD%95-MyBaits-%E6%8A%A5%E9%94%99-Cannot-get-Configuration-as-configuration-factory-was-not-set/"/>
    <url>/2020/8/14/Bug%E8%AE%B0%E5%BD%95-MyBaits-%E6%8A%A5%E9%94%99-Cannot-get-Configuration-as-configuration-factory-was-not-set/</url>
    
    <content type="html"><![CDATA[<h2 id="错误复现"><a class="header-anchor" href="#错误复现">⚡</a>错误复现</h2><!-- more --><ul><li><p>第一次查询数据库，没问题</p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_5.png" srcset="/img/loading.gif" alt=""></p><p>日志：</p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_6.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_7.png" srcset="/img/loading.gif" alt=""></p></li><li><p>第二次则503</p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_8.png" srcset="/img/loading.gif" alt=""></p><p>日志：</p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_3.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_4.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_2.png" srcset="/img/loading.gif" alt=""></p></li></ul><h2 id="出错原因："><a class="header-anchor" href="#出错原因：">⚡</a>出错原因：</h2><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_1.png" srcset="/img/loading.gif" alt=""></p><p>加入 <code>&lt;cache/&gt;</code> 标签并在 MyBatis 配置文件中开启了二级缓存时，如果这个 mapper 有用到 lazyLoading 相关的技术，比如 resultMap 里面的 <code>fetchType = lazy</code> 就会出现这样的错误</p><h2 id="解决办法"><a class="header-anchor" href="#解决办法">⚡</a>解决办法</h2><blockquote><p>Apparently, the issue is on the lazyLoading functionality code where some race condition trigger the issue. There appears to be a multi-thread related bug in the lazyFunctionality of MyBatis, so deactivating it works as a workaround.<br>显然，问题出在延迟加载功能代码上，其中某些竞争条件触发了该问题。MyBatis 的懒加载功能中似乎存在与多线程相关的错误，因此将其停用可以作为一种解决方法。</p></blockquote><ol><li><p>不使用 <code>cache</code> 标签</p></li><li><p>不使用 lazyLoading 相关配置</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ORM 带来的 N+1 问题</title>
    <link href="/2020/8/13/ORM-%E5%B8%A6%E6%9D%A5%E7%9A%84-N-1-%E9%97%AE%E9%A2%98/"/>
    <url>/2020/8/13/ORM-%E5%B8%A6%E6%9D%A5%E7%9A%84-N-1-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-1-N-问题"><a class="header-anchor" href="#什么是-1-N-问题">⚡</a>什么是 1+N 问题</h2><p><img src="/img/ORM_N+!_Problem1.png" srcset="/img/loading.gif" alt=""></p><p>如图，user 表为用户的基本信息表，role 则是系统内所有角色信息，而用户可能会有多种角色，根据数据库范式，user 和 role 通过 user_role 表相关联，代表一个用户可以有多个角色，一个角色也可以有多个用户。</p><p>这样建表，虽然遵循了范式，提供了系统的扩展性，但是有一个问题，当我们想要去查找一个用户所有的角色信息时，需要先从 user_role 表里面找到这个用户的所有角色id（role_id），然后再根据 role_id 去 role 表里面找到相关的角色信息。</p><p><img src="/img/ORM_N+!_Problem2.png" srcset="/img/loading.gif" alt=""></p><p>如图，最后两个字段的信息需要连接查询才能得到</p><p>这样，就产生了 1+N 问题：查找一个用户的角色要先根据 user_id 查找到 N 个 role_id，再对每个 role_id 查找，总共查找了 1+N 次</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment"># 1 次查询</span><span class="hljs-keyword">select</span> user.*,role_id<span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> user_role <span class="hljs-keyword">on</span> <span class="hljs-keyword">id</span> = user_id<span class="hljs-keyword">where</span> user_id = <span class="hljs-number">1</span>;<span class="hljs-comment"># N 层循环(Java 代码级别而非数据库级别)</span>for(1:N)&#123;    <span class="hljs-keyword">select</span> role.* <span class="hljs-keyword">from</span> <span class="hljs-keyword">role</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">role</span> = <span class="hljs-keyword">var</span>&#125;</code></pre></div><h2 id="如何解决"><a class="header-anchor" href="#如何解决">⚡</a>如何解决</h2><h3 id="SQL（连接查询）不推荐"><a class="header-anchor" href="#SQL（连接查询）不推荐">⚡</a>SQL（连接查询）<strong>不推荐</strong></h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> u.id <span class="hljs-keyword">as</span> <span class="hljs-keyword">id</span>,    user_name,    user_real_name,    user_location,    user_telephone,    role_id,    role_rank,    role_name,    role_description    <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">as</span> u <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> user_role <span class="hljs-keyword">as</span> ur    <span class="hljs-keyword">on</span> u.id = ur.user_id    <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">role</span> <span class="hljs-keyword">as</span> r    <span class="hljs-keyword">on</span> r.id = ur.role_id    <span class="hljs-keyword">where</span> u.id = ?</code></pre></div><p>但是，这样还是会有一些瑕疵。</p><p><img src="/img/ORM_N+!_Problem6.png" srcset="/img/loading.gif" alt=""></p><p>即：前面 user 表的基本信息全部都重复了，而只有后面 role_id 和 role_rank 等信息是不同的，这样只能返回多个部分属性相同的实体集合(collection),对于上面要求的 POJO 还要再进行处理，这个 SQL 和 POJO 并不能对应上，本质上不能代表我们的需求，而且，我们在代码层用 Java 再对返回的 List 或者 Set 进行处理时，又明显会比数据库层慢一些，而且处理也会有些麻烦。</p><p>期望的解决方案是可以对 user 表进行分组，得到一行 user 基本信息，然后把 user_id 这个字段变成一个集合，其他的字段例如 user_rank 也同理变成集合，但是，mysql 没有这样的聚集函数或者分组函数。而且，就算有这样的函数，user_id 和 user_rank 处理之后能否对应也是一个问题。</p><h3 id="ORM"><a class="header-anchor" href="#ORM">⚡</a>ORM</h3><h4 id="MyBatis-集合的嵌套-select-查询-懒加载"><a class="header-anchor" href="#MyBatis-集合的嵌套-select-查询-懒加载">⚡</a>MyBatis 集合的嵌套 select 查询+懒加载</h4><p>UserMapper.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"UserPublicResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.cloud.farming.entity.model.UserPublic"</span>&gt;</span><span class="hljs-comment">&lt;!-- id 和 result 两者之间的唯一不同是，id 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userName"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_real_name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userRealName"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_location"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userLocation"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_telephone"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userTelephone"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleIdSet"</span></span><span class="hljs-tag">            <span class="hljs-attr">javaType</span>=<span class="hljs-string">"java.util.Set"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"com.cloud.farming.repository.UserRoleMapper.findRoleIdSetByUserId"</span></span><span class="hljs-tag">            <span class="hljs-attr">ofType</span>=<span class="hljs-string">"java.lang.Integer"</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">"lazy"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleSet"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.cloud.farming.entity.model.Role"</span></span><span class="hljs-tag">            <span class="hljs-attr">select</span>=<span class="hljs-string">"com.cloud.farming.repository.UserRoleMapper.findRoleSetByUserId"</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">"lazy"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findUserPublicByUserId"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"UserPublicResultMap"</span>&gt;</span>    select id, user_location, user_telephone, user_name, user_real_name    from user    where id = #&#123;userId,jdbcType=BIGINT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>UserRoleMapper.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- UserRoleMapper.findRoleIdSetByUserId --&gt;</span><span class="hljs-comment">&lt;!-- 返回值是 Set&lt;Integer&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findRoleIdSetByUserId"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"java.lang.Integer"</span>&gt;</span>    select role_id    from user_role    where user_id = #&#123;userId,jdbcType=BIGINT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-comment">&lt;!-- UserRoleMapper.findRoleSetByUserId --&gt;</span><span class="hljs-comment">&lt;!-- 返回值是 Set&lt;Role&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findRoleSetByUserId"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"com.cloud.farming.repository.RoleMapper.BaseResultMap"</span>&gt;</span>    select role.id, role_rank, role_name, role_description    from user_role    left join role    on user_role.role_id = role.id    where user_id = #&#123;userId,jdbcType=BIGINT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>上面的 SQL 语句新增的实际上只有一条即，UerMapper 的findUserPublicByUserId，其他 UserRoleMapper 都是之前已有的。</p><p>结果：</p><p><img src="/img/ORM_N+!_Problem3.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/ORM_N+!_Problem4.png" srcset="/img/loading.gif" alt=""></p><p>这样，直接调用 UserMapper.xml 的查询语句findUserPublicByUserId时，对于 association 的字段可以由 MyBatis 帮我们执行，不需要我们手动写连接查询，从另一个角度说，如果像上面第一种方法，一条 SQL 语句中连接查询根本无法得到我们想要的格式的数据，使用这个方式也可以很好的解决问题。</p><p>但是这样看起来只是将 SQL 复用以及避免了单个语句中的连接查询，应该还是存在 1+N 问题，而且这样感觉将问题反而表现的更加明显了。</p><p>一个在某些情况下可用的方案是懒加载。association 标签中的 fetchType = lazy 则是处于性能的考虑，如果我们有时不需要这些信息，没有调用相关字段的 get 方法，那么此时由于懒加载直接不进行 association 的查询，字段返回空，这样可以大幅减少数据库的 IO 操作也就从源头上解决了 1+N 的问题。</p><p>当然，这样做的前提是懒加载字段确实不需要才可用。</p><p>然而，退一步说，即使没有懒加载，如果二次查询字段使用了 MyBatis 的二级缓存，那么直接命中缓存性能会更高；或者，如果二次查询的字段使用了外键或者索引，这样效率说不定也会比多表连接好一些，可读性，复用性也会更好。</p><h4 id="集合的嵌套结果映射"><a class="header-anchor" href="#集合的嵌套结果映射">⚡</a>集合的嵌套结果映射</h4><p>UserMapper.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"UserPublicResultMapWithoutN+1"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.cloud.farming.entity.model.UserPublic"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userName"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_real_name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userRealName"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_location"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userLocation"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_telephone"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userTelephone"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleSet"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.cloud.farming.entity.model.Role"</span></span><span class="hljs-tag">            <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"com.cloud.farming.repository.RoleMapper.RoleResultMap"</span>/&gt;</span><span class="hljs-comment">&lt;!--                    resultSet="roles" column="role_id" foreignColumn="user_id"/&gt;--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleIdSet"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"java.lang.Integer"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"java.util.Set"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"role_id"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"role_id"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"java.lang.Integer"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"value"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findUserRolesByUserIdWithoutN"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"UserPublicResultMapWithoutN+1"</span>&gt;</span>    select u.id as id,    user_name,    user_real_name,    user_location,    user_telephone,    role_id,    role_rank,    role_name,    role_description    from user as u left join user_role as ur    on u.id = ur.user_id    left join role as r    on r.id = ur.role_id    where u.id = #&#123;userId,jdbcType=BIGINT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>这样直接关联再配合 MyBatis 的缓存 <code>&lt;cache/&gt;</code>，可以将性能调整到极致。</p><p>第一次查询数据库：</p><p><img src="/img/ORM_N+!_Problem7.png" srcset="/img/loading.gif" alt=""></p><p>第二次直接命中缓存，没有查询数据库</p><p><img src="/img/ORM_N+!_Problem8.png" srcset="/img/loading.gif" alt=""></p><h4 id="集合的多结果集"><a class="header-anchor" href="#集合的多结果集">⚡</a>集合的多结果集</h4><p>官方文档原话：</p><blockquote><p>从版本 3.2.3 开始，MyBatis 提供了另一种解决 N+1 查询问题的方法。</p></blockquote><blockquote><p>某些数据库允许存储过程返回多个结果集，或一次性执行多个语句，每个语句返回一个结果集。 我们可以利用这个特性，在不使用连接的情况下，只访问数据库一次就能获得相关数据。</p></blockquote><p>存储过程要比单个 SQL 快</p><p>虽然存储过程有三个好处：安全，简单，高性能，但是阿里归约中并不推荐，原因是难以调试和扩展，更没有移植性.</p><p>然而，这个规约我认为要视情况而定，大部分情况下都没有移植或者扩展的要求。不过每次去写一个存储过程也的确有些麻烦，而且此处我也尝试测试使用过，但是有报错的问题，没有多浪费时间解决，先留做记录，如果后续需要可以尝试使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- 相关子查询优化</title>
    <link href="/2020/7/27/MySQL-%E7%9F%A5%E8%AF%86-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <url>/2020/7/27/MySQL-%E7%9F%A5%E8%AF%86-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="相关子查询的-MySQL-错误优化-MySQL-5-7-以后不适用"><a class="header-anchor" href="#相关子查询的-MySQL-错误优化-MySQL-5-7-以后不适用">⚡</a>相关子查询的 MySQL 错误优化(MySQL 5.7 以后不适用)</h2><a id="more"></a><h3 id="问题"><a class="header-anchor" href="#问题">⚡</a>问题</h3><p>对于不相关子查询来说,我们会认为先执行子查询,在执行外层查询,但是实际不会: MySQL 会将相关的外层表压缩到子查询中,它认为这样可以更高效地查找到数据行</p><p>例如:</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> test.tabname2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'name'</span>);<span class="hljs-comment"># MySQL 不会这样执行:</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">from</span> test.tabname2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'name'</span>;<span class="hljs-comment"># 内层查询结果：1,3,5,7,9,11,13,15,17,1</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>);<span class="hljs-comment"># MySQL 实际执行:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname2     <span class="hljs-keyword">where</span> tabname.id=tabname2.id     <span class="hljs-keyword">and</span> tabname2.name=<span class="hljs-string">'name'</span>);<span class="hljs-comment"># 这时,子查询先根据 id 来关联外部表 tabname ,通过 explain 我们可以看到子查询是一个相关子查询(DEPENDENT SUBQUERY)</span><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> test.tabname2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'name'</span>);<span class="hljs-comment"># +----+--------------------+----------+-----------------+---------------+---------+---------+------+------+-------------+</span><span class="hljs-comment"># | id | select_type        | table    | type            | possible_keys | key     | key_len | ref  | rows | Extra       |</span><span class="hljs-comment"># +----+--------------------+----------+-----------------+---------------+---------+---------+------+------+-------------+</span><span class="hljs-comment"># |  1 | PRIMARY            | tabname  | ALL             | NULL          | NULL    | NULL    | NULL |   30 | Using where | </span><span class="hljs-comment"># |  2 | DEPENDENT SUBQUERY | tabname2 | unique_subquery | PRIMARY       | PRIMARY | 4       | func |    1 | Using where | </span><span class="hljs-comment"># +----+--------------------+----------+-----------------+---------------+---------+---------+------+------+-------------+</span><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname<span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname2    <span class="hljs-keyword">where</span> tabname.id=tabname2.id <span class="hljs-keyword">and</span> tabname2.name=<span class="hljs-string">'name'</span>    );<span class="hljs-comment"># +----+--------------------+----------+--------+---------------+---------+---------+-----------------+------+-------------+</span><span class="hljs-comment"># | id | select_type        | table    | type   | possible_keys | key     | key_len | ref             | rows | Extra       |</span><span class="hljs-comment"># +----+--------------------+----------+--------+---------------+---------+---------+-----------------+------+-------------+</span><span class="hljs-comment"># |  1 | PRIMARY            | tabname  | ALL    | NULL          | NULL    | NULL    | NULL            |   30 | Using where | </span><span class="hljs-comment"># |  2 | DEPENDENT SUBQUERY | tabname2 | eq_ref | PRIMARY       | PRIMARY | 4       | test.tabname.id |    1 | Using where | </span><span class="hljs-comment"># +----+--------------------+----------+--------+---------------+---------+---------+-----------------+------+-------------+</span><span class="hljs-comment"># 然而,MySQL 的优化把不相关子查询变成了相关子查询,效率更低: 先扫描外层表,再逐个匹配内层表,如果外层表很大,这样效率降低更加明显</span></code></pre></div><h3 id="解决方案-使用连接查询"><a class="header-anchor" href="#解决方案-使用连接查询">⚡</a>解决方案:使用连接查询</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> tabname. * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> test.tabname2 <span class="hljs-keyword">using</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">where</span> tabname2.name=<span class="hljs-string">'name'</span>;<span class="hljs-comment"># +----+-------------+----------+--------+---------------+---------+---------+------------------+------+-------------+</span><span class="hljs-comment"># | id | select_type | table    | type   | possible_keys | key     | key_len | ref              | rows | Extra       |</span><span class="hljs-comment"># +----+-------------+----------+--------+---------------+---------+---------+------------------+------+-------------+</span><span class="hljs-comment"># |  1 | SIMPLE      | tabname2 | ALL    | PRIMARY       | NULL    | NULL    | NULL             |   20 | Using where | </span><span class="hljs-comment"># |  1 | SIMPLE      | tabname  | eq_ref | PRIMARY       | PRIMARY | 4       | test.tabname2.id |    1 |             | </span><span class="hljs-comment"># +----+-------------+----------+--------+---------------+---------+---------+------------------+------+-------------+</span><span class="hljs-comment"># 这次可以看到,select_type 变为两个简单查询simple</span><span class="hljs-comment"># 首先访问的是 tabname2,因为表 tabname2 的记录比较少,只需该表全表扫描,再查询子查询</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 博客( fluid 主题)升级记录</title>
    <link href="/2020/7/26/hexo-%E5%8D%9A%E5%AE%A2(fluid%E4%B8%BB%E9%A2%98)%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/7/26/hexo-%E5%8D%9A%E5%AE%A2(fluid%E4%B8%BB%E9%A2%98)%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p>更新相关软件版本</p> <!-- more --> <div class="hljs"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 安装更新 npm</span>sudo <span class="hljs-built_in">npm</span> install -g <span class="hljs-built_in">npm</span><span class="hljs-comment"># 安装更新 npm-check</span>sudo <span class="hljs-built_in">npm</span> install -g <span class="hljs-built_in">npm</span>-check<span class="hljs-comment"># 安装更新 npm-upgrade</span>sudo <span class="hljs-built_in">npm</span> install -g <span class="hljs-built_in">npm</span>-upgrade<span class="hljs-comment"># 运行 check</span>sudo <span class="hljs-built_in">npm</span>-check<span class="hljs-comment"># 运行 upgrade</span>sudo <span class="hljs-built_in">npm</span>-upgrade<span class="hljs-comment"># 更新 upgrade(全局组件)</span>sudo <span class="hljs-built_in">npm</span> update -g<span class="hljs-comment"># 更新 upgrade (生产环境依赖包)</span>sudo <span class="hljs-built_in">npm</span> update --save<span class="hljs-comment"># 更新 hexo-cli</span>sudo <span class="hljs-built_in">npm</span> i hexo-cli -g</code></pre></div></li><li><p>更新主题</p><ol><li><p>去 github 上面下载,直接解压包到相应 hexo 的 theme 文件夹</p></li><li><p>修改 hexo 根目录的 _config.yml 文件,设置最新主题名</p></li><li><p>运行 <code>hexo clean</code>,<code>hexo s</code>查看即可</p></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- explain 执行计划</title>
    <link href="/2020/7/26/MySQL-%E7%9F%A5%E8%AF%86-explain-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2020/7/26/MySQL-%E7%9F%A5%E8%AF%86-explain-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="explain-查询字段"><a class="header-anchor" href="#explain-查询字段">⚡</a>explain 查询字段</h2><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">The SELECT identifier:select 标识符,表示执行顺序</td></tr><tr><td style="text-align:center">select_type</td><td style="text-align:center">The SELECT type:查询类型</td></tr><tr><td style="text-align:center">table</td><td style="text-align:center">The table for the output row: 表名</td></tr><tr><td style="text-align:center">partitions</td><td style="text-align:center">The matching partitions:使用的哪些分区(对于非分区表值为null)</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">The join type: join 类型</td></tr><tr><td style="text-align:center">possible_keys</td><td style="text-align:center">The possible indexes to choose:可能用到的索引</td></tr><tr><td style="text-align:center">key</td><td style="text-align:center">The index actually chosen:实际选择的索引</td></tr><tr><td style="text-align:center">key_length</td><td style="text-align:center">The length of the chosen key:所选择索引的长度</td></tr><tr><td style="text-align:center">ref</td><td style="text-align:center">The columns compared to the index :显示索引的哪一列被使用了,可以是一个常数</td></tr><tr><td style="text-align:center">rows</td><td style="text-align:center">Estimate of rows to be examined:预计检查行数</td></tr><tr><td style="text-align:center">filtered</td><td style="text-align:center">Percentage of rows filtered by table condition:通过过滤条件之后对比总数的百分比</td></tr><tr><td style="text-align:center">Extra</td><td style="text-align:center">Additional information:其他信息,如 using file sort,using index,using index condition,using join buffer,using where</td></tr></tbody></table><h3 id="id"><a class="header-anchor" href="#id">⚡</a>id</h3><blockquote><p>The SELECT identifier. This is the sequential number of the SELECT within the query. The value can be NULL if the row refers to the union result of other rows. In this case, the table column shows a value like &lt;unionM,N&gt; to indicate that the row refers to the union of the rows with id values of M and N.</p><p>翻译:<br>id 是 SELECT 的标识符.它是查询中 SELECT 的<strong>顺序号</strong></p><p>如果该行引用其他行的并集结果,则该值<em>可以为 NULL</em>,在这种情况下,table 字段会显示类似&lt;unionM，N&gt;的值，以表示该行引用 ID 值为 M 和 N 的行的并集。</p></blockquote><p>也就是说,id 数字越大越先执行,如果说数字一样大,那么就从上往下依次执行,还有一种为 null 的情况,是由于这一行会 union 其他行的结果(其对应 select_type 为 union result)</p><h3 id="select-type"><a class="header-anchor" href="#select-type">⚡</a>select_type</h3><table><thead><tr><th style="text-align:center">select_type</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">SIMPLE</td><td style="text-align:center">Simple SELECT (not using UNION or subqueries): 简单查询,没有用到 union 或者子查询</td></tr><tr><td style="text-align:center">PRIMARY</td><td style="text-align:center">Outermost SELECT:最外层查询,即有 union 或者子查询的最外层查询,一个 SQL 整体语句有且仅有一个最外层查询</td></tr><tr><td style="text-align:center">UNION</td><td style="text-align:center">Second or later SELECT statement in a UNION: union 语句中,除了第一个表之外,第二和之后的查询都是 union</td></tr><tr><td style="text-align:center">DEPENDENT</td><td style="text-align:center">Second or later SELECT statement in a UNION, dependent on outer query: 与union一样，出现在union 或union all 语句中，但是这个查询要受到外部查询的影响</td></tr><tr><td style="text-align:center">UNION RESULT</td><td style="text-align:center">Result of a UNION: 包含 union 的结果集,在 union 和 union all 语句中,因为它不需要参与查询,所以id字段为null</td></tr><tr><td style="text-align:center">SUBQUERY</td><td style="text-align:center">First SELECT in subquery: 第一个出现的子查询. 即如果在 select 或者 where 里包含了子查询,那么子查询就是 subquery</td></tr><tr><td style="text-align:center">DEPENDENT SUBQUERY</td><td style="text-align:center">First SELECT in subquery, dependent on outer query: 和 subquery 一样,是第一个出现的子查询,并且它依靠外部查询.这就是**(相关子查询)**</td></tr><tr><td style="text-align:center">DERIVED</td><td style="text-align:center">Derived table SELECT (subquery in FROM clause): 派生表,from 子句中出现的子查询</td></tr><tr><td style="text-align:center">MATERIALIZED</td><td style="text-align:center">Materialized subquery</td></tr><tr><td style="text-align:center">UNCACHEABLE SUBQUERY</td><td style="text-align:center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td style="text-align:center">UNCACHEABLE UNION</td><td style="text-align:center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><blockquote><p>DEPENDENT typically signifies the use of a correlated subquery: dependent 一般代表用到相关子查询</p></blockquote><blockquote><p>DEPENDENT SUBQUERY evaluation differs from UNCACHEABLE SUBQUERY evaluation. For DEPENDENT SUBQUERY, the subquery is re-evaluated only once for each set of different values of the variables from its outer context. For UNCACHEABLE SUBQUERY, the subquery is re-evaluated for each row of the outer context.<br>DEPENDENT SUBQUERY 评估方式与 UNCACHEABLE SUBQUERY 不同.对于 DEPENDENT SUBQUERY,子查询仅针对其外部上下文中变量的每组不同值重新评估一次.对于UNCACHEABLE SUBQUERY,将为外部上下文的每一行重新评估子查询</p></blockquote><blockquote><p>The select_type value for non-SELECT statements displays the statement type for affected tables. For example, select_type is DELETE for DELETE statements<br>非 SELECT 语句的 select_type 值显示受影响表的语句类型.例如,对于 DELETE 语句,select_type 是 DELETE</p></blockquote><h3 id="table"><a class="header-anchor" href="#table">⚡</a>table</h3><blockquote><p>The name of the table to which the row of output refers. This can also be one of the following values:</p><p>&lt;unionM,N&gt; : The row refers to the union of the rows with id values of M and N.</p><p><derivedN> : The row refers to the derived table result for the row with an id value of N. A derived table may result, for example, from a subquery in the FROM clause.</p><p><subqueryN>: The row refers to the result of a materialized subquery for the row with an id value of N. See Section 8.2.2.2, “Optimizing Subqueries with Materialization”.</p><p>即: 通常是所查询的表名,或者表的别名,或者一个为查询产生临时表(如派生表、子查询、union 集合)的标示符</p></blockquote><h3 id="type"><a class="header-anchor" href="#type">⚡</a><strong>type</strong></h3><h4 id="system"><a class="header-anchor" href="#system">⚡</a>system</h4><blockquote><p>The table has only one row (= system table). This is a special case of the const join type.</p><p>只有一行数据,const 的特殊情况</p></blockquote><p>(如果是 Innodb，type 通常都是 all 或者 index)</p><h4 id="const"><a class="header-anchor" href="#const">⚡</a>const</h4><blockquote><p>The table has at most one matching row, which is read at the start of the query. Because there is only one row, values from the column in this row can be regarded as constants by the rest of the optimizer. const tables are very fast because they are read only once.</p><p>表最多具有一个匹配行,该行在查询开始时读取.因为只有一行,所以优化器的其余部分可以将这一行中列的值视为常量.const表非常快,因为它们只需要读取一次</p></blockquote><blockquote><p>const is used when you compare all parts of a PRIMARY KEY or UNIQUE index to constant values</p><p>当您将 PRIMARY KEY 或 UNIQUE 索引的所有部分与常量值进行比较时,将使用 const</p></blockquote><p>例如:</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name <span class="hljs-keyword">WHERE</span> primary_key=<span class="hljs-number">1</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name  <span class="hljs-keyword">WHERE</span> primary_key_part1=<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> primary_key_part2=<span class="hljs-number">2</span>;</code></pre></div><p>即: 针对唯一或者主键索引等值查询,查询条件是一个常量,从该表中读取最多一行</p><h4 id="eq-ref"><a class="header-anchor" href="#eq-ref">⚡</a>eq_ref</h4><blockquote><p>One row is read from this table for each combination of rows from the previous <a href="http://tables.It" target="_blank" rel="noopener">tables.It</a> is used when all parts of an index are used by the join and the index is a PRIMARY KEY or UNIQUE NOT NULL index.</p><p>对于先前表中的每行组合,从这一张表中读取一行.当 join 使用索引的所有部分并且索引是 PRIMARY KEY 或 UNIQUE NOT NULL 索引时,显示 eq_ref</p></blockquote><blockquote><p>eq_ref can be used for indexed columns that are compared using the = operator. The comparison value can be a constant or an expression that uses columns from tables that are read before this table.</p><p>eq_ref 可用于使用 = 运算符进行比较的索引列.比较值可以是常量,也可以是使用在此表之前读取的表中列的表达式</p></blockquote><p>例如:</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> ref_table,other_table  <span class="hljs-keyword">WHERE</span> ref_table.key_column=other_table.column;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> ref_table,other_table  <span class="hljs-keyword">WHERE</span> ref_table.key_column_part1=other_table.column  <span class="hljs-keyword">AND</span> ref_table.key_column_part2=<span class="hljs-number">1</span>;</code></pre></div><p>即: 唯一性索引扫描,对于每个来自于前面的表的记录,从该表中匹配到唯一一行,并且一般是等值匹配.驱动表只返回一行数据,且这行数据是第二个表的主键或者唯一索引,且必须为 not null.<br>也就是 t1 join t2,其关联条件都是主键或唯一索引,t1的一行,对应 t2 也只有一行(一般用到最左原则)</p><h4 id="ref"><a class="header-anchor" href="#ref">⚡</a>ref</h4><blockquote><p>All rows with matching index values are read from this table for each combination of rows from the previous tables. ref is used if the join uses only a leftmost prefix of the key or if the key is not a PRIMARY KEY or UNIQUE index (in other words, if the join cannot select a single row based on the key value). If the key that is used matches only a few rows, this is a good join type.</p><p>对于先前表中的每个行组合,将从该表中读取具有匹配索引值的所有行.如果 join 仅使用键的最左前缀,或者如果该键不是 PRIMARY KEY 或 UNIQUE 索引(换句话说,如果联接无法根据键值选择单个行),则使用ref.如果使用的键仅匹配几行,则这是一种很好的联接类型</p></blockquote><p>即: 非唯一性索引扫描,类似 eq_ref,只是关联条件只是普通索引,不是唯一或主键索引,t1 对应的 t2 会有多个匹配行</p><h4 id="ref-or-null"><a class="header-anchor" href="#ref-or-null">⚡</a>ref_or_null</h4><blockquote><p>This join type is like ref, but with the addition that MySQL does an extra search for rows that contain NULL values. This join type optimization is used most often in resolving subqueries</p><p>这种 join 类型类似于 ref,<strong>但是 MySQL 需要额外搜索包含 NULL 值的行</strong>.此联接类型优化最常用于解决子查询</p></blockquote><p>例如:</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> ref_table  <span class="hljs-keyword">WHERE</span> key_column=expr <span class="hljs-keyword">OR</span> key_column <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;</code></pre></div><h4 id="index-merge"><a class="header-anchor" href="#index-merge">⚡</a>index_merge</h4><blockquote><p>This join type indicates that the Index Merge optimization is used. In this case, the key column in the output row contains a list of indexes used, and key_len contains a list of the longest key parts for the indexes used</p><p>此 join 类型表示使用了索引合并优化.在这种情况下,输出行中的键列包含使用的索引列表,而 key_len 包含使用的索引的最长键部分的列表</p></blockquote><p>即: 使用同一张表的多个索引,将多个索引合并取交集或者并集,常见 and,or 的条件使用了不同的索引</p><h4 id="unique-subquery"><a class="header-anchor" href="#unique-subquery">⚡</a>unique_subquery</h4><blockquote><p>This type replaces eq_ref for some IN subqueries of the following form</p></blockquote><div class="hljs"><pre><code class="hljs sql">value IN (<span class="hljs-keyword">SELECT</span> primary_key <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> some_expr)</code></pre></div><blockquote><p>unique_subquery is just an index lookup function that replaces the subquery completely for better efficiency.</p><p>unique_subquery 只是一个索引查找函数,<strong>可以完全替换子查询以提高效率</strong></p></blockquote><h4 id="range"><a class="header-anchor" href="#range">⚡</a>range</h4><blockquote><p>Only rows that are in a given range are retrieved, using an index to select the rows. The key column in the output row indicates which index is used. The key_len contains the longest key part that was used. The ref column is NULL for this type.</p><p>使用索引选择行,仅检索给定范围内的行.输出行中的 key 指示使用哪个索引.key_len包含使用的最长的键部分。此类型的ref列为NULL。</p></blockquote><blockquote><p>range can be used when a key column is compared to a constant using any of the =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, LIKE, or IN() operators:</p></blockquote><p>即: 只检索给定范围的行，使用一个索引来选择行,而且可以是范围常量比较</p><h4 id="index"><a class="header-anchor" href="#index">⚡</a>index</h4><blockquote><p>The index join type is the same as ALL, except that the index tree is scanned. This occurs two ways:</p><p>index 的类型除了扫描的是索引树之外和 ALL 差不多，而扫描索引树只在下面两种情况下发生</p></blockquote><ul><li><blockquote><p>If the index is a covering index for the queries and can be used to satisfy all data required from the table, only the index tree is scanned. In this case, the Extra column says Using index. An index-only scan usually is faster than ALL because the size of the index usually is smaller than the table data.</p><p>如果索引是查询的覆盖索引，并且可用于满足表中所需的所有数据，则仅扫描索引树。在这种情况下，<code>Extra</code> 列显示 <code>using index</code>。仅索引扫描通常比ALL快，因为索引的大小通常小于表数据。</p></blockquote></li><li><blockquote><p>A full table scan is performed using reads from the index to look up data rows in index order. Uses index does not appear in the Extra column.</p><p>使用对索引的读取来执行全表扫描，是按照索引顺序查找数据行。<code>using index</code>不会出现在 <code>Extra</code> 列中。</p></blockquote></li></ul><p>即：如果是覆盖索引，那么在 <code>extra</code> 列中会显示 <code>using index</code>，而如果没有用到覆盖索引，那么就不会在 <code>extra</code>列中显示，查询方式为全索引扫描。</p><h4 id="fulltext"><a class="header-anchor" href="#fulltext">⚡</a>fulltext</h4><blockquote><p>The join is performed using a FULLTEXT index.</p><p>用到全文索引时显示</p></blockquote><p>要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p><h4 id="ALL"><a class="header-anchor" href="#ALL">⚡</a>ALL</h4><blockquote><p>A full table scan is done for each combination of rows from the previous tables. This is normally not good if the table is the first table not marked const, and usually very bad in all other cases. Normally, you can avoid ALL by adding indexes that enable row retrieval from the table based on constant values or column values from earlier tables.</p><p>对来自先前表的行的每个组合进行全表扫描。如果该表是未标记为const的第一个表，则通常不好，并且在所有其他情况下通常非常糟糕。通常，可以通过添加索引来避免ALL，这些索引允许基于早期表中的常量值或列值从表中检索行。</p></blockquote><h3 id="possible-keys"><a class="header-anchor" href="#possible-keys">⚡</a>possible_keys</h3><p>可能用到的索引</p><blockquote><p>If this column is NULL, there are no relevant indexes. In this case, you may be able to improve the performance of your query by examining the WHERE clause to check whether it refers to some column or columns that would be suitable for indexing. If so, create an appropriate index and check the query with EXPLAIN again</p><p>翻译: 如果此列为 NULL,则没有相关的索引.在这种情况下,你可以通过检查 WHERE 子句来检查它是否引用了某些适合索引的列,从而可以提高查询性能.如果是这样,请创建一个适当的索引,然后再次使用 EXPLAIN 检查查询</p></blockquote><h3 id="keys"><a class="header-anchor" href="#keys">⚡</a>keys</h3><p>实际用到的索引</p><blockquote><p>It is possible that key will name an index that is not present in the possible_keys value. This can happen if none of the possible_keys indexes are suitable for looking up rows, but all the columns selected by the query are columns of some other index. That is, the named index covers the selected columns, so although it is not used to determine which rows to retrieve, an index scan is more efficient than a data row scan.</p><p>可能会显示一个 possible_keys 中不存在的索引.如果没有一个 possible_keys 索引适合查找行,但是查询选择的所有列都是其他索引的列,则可能发生这种情况.也就是说,这个索引覆盖了选定的列,因此尽管不使用索引来确定要检索的行,但索引扫描比数据行扫描更有效(<strong>索引覆盖的情况?</strong>)</p></blockquote><blockquote><p>For InnoDB, a secondary index might cover the selected columns even if the query also selects the primary key because InnoDB stores the primary key value with each secondary index. If key is NULL, MySQL found no index to use for executing the query more efficiently.</p><p>对于 InnoDB,即使查询也选择了主键,辅助索引也可能覆盖选定的列,因为 InnoDB 将主键值与每个辅助索引一起存储</p></blockquote><p>(可以用 force index,use index 或者 ignore index,选择:使用/建议/不使用索引)</p><h3 id="key-len"><a class="header-anchor" href="#key-len">⚡</a>key_len</h3><blockquote><p>The key_len column indicates the length of the key that MySQL decided to use. The value of key_len enables you to determine how many parts of a multiple-part key MySQL actually uses. If the key column says NULL, the key_len column also says NULL.</p><p>key_len 指示 MySQL 决定使用的索引的长度.key_len 的值使您能够确定 MySQL 实际使用的联合索引的多少部分</p></blockquote><h3 id="ref-v2"><a class="header-anchor" href="#ref-v2">⚡</a>ref</h3><blockquote><p>The ref column shows which columns or constants are compared to the index named in the key column to select rows from the table.</p><p>ref 显示将哪些列或常量与 explain 中 key 列中列出的索引进行比较来从表中选择行</p></blockquote><p>即显示关联的字段.如果使用常数等值查询,则显示 const,如果是多个表连接查询,则会显示关联表的字段</p><blockquote><p>If the value is func, the value used is the result of some function. To see which function, use SHOW WARNINGS following EXPLAIN to see the extended EXPLAIN output. The function might actually be an operator such as an arithmetic operator.</p><p>如果该值为 func,则使用的值是某些函数的结果.要查看哪个函数,在 EXPLAIN 之后使用 SHOW WARNINGS 来查看扩展的 EXPLAIN 输出.该函数实际上可能是算术运算符之类的运算符</p></blockquote><p>即如果是 func,说明条件判断时进行了数据类型转换或者使用了表达式或函数</p><h3 id="rows"><a class="header-anchor" href="#rows">⚡</a>rows</h3><blockquote><p>The ref column shows which columns or constants are compared to the index named in the key column to select rows from the table.<br>For InnoDB tables, this number is an estimate, and may not always be exact.</p><p>rows列指示MySQL认为执行查询必须检查的行数。<br>对于 InnoDB,此数字是估计值</p></blockquote><h3 id="filtered"><a class="header-anchor" href="#filtered">⚡</a>filtered</h3><p>表示此查询条件所过滤的数据的百分比，将 rows 除以 filtered 可以估算出整个表数据行数。</p><blockquote><p>The filtered column indicates an estimated percentage of table rows that will be filtered by the table condition. The maximum value is 100, which means no filtering of rows occurred. Values decreasing from 100 indicate increasing amounts of filtering. rows shows the estimated number of rows examined and rows × filtered shows the number of rows that will be joined with the following table. For example, if rows is 1000 and filtered is 50.00 (50%), the number of rows to be joined with the following table is 1000 × 50% = 500.</p><p>表示被条件过滤的行数的估计百分比.最大值为100,这表示未过滤行.值从100减小表示过滤量增加.rows 显示检查的估计行数，filtered 显示将与下表连接的行数.例如,如果 rows 是1000,filtered 是 50.00(50％),则与下表连接的行数是 1000×50％= 500。</p></blockquote><h3 id="extra"><a class="header-anchor" href="#extra">⚡</a>extra</h3><blockquote><p>This column contains additional information about how MySQL resolves the query</p></blockquote><h2 id="附录"><a class="header-anchor" href="#附录">⚡</a>附录</h2><h3 id="extra-列的几种情况"><a class="header-anchor" href="#extra-列的几种情况">⚡</a>extra 列的几种情况</h3><ol><li><p>using index:</p><blockquote><p>The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index.</p><p>仅使用索引树中的信息从表中检索列信息，而不必进行其他查找以读取实际行。当查询仅使用属于单个索引的列时，可以使用此策略。</p></blockquote><blockquote><p>For InnoDB tables that have a user-defined clustered index, that index can be used even when Using index is absent from the Extra column. This is the case if type is index and key is PRIMARY.</p><p>对于具有用户定义的聚集索引的InnoDB表，即使 <code>Extra</code> 列中没有 <code>using index</code>，也可以使用索引。如果 <code>type</code> 列是 <code>index</code> 并且 <code>key</code> 列是<code>PRIMARY</code>，就是这种情况。</p></blockquote><p>即：在索引列上进行查找，使用到了索引覆盖；或者是 type 为 index 且 key 为 primary 的 InnoDB 表的情况。</p><p>如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表面索引用来读取数据而非执行查找动作。</p></li><li><p>using index condition</p><blockquote><p>Tables are read by accessing index tuples and testing them first to determine whether to read full table rows. In this way, index information is used to defer (“push down”) reading full table rows unless it is necessary.</p><p>通过访问索引元组并首先对其进行测试以确定是否读取完整的表行来读取表。这样，除非有必要，否则索引信息将用于延迟（“下推”）读取整个表行。</p></blockquote><p>即：索引下推，当取出记录的时候就进行过滤，过滤掉不必要的记录。</p></li><li><p>using filesort</p><blockquote><p>MySQL must do an extra pass to find out how to retrieve the rows in sorted order. The sort is done by going through all rows according to the join type and storing the sort key and pointer to the row for all rows that match the WHERE clause. The keys then are sorted and the rows are retrieved in sorted order.</p><p>MySQL必须额外进行一遍，以按排序顺序检索行。通过根据联接类型遍历所有行并存储与WHERE子句匹配的所有行的排序键和指向该行的指针，可以完成排序。然后对键进行排序，并按排序顺序检索行。</p></blockquote><p>使用文件排序，常出现在 order by 或者 group by 语句中，且排序成分没有用到索引，此时需要在 <strong>内存中</strong> 进行排序，由于使用索引排序会好于文件排序，一般这种情况为了减小 CPU 资源消耗都可以考虑添加索引进行优化。</p><blockquote><p>出现条件：在 order by 或者在 group by 排序的过程中，order by 的字段不是索引字段，或者 select 查询字段存在不是索引字段，或者 select 查询字段都是索引字段，但是 order by 字段和 select 索引字段的顺序不一致，都会导致 fileSort</p></blockquote></li><li><p>using join buffer (Block Nested Loop 或者 Batched Key Access 或者 hash join)</p><blockquote><p>Tables from earlier joins are read in portions into the join buffer, and then their rows are used from the buffer to perform the join with the current table. (Block Nested Loop) indicates use of the Block Nested-Loop algorithm, (Batched Key Access) indicates use of the Batched Key Access algorithm, and (hash join) indicates use of a hash join. That is, the keys from the table on the preceding line of the EXPLAIN output are buffered, and the matching rows are fetched in batches from the table represented by the line in which Using join buffer appears.</p><p>来自较早联接的表被部分读取到 join 缓冲区中，然后从缓冲区中使用它们的行来执行与当前表的联接。使用 Blocked Nested Loop 或者 Batched Key Access 或 hash join 算法进行具体连接。即，将缓冲EXPLAIN输出的前一行中的表中的键，并从出现“使用连接缓冲区”的行所代表的表中批量提取匹配的行。</p></blockquote><blockquote><p>Hash joins are available beginning with MySQL 8.0.18; the Block Nested-Loop algorithm is not used in MySQL 8.0.20 or later MySQL releases.</p><p>从MySQL 8.0.18开始，可以使用哈希联接。MySQL 8.0.20或更高版本的MySQL中未使用“块嵌套循环”算法。</p></blockquote></li><li><p>using temporary</p><blockquote><p>To resolve the query, MySQL needs to create a temporary table to hold the result. This typically happens if the query contains GROUP BY and ORDER BY clauses that list columns differently.</p><p>为了解决该查询，MySQL需要创建一个临时表来保存结果。如果查询包含GROUP BY和ORDER BY子句以不同方式列出列，则通常会发生这种情况。</p></blockquote></li><li><p>using where</p><p>MySQL 服务器会在存储引擎检索行后再根据 where 条件进行过滤。</p><blockquote><p>A WHERE clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the Extra value is not Using where and the table join type is ALL or index.</p><p>WHERE子句用于限制要与下一个表匹配或发送给客户端的行。除非你专门打算从表中获取或检查所有行，否则，如果 <code>Extra</code> 值不是 <code>using where</code> 并且表 <code>type</code> 是 <code>ALL</code> 或 <code>index</code>，则查询中可能存在一些问题。</p></blockquote><p>即：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。</p><p>查询条件中分为限制条件和检查条件。5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。<code>extra</code> 列显示 <code>using index condition</code></p></li><li><p>using MRR</p><blockquote><p>Tables are read using the Multi-Range Read optimization strategy.</p><p>使用 Multi-Range Read 优化策略读取表。</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-TCP/IP</title>
    <link href="/2020/7/17/%E8%AE%A1%E7%BD%91-TCP-IP/"/>
    <url>/2020/7/17/%E8%AE%A1%E7%BD%91-TCP-IP/</url>
    
    <content type="html"><![CDATA[<ul><li><p>[x] TCP/IP 是网络层和传输层协议,是协议簇</p></li><li><p>[x] 如何理解 TCP (两点)</p><p>TCP 是面向<strong>连接</strong>的<strong>可靠</strong>传输,这里有两点,一是连接,二是可靠</p><p>连接指的是两方要去通信肯定需要连接,连接可以是虚拟的,也可以是物理真实存在的</p><p>TCP 的连接是一对 Socket 套接字</p><p>可靠指的是两方是由 socket 中的一对 ip:prot 和 ip:port,当客户端发送数据时,由于 ip:port 和 ip:port 是网络上唯一的,保证了可靠性</p></li><li><p>[x] TCP连接三次握手的过程</p><ol><li><p>server 首先要处在 listen 状态监听端口</p></li><li><p>client 发送 SYN ,client 进入<strong>同步已发送</strong> syn-sent 状态</p><p>SYN =1,seq = x,x 是自己初始化的序列号</p></li><li><p>server 收到后(如果同意连接),会发出确认报文 SYN + ACK,server 进入<strong>同步收到</strong> syn-revd 状态</p><p>ACK = 1,SYN = 1,ack = x+1,seq = y</p><p>确认号 ack 是 x+1</p><p>y 是自己初始化的序列号</p></li><li><p>client 收到 server 发送的 ACK 之后,还要再给服务端发送确认报文 ACK,此时,TCP建立, client 进入已建立链接 established 状态,<strong>开辟资源</strong></p></li></ol><p>ack=1,ack=y+1,序列号 seq=x+1</p><ol><li>server 收到之后,进入 establish 状态,会<strong>开辟资源</strong>,此时双方可以开始通信了</li></ol></li><li><p>[x] TCP 连接为什么需要发送最后第三次确认呢?</p><p>如果使用的是两次握手建立连接,假设有这样一种场景:</p><p>客户端发送了第一个请求连接并且没有丢失,只是因为在网络结点中滞留的时间太长了,由于TCP的 client 以为服务器没有收到,此时<strong>重新</strong>向服务器发送这条报文</p><p>此后客户端和服务器经过两次握手完成连接,传输数据,然后关闭连接</p><p>此时此前滞留的那一次请求连接,网络通畅了到达了服务器,这个请求该是失效的,但是,两次握手的机制将会让客户端和服务器再次建立连接,但是再次建立连接之后没有传输任何数据,这会导致不必要的错误和资源的浪费</p><p>同样的场景,如果采用的是三次握手,就算是那一次失效的报文传送过来了,服务端接受到了那条失效报文并且回复了确认报文,但是客户端不会再次发出确认,由于服务器收不到确认,就不会开辟资源,避免了资源的浪费</p></li><li><p>[x] 四次挥手</p><ol><li><p>首先,server 和 client 都是 established 状态</p></li><li><p>client 发送连接释放报文 FIN,client 进入<strong>终止等待状态1</strong> fin-wait-1</p><p>fin =1,seq=u(前面已经传输的最后一个字节的序列号+1),</p></li><li><p>server 收到连接释放 FIN 之后,发出确认报文 ACK,此时服务端进入<strong>关闭等待</strong>状态 close-wait</p><p>ACK = 1,ack = u+1,seq = v</p><p>此时 client 处于半关闭状态,即 client 不会发送数据了,但是 server 端还可以发送数据让 client 接收</p></li><li><p>client 收到 server 发送的 ACK 之后,进入<strong>终止等待状态2</strong> FIN-WAIT-2</p></li><li><p>server 发送完数据后,再向 client 发送连接释放报文 FIN,此时 server 进入<strong>最后确认</strong>状态 LAST-ACK</p><p>FIN = 1,ack = u+1,seq = w</p></li><li><p>client 收到 FIN 之后,发送 ACK 确认,此时 client 进入<strong>时间等待</strong>状态 TIME-WAIT</p><p>ACK =1,ack = w+1,seq = u+1</p><p>此时 TCP 还没有释放,必须经过一个最长报文寿命 2*MSL 时间后,才进入 CLOSE 状态</p></li><li><p>server 收到 ACK 之后,立即进入 CLOSE 关闭状态</p><p>server 结束要比 client 早</p></li></ol></li><li><p>[x] 为什么客户端最后还要等待2MSL? (两点)</p><p>MSL(Maximum Segment Lifetime),TCP允许不同的实现可以设置不同的MSL值</p><p>第一,保证客户端发送的最后一个 ACK 报文能够到达 server</p><p>因为这个 ACK 报文可能丢失</p><p>站在服务器的角度来看,我已经发送了 FIN+ACK 报文请求断开了,客户端还没有给我回应,应该是我发送的请求断开报文它没有收到,于是服务器又会<strong>重新发送一次 FIN+ACK</strong></p><p>而客户端就能在这个 2MSL 时间段内收到这个重传的报文,接着给出回应报文,并且会重启2MSL计时器</p><p>所以,TIME_WAIT 状态就是用来接收 server 重发可能丢失的 FIN+ACK 报文,并重新发送 ACK</p><p>第二,防止类似与&quot;三次握手&quot;中提到了的&quot;已经失效的连接请求报文段&quot;出现在本连接中</p><p>客户端发送完最后一个确认报文后,在这个 2MSL 时间中,就可以使本连接持续的时间内所产生的所有报文段都从网络中消失,这样新的连接中不会出现旧连接的请求报文</p></li><li><p>[x] 为什么建立连接是三次握手，关闭连接确是四次挥手呢?</p><p>建立连接的时候,服务器在 LISTEN 状态下,收到建立连接请求的SYN报文后,把 ACK 和 SYN 放在一个报文里发送给客户端</p><p>而关闭连接时,服务器收到对方的 FIN 报文时,仅仅表示对方不再发送数据了但是还能接收数据,而自己也未必全部数据都发送给对方了,所以己方可以立即关闭,也可以发送一些数据给对方后,再发送 FIN 报文给对方来表示同意再关闭连接,因此,己方 ACK 和 FIN 一般都会分开发送,从而导致多了一次</p></li><li><p>[x] 如果已经建立了连接，但是客户端突然出现故障了怎么办?</p><p>TCP还设有一个保活计时器,显然,客户端如果出现故障,服务器不能一直等下去,白白浪费资源</p><p>服务器每收到一次客户端的请求后都会重新复位这个计时器,时间通常是设置为2小时,若两小时还没有收到客户端的任何数据,服务器就会发送一个探测报文段,以后每隔75秒发送一次</p><p>若一连发送10个探测报文仍然没反应,服务器就认为客户端出了故障,接着就关闭连接</p></li></ul><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">更深入</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>net</tag>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-HTTP</title>
    <link href="/2020/7/17/%E8%AE%A1%E7%BD%91-HTTP/"/>
    <url>/2020/7/17/%E8%AE%A1%E7%BD%91-HTTP/</url>
    
    <content type="html"><![CDATA[<ul><li><p>[x] HTTP 请求报文包括</p><ol><li><p>请求行</p></li><li><p>请求头</p></li><li><p>请求正文</p></li><li><p>空行</p></li></ol></li><li><p>[x] HTTP 响应报文包括</p><ol><li><p>状态行</p></li><li><p>响应头</p></li><li><p>响应正文</p></li><li><p>空行</p></li></ol></li><li><p>[x] 完整的HTTP请求所经历的7个步骤</p><ol><li><p>建立TCP连接</p><p>在 HTTP 工作开始之前,Web 浏览器首先要通过网络与 Web 服务器建立连接,该连接是通过 TCP 来完成的</p><p>HTTP 是比 TCP 更高层次的应用层协议,根据规则,只有低层协议建立之后才能进行更高层协议的连接</p></li><li><p>浏览器向Web服务器发送请求行</p></li><li><p>浏览器发送请求头</p><p>浏览器发送其请求命令之后,还要以头信息的形式向 Web 服务器发送一些别的信息,之后浏览器发送了一个空白行来通知服务器,它已经结束了该头信息的发送</p></li><li><p>服务器响应行</p><p>客户机向服务器发出请求后,服务器会客户机回送响应, <code>HTTP/1.1 200 OK</code>,应答的第一部分是协议的版本号和响应状态码</p></li><li><p>服务器发送响应头</p><p>正如客户端会随同请求发送关于自身的信息一样,服务器也会随同应答向用户发送关于它自己的数据及被请求的文档</p></li><li><p>Web服务器向浏览器发送数据</p><p>服务器向浏览器发送头信息后,它会发送一个空白行来表示头信息的发送到此为结束</p><p>接着,它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据</p></li><li><p>Web服务器关闭TCP连接</p><p>一般情况下,一旦服务器向浏览器发送了请求数据,它就要关闭 TCP 连接,然后如果浏览器或者服务器在其头信息加入了 <code>Connection:keep-alive</code></p><p>TCP 连接在发送后将仍然保持打开状态,于是,浏览器可以继续通过相同的连接发送请求</p><p>保持连接节省了为每个请求建立新连接所需的时间,还节约了网络带宽</p></li></ol><p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p></li><li><p>[x] POST 和 GET 区别 (四点)</p><ol><li><p>都包含请求头请求行,POST 多了请求 body</p></li><li><p>GET 参数是直接添加到 URL 后面的,直接就可以在 URL 中看到内容,而 POST 是放在报文内部的,用户无法直接看到</p></li><li><p>GET 提交的数据长度是有限制的,因为 URL 长度有限制,具体的长度限制视浏览器而定,而POST没有长度限制</p></li><li><p>约定俗成,GET 多用来查询,请求参数放在 URL 中,不会对服务器上的内容产生作用,POST 用来提交</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-HTTPS</title>
    <link href="/2020/7/17/%E8%AE%A1%E7%BD%91-HTTPS/"/>
    <url>/2020/7/17/%E8%AE%A1%E7%BD%91-HTTPS/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是HTTPS"><a class="header-anchor" href="#什么是HTTPS">⚡</a>什么是HTTPS?</h2><p>HTTPS 协议(HyperText Transfer Protocol over Secure Socket Layer): 一般理解为 HTTP+SSL/TLS = HTTPS,通过 SSL 证书来验证服务器的身份,并为浏览器和服务器之间的通信进行加密</p><p>SSL:Secure Socket Layer,安全套接字层</p><p>TLS(Transport Layer Security,传输层安全): 其前身是 SSL，它最初的几个版本(SSL 1.0、SSL 2.0、SSL 3.0) 由网景公司开发,1999年从 3.1 开始被 IETF 标准化并改名,发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本.SSL3.0和TLS1.0由于存在安全漏洞,已经很少被使用到.TLS 1.3 改动会比较大,目前还在草案阶段,目前使用最广泛的是 TLS 1.1、TLS 1.2</p><h2 id="浏览器在使用-HTTPS-传输数据的流程是什么-六点"><a class="header-anchor" href="#浏览器在使用-HTTPS-传输数据的流程是什么-六点">⚡</a>浏览器在使用 HTTPS 传输数据的流程是什么? (六点)</h2><ol><li><p>首先客户端通过 URL 访问服务器建立 SSL 连接,客户端会将生成一个随机数(client random),以及客户端支持的加密方法发送给服务端</p></li><li><p>服务端收到客户端请求后,会将网站支持的证书信息(证书中包含服务端的公钥)还有一个随机数(server random)传送一份给客户端</p></li><li><p>客户端的服务器开始协商 SSL 连接的安全等级,也就是信息加密的等级</p></li><li><p>客户端的浏览器根据双方同意的安全等级,生新成一个随机数(Premaster secret),然后利用服务端的公钥将生成的新随机数加密,并传送给服务端</p></li><li><p>服务器利用自己的私钥解密得到新随机数(Premaster secret),用(client random,server random,Premaster secret)生成对话密钥(session key)</p></li><li><p>服务器利用会话密钥加密与客户端之间的通信</p></li></ol><p><img src="https://pic4.zhimg.com/v2-a994fbf3094d737814fe01c2b919477b_r.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="为什么要用https-三点"><a class="header-anchor" href="#为什么要用https-三点">⚡</a>为什么要用https? (三点)</h2><ol><li><p>参数明文传输,不安全</p></li><li><p>数据的完整性未校验，容易被篡改</p></li><li><p>没有验证对方身份，存在冒充危险</p></li></ol><h2 id="HTTPS-的缺点-三点"><a class="header-anchor" href="#HTTPS-的缺点-三点">⚡</a>HTTPS 的缺点?(三点)</h2><ol><li><p>HTTPS 协议多次握手,导致页面的加载时间延长近50%</p></li><li><p>HTTPS 连接缓存不如 HTTP 高效,会增加数据开销和功耗</p></li><li><p>SSL 涉及到的安全算法会消耗 CPU 资源,对服务器资源消耗较大</p></li></ol><h2 id="HTTPS-和-HTTP-的区别-三点"><a class="header-anchor" href="#HTTPS-和-HTTP-的区别-三点">⚡</a>HTTPS 和 HTTP 的区别?(三点)</h2><ol><li><p>HTTPS 是 HTTP 协议的安全版本,HTTP 协议的数据传输是明文的,是不安全的,HTTPS 使用了 SSL/TLS 协议进行了加密处理</p></li><li><p>HTTP 和 HTTPS 使用连接方式不同,默认端口也不一样,HTTP 是80，HTTPS 是443</p></li><li><p>HTTP 属于应用层, HTTPS 由于加了 SSL,是应用层和传输层的结合</p></li></ol><h2 id="对称加密和非对称加密"><a class="header-anchor" href="#对称加密和非对称加密">⚡</a>对称加密和非对称加密?</h2><p>加密和解密同用一个密钥的方式称为<em>共享密钥加密</em>,也被叫做<em>对称密钥加密</em></p><p>共享加密方式加密时必须将密钥也发给对方</p><p>在互联网上转发密钥时,如果通信被监听那么密钥就会落入攻击者之手,同时也就失去了加密的意义</p><p>公开密钥加密方式很好地解决了共享密钥加密的困难:</p><p>公开密钥加密使用一对非对称的密钥:一把叫做私有密钥,另一把叫做公开密钥</p><p>使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的信息后,再使用自己的私有密钥进行解密</p><p>利用这种方式,不需要发送用来解密的私有密钥,也不用担心密钥被攻击者窃听而盗走</p><p>HTTPS采用共享秘钥加密和公开秘钥加密两者并用的<strong>混合加密</strong>机制</p><p>若密钥能够实现安全交换,那么有可能会考虑仅适用公开密钥加密来通信</p><p>但是公开密钥加密和共享密钥加密相比,处理速度要慢</p><p>公开密钥加密方式还是存在一些问题的,那就是无法证明公开密钥本身就是货真价实的公开密钥</p><p>例如当服务器发送公钥时被截取,然后替换了公钥,那么就会出现问题,所以解决办法是:数字证书认证机构 CA 颁发的公开密钥证书 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h2 id="如何保证-server-的公钥传到客户端时不被篡改呢"><a class="header-anchor" href="#如何保证-server-的公钥传到客户端时不被篡改呢">⚡</a>如何保证 server 的公钥传到客户端时不被篡改呢?</h2><blockquote><p>答: 1. 可信的第三方 CA 机构 2. 非对称加密</p></blockquote><p>HTTPS 中 RSA 非对称加密的两种模式:</p><ol><li><p>加密模式,保证数据传输方的数据安全性(不可被其他人读)</p><p>加密模式:私钥解密,公钥加密</p></li><li><p>认证模式,保证数据接受方的数据完整性(不可被其他人篡改)</p><p>认证模式: 私钥签名(加密),公钥认证(解密)</p></li></ol><p>CA 机构使用 CA 自己的私钥对 server 的公钥和 server 的一些信息统一<strong>加密/认证</strong>,生成数字证书.</p><p>当 client 请求 server 时,server 将信息正文,有信息正文生成的数字签名<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>和数字证书<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>一起发送给 client.</p><p>这样,client 在接收时会根据浏览器内置的受信任的 CA 机构列表判断发来的签发证书的机构是否有效,如果有效,那么使用对应 CA 机构内置的 CA 的公钥<strong>解密/认证</strong> CA 发送的证书,从中得到 server 的公钥,并且,使用 server 的公钥解密/认证数字签名,如果得到的结果和信息正文散列后的摘要一致,那么说明 server 的公钥是安全的,且信息正文没有被篡改.</p><p>因为,1. 如果 server 向 client 发送的信息中,server 的公钥被恶意第三方篡改,但是第三方无法拿到 CA 的私钥对数字证书重新加密认证;2. 而如果使用第三方自己的私钥加密认证,client 会提示这是不受信任的机构;3. 如果是只修改了信息正文,那么数字签名会不对应;4. 如果修改了信息正文并想重新生成对应的数字签名也是不可能的,因为加密摘要要使用 server 的私钥,第三方拿不到</p><ul><li><p>如果只是 server 自己签发数字签名和公钥以及信息正文,没有第三方 CA 机构:</p><p>server 的公钥散列生成摘要,并使用自己的公钥对公钥和 server 的一些信息统一<strong>加密/认证</strong>,生成数字证书发送给 client</p><p>但是中途还是有可能被第三方拦截,如果替换了 server 公钥还是无法察觉</p></li><li><p>如果只是颁发数字证书,没有数字签名,信息正文可能会被篡改</p></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>数字证书: 信任的 CA 机构颁发,证书 = CA 使用自己的 CA 私钥<strong>加密/认证</strong> server 的公钥以及一些 server 的其他信息后的结果 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>数字签名: 将信息散列<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>生成摘要<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>,并使用自己的私钥对摘要加密,即生成数字签名 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>散列: 散列不同于加密,散列即不可逆 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>例如使用 MD5 算法将一个原值生成散列值,而这个散列值不可反推回原来的值 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识 -- BKA 优化</title>
    <link href="/2020/5/25/MySQL-%E7%9F%A5%E8%AF%86-BKA-%E4%BC%98%E5%8C%96/"/>
    <url>/2020/5/25/MySQL-%E7%9F%A5%E8%AF%86-BKA-%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Batched Kay Access</p><a id="more"></a><ul><li><p>目的:</p><p>BKA 是指在表连接的过程中为了提升 join 性能而使用的一种 <code>join buffer</code>,其作用是在读取被 join 表的记录的时候使用顺序 IO</p></li><li><p>适用条件: BKA 被使用的标识是 explain 中 extra 信息为 Batched Key Access</p></li><li><p>好处:</p><ol><li></li></ol></li><li><p>工作原理:</p><p>BKA将有序主建投递到存储引擎是通过 MRR 的接口的调用来实现的</p><p>所以BKA 依赖 MRR，如果要使用BKA, MRR 是需要先打开的</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识-- Unsafe</title>
    <link href="/2020/4/30/Java-%E7%9F%A5%E8%AF%86-Unsafe/"/>
    <url>/2020/4/30/Java-%E7%9F%A5%E8%AF%86-Unsafe/</url>
    
    <content type="html"><![CDATA[<h2 id="关于-unsafe"><a class="header-anchor" href="#关于-unsafe">⚡</a>关于 unsafe</h2><a id="more"></a><ol><li><p>不能使用提供的 getInstance() 方法获取单例对象</p><p>unsafe 是单例的</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</code></pre></div> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;    Class var0 = Reflection.getCallerClass();    <span class="hljs-comment">// 此处做了限制,非根类加载器 bootstrap class loader 调用会报错</span>    <span class="hljs-keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<span class="hljs-string">"Unsafe"</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> theUnsafe;    &#125;&#125;</code></pre></div></li><li><p>要想获得 unsafe 实例</p><ol><li><p>反射</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">reflectGetUnsafe</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        Field field = Unsafe.class.getDeclaredField("theUnsafe");        field.setAccessible(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-keyword">null</span>);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    log.error(e.getMessage(), e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div></li><li><p>修改 JVM 参数,把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过 Unsafe.getUnsafe 方法安全的获取 Unsafe 实例。</p> <div class="hljs"><pre><code class="hljs shell">java -Xbootclasspath/a: $&#123;path&#125;<span class="hljs-meta">#</span><span class="bash"> 其中path为调用Unsafe相关方法的类所在jar包路径</span></code></pre></div></li></ol></li></ol><h2 id="CAS-相关"><a class="header-anchor" href="#CAS-相关">⚡</a>CAS 相关</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// var2 字段值增加 var4</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;    <span class="hljs-keyword">int</span> var5;    <span class="hljs-comment">// 自旋 + CAS</span>    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-comment">// 获取当前对象 var1 中 var2 字段的地址值</span>        <span class="hljs-comment">// 即从内存中获取字段的真实值</span>        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);        <span class="hljs-comment">// 如果 CAS 失败,那么重试</span>        <span class="hljs-comment">// 如果成功,跳出循环</span>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));    <span class="hljs-keyword">return</span> var5;&#125;</code></pre></div><p>var2 这个偏移量是通过:</p><div class="hljs"><pre><code class="hljs java">valueOffset = unsafe.objectFieldOffset(TargetObject.class.getDeclaredField("fileName"));</code></pre></div><p>对于任意一个类要修改的字段,可以通过这种方式传入类名和字段名来获取对象字段的内存地址</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识-- CAS</title>
    <link href="/2020/4/30/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CAS/"/>
    <url>/2020/4/30/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CAS/</url>
    
    <content type="html"><![CDATA[<p>CAS (Compare And Swap) (CompareAndSet): 比较并交换,比较并设定</p><a id="more"></a><p>CAS 是一种并发时用到的技术,其本质是一种算法</p><p>为了解决并发时修改共享变量的问题,传统的解决方式就是加锁,例如典型的 <code>synchronized</code> 关键字,但是加锁一般都是悲观锁,即首先认为每次都会进行多线程的竞争,所以首先加锁,其他线程需要阻塞直到锁释放</p><p>但是加锁可能会带来额外的性能开销,如果是对于轻量级的并发,或者只是线程交替执行,就可能显得很笨重</p><p>那么,乐观锁应运而生,而它的一个实现就是 CAS</p><p>乐观锁是首先认为没有其他线程会对同一个数据进行改变,而当真正去操作共享变量的时候,再去看共享变量有没有被更新,如果没有就进行一个原子性的业务操作(通过硬件支持将非原子性的操作变成原子性),反之操作失败</p><p>CAS 的思想当然也和上面的类似,只是具体实现细节需要我们探究</p><p>Java 中实现 CAS 的是 Unsafe 类,其中有一个本地方法</p><div class="hljs"><pre><code class="hljs java">compareAndSwapObject(Object var1, <span class="hljs-keyword">long</span> v2, Object v4, Object v5);</code></pre></div><p>其中 var1 就是要改变的类对象,v2 则是要修改的字段的内存地址,v4 则是未修改之前的预期值,v5 则是新的值</p><p>这个方法是通过 JNI 调用 Unsafe.cpp 文件的一个函数,而这个函数(在Linux 版本下)又是汇编语言的<code>cmpxchg</code>指令,所以实际上是硬件层面上提供的 API 实现的</p><p>CAS 产生的问题:</p><ol><li><p>只能对单一共享变量操作</p><p>如果需要对多个变量进行 CAS 同步更新,那么还是得加锁解决</p></li><li><p>ABA</p><p>如果一个线程 CAS 将 A 值改变成了 B,另一个线程再将 B 改变成了 A,然后又有一个线程看到的依然是 A,就会认为这个值一直是 A,没有改变,此时在将 A 改为 C,这样就覆盖了之前两个线程的操作</p><ul><li><p>解决办法是: 增加一个字段来标识整个对象的版本,一旦进行了修改,就改变版本号</p><p>JDK 的实现: AtomicStampedReference</p><p>将对象和一个版本戳组成一个内部类 pair,相比没有版本戳的例如 AtomicInteger 每次更新还需要传入预期的版本戳</p></li></ul></li><li><p>如果用到了 CAS + 自旋</p><p>如果 CAS 不成功,会一直自旋重试导致 CPU 占用资源</p><p>甚至类似产生死锁的问题,那么就会一直占用,更损耗性能</p><p>所以要根据情况选择是否要加入自旋,分场景考虑</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识- (杂谈) 高并发高可用 VS 多线程正确性</title>
    <link href="/2020/4/23/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%20(%E6%9D%82%E8%B0%88)%20%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8-VS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A3%E7%A1%AE%E6%80%A7/"/>
    <url>/2020/4/23/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%20(%E6%9D%82%E8%B0%88)%20%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8-VS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A3%E7%A1%AE%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="header-anchor" href="#写在前面">⚡</a>写在前面</h2><p>文章是学习并发编程的时候,觉得并发编程难学,想到什么情况下需要用到并发编程,然后想到了一些情况,故记录之</p><a id="more"></a><p>我认为最主要的两个场景应该是:</p><ol><li><p>使用的人变多了,被迫需要高并发高可用</p></li><li><p>其次就是要将大任务进行一个拆分,需要使用多线程提高速度和效率</p></li></ol><h2 id="正文"><a class="header-anchor" href="#正文">⚡</a>正文</h2><p>假设我们现在有两个业务场景,一个是支付宝转账,一个是淘宝秒杀(抢火车票另说)</p><p>现在我们想想,哪个场景高可用高并发是要完全保证的,哪个场景是正确性优先的</p><p>这个时候你又会问了,为什么要有优先呢?不能两个都保证吗?</p><p>这里不讲原因,先摆事实:</p><p>你去支付宝还花呗或者微信提现的时候,是不是一般都会提示你,<code>业务正在审核/处理,两个小时内完成/到帐</code>,这个就是个铁证:</p><p>因为设计到转账,必须保证金额的正确性,加少了减少了谁负责?而对于并发量没有很高的要求(一不要求实时到账,二也没有那么多人会对同一个账户进行转账操作)</p><p>所以这些操作一般都是有一个最低时效,在时效内部,实际上是不保证操作的正确性的,例如:账也转了,钱也扣了,但是对方可能根本就没有收到,后台程序实际上还在处理后半部分的业务,这样就没有保证高可用(立刻响应,立刻处理完成),而完成了后面的业务处理之后,对方收到了款,才是一个真正的转账,最后才保证了正确性</p><hr><p>然后就是淘宝秒杀,对于这个场景,高可用则肯定是需要完全保证的</p><p>你可能又会问了,那是不是就可以不保证正确性了呢?</p><p>那也不是,这里说的正确性是,不能多卖,说白了,库存100件,你也要保证最多只卖100件,不能多卖了</p><p>但是!</p><p>这样也不是说同时满足了高并发和完全正确性,只能说是部分的正确性,或者说对于原则行问题保证正确性(当然的,因为不能把程序写的有问题是写程序的起码要求),非原则问题在<strong>一定程度上</strong>牺牲正确性来实现高可用</p><p>什么叫一定程度上?</p><p>例如秒杀的时候,你可能会去用一个锁把查看库存,付款,扣库存这三个操作给锁住,保证多线程同步</p><p>那么如果是并发量不太大可能可以,但是并发量很大,那么很多付款就会一直阻塞,用户看不到付款的结果,体验很差,而且,服务器产生很多线程阻塞,可能 CPU 飙高乃至当机</p><p>一个可以的解决方法就是,设置会一个超时的锁,如果线程在设定好的时间范围内没有获取到锁,那么就直接返回,告诉用户付款超时,稍后再试</p><p>这样就是保证了服务器提供的服务是高可用的,因为不会产生大量线程阻塞,导致服务没有办法响应或者处理速度很慢,一定时间内没有拿到锁就返回失败结果,如果拿到锁,立刻处理完成就成功,说白了就是立刻响应,立刻处理</p><p>但是,实际上,服务器立刻响应,返回失败结果的时候,不是说库存卖完了,有可能库存还有,仅仅只是你没有获取到锁(买东西的资格),跟库存多少其实根本没关系,这个就是上面我理解的在一定范围内,牺牲非原则性正确性来保证服务的高可用</p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识-- ReentrantLock</title>
    <link href="/2020/4/21/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-ReentrantLock/"/>
    <url>/2020/4/21/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h2 id="ReentrantLock-初步设计思想"><a class="header-anchor" href="#ReentrantLock-初步设计思想">⚡</a>ReentrantLock 初步设计思想</h2><p>new 一个 ReentrantLock 之后,调用 lock 方法,改变锁的状态码,从0变为1,主线程获取到锁,然后继续执行</p><!-- more --><p>如果此时同一个线程多次调用则进行多次重入,状态码增加</p><p>如果是线程交替执行,即并发度不是很高,那么就不存在锁的竞争,可以依次获取锁,然后依次释放,循环往复,保证高性能高可用</p><p>但是如果并发度很大,那么就一定存在线程之前对锁的竞争,这时,如果是公平锁,那么先获取锁的线程先处理,后获取锁的排在一个等待队列,然后这个线程就 <code>park</code> 暂停,然后等待锁释放和通知,<code>unpark</code> 后,再去获取锁</p><p>(注意:此处的 park 和 unpark 只是一种抽象概念,不一定指 LockSupport 里面的方法,也可以是 interrupt 中断)</p><p>但是,这里虽然想的很容易理解,但是要实现却不是那么容易,且看我如下分析</p><h2 id="ReentrantLock-类数据结构"><a class="header-anchor" href="#ReentrantLock-类数据结构">⚡</a>ReentrantLock 类数据结构</h2><h3 id="ReentrantLock-抽象内部类-Sync-锁"><a class="header-anchor" href="#ReentrantLock-抽象内部类-Sync-锁">⚡</a>ReentrantLock 抽象内部类 Sync 锁</h3><p>图 ReentrantLockSyncAndExtend:</p><p><img src="/img/ReentrantLockSyncAndExtend.png" srcset="/img/loading.gif" alt="ReentrantLockSyncAndExtend"></p><p>图 ReentrantLockSyncAndExtend1:<br><img src="/img/ReentrantLockSyncAndExtend1.png" srcset="/img/loading.gif" alt="ReentrantLockSyncAndExtend1"></p><p>从源码和上图可知, Sync 只有第一个 <code>lock()</code> 方法是抽象的,有一个默认的非公平的 <code>nonFairTryAcquired(int)</code> 方法,这个方法是<strong>尝试</strong>获取锁的,并且是一种非公平的方式</p><h2 id="Sync-的公平锁具体实现"><a class="header-anchor" href="#Sync-的公平锁具体实现">⚡</a>Sync 的<strong>公平锁</strong>具体实现</h2><p>图 AQSAbstractTryAcquire:</p><p><img src="/img/ReentrantLockFairSync.jpg" srcset="/img/loading.gif" alt="ReentrantLockFairSync"></p><p>一个 lock 方法,一个 tryAcquire 方法</p><p>lock 方法是 Sync 的具体实现,而 tryAcquire 则是<strong>重写</strong>了 Sync 的父类 AQS 的方法</p><p><span id="ReentrantLockFairSync1">图 ReentrantLockFairSync1</span><br><img src="/img/ReentrantLockFairSync1.jpg" srcset="/img/loading.gif" alt="ReentrantLockFairSync1"></p><h2 id="ReentrantLock-加锁过程-公平锁"><a class="header-anchor" href="#ReentrantLock-加锁过程-公平锁">⚡</a>ReentrantLock 加锁过程 (公平锁)</h2><h3 id="第一次加锁"><a class="header-anchor" href="#第一次加锁">⚡</a>第一次加锁</h3><ol><li><p>new 是默认非公平锁(这里分析公平锁)</p> <div class="hljs"><pre><code class="hljs java">sync = <span class="hljs-keyword">new</span> FairSync();</code></pre></div></li><li><p>当程序中调用 <code>reentrantLock.lock()</code> 方法时</p><p>lock() 方法就会调用 <code>sync.lock()</code> 方法</p><p>(sync 锁具体实现 lock 方法的 非公平的锁和公平锁不同)</p><p>由上面两张图可知,在 <code>lock()</code> 方法里面直接调用的是 <strong>AQS</strong> 的 <code>acquire(int)</code> 方法, 并且参数为1</p></li><li><p>那我们再去看 AQS</p><p><span id="AQSAcquire"><img src="/img/AQSAcquire.jpg" srcset="/img/loading.gif" alt="AQSAcquire"></span></p><p>我们可以看到首先会调用 <code>tryAcquire(int)</code> 方法,这也是 AQS 中的一个方法,我们可以根据名称猜测这个方法是用来<em>尝试获取锁</em>的</p><p>点进去,发现:</p><p><img src="/img/AQSAbstractTryAcquire.png" srcset="/img/loading.gif" alt="AQSAbstractTryAcquire"></p><p>仅仅抛一个异常?!</p><p>这当然不可能,因为这样没有任何意义</p><p>再按住 <code>ctrl</code>和<code>alt</code>,鼠标点击 <code>tryAcquire</code>,出现如下具体实现:</p><p><img src="/img/AQSAbstractTryAcquire1.jpg" srcset="/img/loading.gif" alt="AQSAbstractTryAcquire2"></p><p>我们点击第一个,发现回到了 ReentrantLock 里面的 FairSync 静态内部类的 <code>tryAcquire(int)</code> 方法, <a href="#ReentrantLockFairSync1">见图 ReentrantLockFairSync1</a></p><p>这说明,内部的公平锁自己重写了 AQS 的方法但是没有加 <strong><code>@Override</code></strong> 注释!</p></li><li><p>再回到 ReentrantLock 看这个公平锁的 <code>tryAcquired(int)</code> 方法(和<a href="#ReentrantLockFairSync1">图ReentrantLockFairSync1 一样,只是把代码贴出来了</a>)</p><p>具体分析见<span id="ReentrantLockFairSyncTryAcquire">注释:</span></p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;    <span class="hljs-comment">// 拿到当前线程</span>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();    <span class="hljs-comment">// 拿到 AQS 的内部 volatile 变量 state</span>    <span class="hljs-keyword">int</span> c = getState();    <span class="hljs-comment">// 如果 state =0 说明此时没有线程拿到锁</span>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 第一个 hasQueuedPredecessors() 是 AQS 的内部方法,是用来判断自己需不需要排队</span>        <span class="hljs-comment">// 返回 false 在表示队列不存在或者队列中没有前驱(即队列中没有已经拿到锁的线程)</span>        <span class="hljs-comment">// 那么这个线程就不需要排队</span>        <span class="hljs-comment">// 为什么需要排队呢,最前面将思想的时候其实已经说了:</span>        <span class="hljs-comment">// 想想如果存在多线程竞争,而且又是公平锁,那么就需要排队等待,直到前面那个线程处理完了,后面的线程才能拿到锁,再去处理</span>        <span class="hljs-comment">// todo 这里理解排队要看之后的线程竞争或者其他特殊情况,我们这里假设的是第一个线程来拿锁,暂时不考虑,因为从开始到现在根本没有初始化队列(new FairSync 也没有初始化 Sync 父类的 AQS 队列)</span>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;                <span class="hljs-comment">// 下面调用 AQS 的 CAS 方法,原子操作,改变的是 AQS 内部的 state 变量</span>                <span class="hljs-comment">// CAS 尝试加锁</span>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;            <span class="hljs-comment">// 如果前面的条件成立,说明: 1. 自己不需要排队 2. 自己成功拿到锁了</span>            <span class="hljs-comment">// 此时就可以将锁设置为当前线程</span>            <span class="hljs-comment">// 注意,这个方法是 `AQS` 继承 `AOS` 这个抽象类自己内部的方法,表示是一个排他锁</span>            <span class="hljs-comment">// 关于 AOS 具体看下面相应的地方,这里就不多做解释,现在就认为是一个排他锁</span>            setExclusiveOwnerThread(current);             <span class="hljs-comment">// 返回 true,表示成功加上了排他锁</span>            <span class="hljs-comment">// 第一个线程到这里返回</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    <span class="hljs-comment">// 又有一个线程来了,如果锁状态不为0,说明已经加锁,并且该线程就是之前加锁的第一个线程,此时会重入,state +1,并返回 true,代表重入锁加锁成功</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;        <span class="hljs-comment">// 可能在这里会想,c 是最前面 getState() 方法得到的,为什么这里不用 CAS 来保证原子操作呢?</span>        <span class="hljs-comment">// 因为其它的线程如果来了,会首先排队,不会改变第一个线程的状态值</span>        <span class="hljs-comment">// 但是如果第一个线程此时刚好释放所了,岂不是重入错了?</span>        <span class="hljs-comment">// 这里就要看上面的 else-if 判断了,如果是同一线程重入,然后释放,然后再加锁是不可能的,一个线程怎么可能同时加锁和解锁呢!</span>        <span class="hljs-comment">// 上面是目前我的分析,如果加上锁自动释放(超时释放)的功能 tryLock 可能会有问题?</span>        <span class="hljs-comment">// 解答: tryLock 是在指定时间内获取锁,而不是在指定时间内释放拿到的锁,拿到锁释放必须由这个线程显式调用 unLock 方法,所以根本不会存在自动释放锁这个逻辑</span>        <span class="hljs-comment">// 超时释放指的是超过时间没有拿到就放弃抢锁,不是超时了就释放锁</span>        <span class="hljs-keyword">int</span> nextc = c + acquires;        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);        setState(nextc);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 如果锁状态不为0,并且是另一个线程来加锁,会返回 false</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p>关于 <code>hasQueuedPredecessors() </code> 方法,放到 AQS 章节再讲,这些 AQS 内部方法也有很多需要分析</p></li><li><p>方法 <code>tryAcquire(int)</code> 返回 true,回到<a href="#AQSAcquire">前面 AQS 的 acquire</a></p><p>此时 if 条件不成立,直接返回了,然后递归返回,就没有什么,结束程序中的 <code>reentrantLock.lock()</code> 方法,加锁成功,主程序继续执行</p></li></ol><h3 id="如果此时第一个线程又来加锁-重入"><a class="header-anchor" href="#如果此时第一个线程又来加锁-重入">⚡</a>如果此时第一个线程又来加锁(重入)</h3><p>此时在 <code>ReentrantLock</code> 中的 <code>FairSync</code> 的 <code>tryAcquire(int)</code> 方法里面,进入 else 判断,<a href="#ReentrantLockFairSyncTryAcquire">请看代码注释 else-if 部分</a></p><p><code>tryAcquire(int)</code> 返回 true, 然后也是和第一次拿到锁一样,调用递归返回,主程序继续执行</p><p>不过需要注意,<code>FairSync</code> 公平锁的父类 AQS 的内部状态 volatile 变量 state 每次都要加一,而每次释放锁的时候,state 才会减一,最后一定要变为0才释放了所有锁</p><h3 id="如果是第二个线程来了-也开始加锁-并且此时第一个线程还没有释放锁"><a class="header-anchor" href="#如果是第二个线程来了-也开始加锁-并且此时第一个线程还没有释放锁">⚡</a>如果是第二个线程来了,也开始加锁,并且此时第一个线程还没有释放锁</h3><ol><li><p>同上面两种情况,会调用 <code>sync.lock()</code> 方法,然后 <code>acquire(1)</code>,再然后 <code>tryAcquire(1)</code></p><p>但是此时 if 和 else 条件都不满足,会返回 false</p></li><li><p><a href="#AQSAcquire">此时AQS 的</a> <code>acquire(1)</code> 方法中 if 的第一个 <code>tryAcquire(1)</code> 取反,值为 true,进入 <code>acquiredQueue(addWaiter(Node.Exclusive,1))</code> 两个方法</p><p>这两个方法就不在这里分析了,因为这是属于 AQS 内部实现,而且很复杂,需要单独说</p><p>我们现在就只需要知道,这里第二个线程就会去在 AQS 内部排队等待</p><p>再然后,会调用 <code>selfInterrupt()</code> 方法,这个 AQS 方法比较简单,就把代码截出来了</p><p><img src="/img/AQSSelfInterrupt.png" srcset="/img/loading.gif" alt="AQSSelfInterrupt"></p><p>把当前线程中断,来让出 CPU 等待 AQS 的唤醒</p></li></ol><h2 id="ReentrantLock-加锁过程-非公平锁"><a class="header-anchor" href="#ReentrantLock-加锁过程-非公平锁">⚡</a>ReentrantLock 加锁过程 (非公平锁)</h2><p><span id="ReentrantLockNonFairSync">如图 ReentrantLockNonFairSync:</span></p><p><img src="/img/ReentrantLockNonFairSync.png" srcset="/img/loading.gif" alt="ReentrantLockNonFairSync"></p><h3 id="第一次加锁-v2"><a class="header-anchor" href="#第一次加锁-v2">⚡</a>第一次加锁</h3><ol><li><p>有源码和上图知,调用 <code>ReentrantLock.lock()</code> 方法时,会调用上图中非公平锁 NonFairSync 的方法</p><ol><li><p>首先会 CAS 直接尝试抢占锁,如果抢到了就直接上锁,程序正常返回</p><p>就是比公平锁少了一个判断方法 <code>!hasQueuedPredecessors()</code> 来判断需不需要排队</p><p>非公平锁当然不需要排队啦~</p></li><li><p>如果没有没有直接抢到,那么其实还是要排队,调用 AQS 的 <code>acquire()</code> 方法</p><p>注意,这个时候就不要认为之后的逻辑和公平锁一模一样,因为锁在继承 <code>AQS</code> 的实现的时候,都重写了 <code>AQS</code> 的 <code>tryAcquire()</code> 方法</p><p>对于非公平锁来说,它默认使用的是 <code>ReentrantLock</code> 类中 <code>Sync</code> 父类里面的 <code>nonFairTryAcquire()</code> 方法</p><ol><li><p>nonFairTryAcquire()</p><p><img src="/img/ReentrantLockNonFairTryAcquire.png" srcset="/img/loading.gif" alt="ReentrantLockNonFairTryAcquire"></p><p>和公平锁的实现没有太大差别,仅仅只是少了 <code>hasQueuedPredecessor()</code> 这个重要的查看队列的方法,会上来就去尝试获取锁,而不考虑是否存在等待队列</p></li></ol></li></ol></li></ol><h3 id="重入情况则和公平锁一致"><a class="header-anchor" href="#重入情况则和公平锁一致">⚡</a>重入情况则和公平锁一致</h3><p><a href="#ReentrantLockFairSyncTryAcquire">同上的 else-if</a></p><h3 id="第二个线程来加锁了"><a class="header-anchor" href="#第二个线程来加锁了">⚡</a>第二个线程来加锁了</h3><p>假设存在线程竞争,那么根据 <a href="#ReentrantLockNonFairSync">图</a>,和公平锁一样,还是会进入上图的 <code>nonFairTryAcquire()</code>,然后返回 false,然后调用 AQS 的 <code>addWaiter()</code> 和 <code>acquireQueued()</code> 加入到等待队列中,<code>selfInterrupt()</code>方法自我中断</p><h2 id="ReentrantLock-解锁过程"><a class="header-anchor" href="#ReentrantLock-解锁过程">⚡</a>ReentrantLock 解锁过程</h2><h3 id="线程调用了-unLock"><a class="header-anchor" href="#线程调用了-unLock">⚡</a>线程调用了 unLock</h3><p><img src="/img/ReentrantLockSyncUnLock.png" srcset="/img/loading.gif" alt="ReentrantLockSyncUnLock"></p><p>然而这个 <code>release(1)</code> 方法又是 AQS 内部的方法:</p><p><img src="/img/AQSRelease.png" srcset="/img/loading.gif" alt="AQSRelease"></p><p>从上面可以看到,这里首先调用了一个 <code>tryRelease(1)</code> 方法</p><p><img src="/img/ReentrantLockTryRelease.png" srcset="/img/loading.gif" alt="ReentrantLockTryRelease"></p><ol><li><p><code>tryRelease()</code> 方法</p><p>这个是 <code>ReentrantLock</code> 内部 <code>Sync</code> 自己实现的默认方法,并且公平锁和非公平锁调用一致</p><p>由于锁可以重入,所以这里 <code>getState()</code> 获取到的状态值可能大于1,所以此处要减去参数 release (=1) 拿到预期值</p><p>然后进行判断,如果不是锁持有的线程拿到锁会抛出异常(一般不会出现)</p><p>如果上面预期的状态值等于0,则说明锁可以释放,此时就把共享锁设为空;反之,不进行该操作</p><p>(注意:锁为空并不代表锁已经释放,因为锁的状态是由 state 字段标识的,此时并没有改锁的状态)</p><p>然后改变锁的状态 <code>setState()</code>,并且返回释放锁的结果</p><p>想想这里改变状态为什么不用 CAS 操作?原因其实上面提到一些</p><p>因为此时线程又不可能重入(这个线程正在释放,怎么可能会重入),如果是别的线程,在 <code>setState()</code> 操作之前,锁还没有释放又不可能来抢锁,所以这里就可以安安心心的进行锁的状态改变了</p></li><li><p>tryRelease() 方法返回了,之后就是 AQS 的内部实现和状态判断了</p><p>老规律还是把这个实现留在讲 AQS 的文章里面集中分析吧</p><p>我们只需要知道此时锁已经释放,并且把 AQS 的内部状态 state 重置成 0,并且锁头已经置为空就行了</p></li></ol><h2 id="写在后面"><a class="header-anchor" href="#写在后面">⚡</a>写在后面</h2><p>AQS 和 ReentrantLock 代码,首先看子路老师的视频和马士兵的视频,然后对着源码一点点分析,做笔记,再结合博客看</p><p>自己再把 AQS 和 ReentrantLock 的类图先理清楚,有哪些内部类,哪些方法,哪些是抽象的,哪些是具体实现,分别做了什么,一层层理清楚</p><p>这篇文章仅仅分析了 ReentrantLock, 很多更重要的代码其实在 AQS 里面,具体分析就暂时等待 AQS 的文章吧</p><p>要不然,ReentrantLock 用到了 AQS 的一部分 api,我们就去看 AQS, 看了 AQS 又不知道像 <code>tryAcquire()</code> 和 <code>acquire()</code> 到底分别在什么情况下使用,又要回到 ReentrantLock 去看 api 的应用,让人云里雾里,非常头疼</p><p>其实也没有分析很多,<s>这么一想其实 ReentrantLock 还挺简单的</s></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- ICP 优化</title>
    <link href="/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-ICP-%E4%BC%98%E5%8C%96/"/>
    <url>/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-ICP-%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Index Condition Pushdown (ICP)</p><ul><li><p>目的: 在取出索引的同时,提前判断 where 条件,从而提前过滤一部分不符合条件的记录</p>  <a id="more"></a></li><li><p>适用条件:explain 的 type 为 range,ref,eq_ref,ref_or_null,而 Extra 可以看到 using index condition</p></li><li><p>好处: 减少上层 SQL 层对记录的索取,从而提升数据库的整体性能</p></li><li><p>工作方式:</p><p>如果没有 ICP,在进行索引查询时,首先会根据索引查找记录,然后再根据 where 条件来过滤</p><p>而使用 ICP 之后,存储引擎在取出索引的同时,会判断是否可以进行 where 条件过滤,也就是<strong>将 where 部分过滤操作放到了存储引擎层</strong>,在某些查询下,可以大大减少上层 SQL 层对记录的索取,从而提高数据库的整体性能</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- MRR 优化</title>
    <link href="/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-MRR%20%E4%BC%98%E5%8C%96/"/>
    <url>/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-MRR%20%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Multi-Range Read (MRR)</p><ul><li><p>目的:通过将随机 IO 排序,优化为顺序 IO 减少磁盘随机访问</p>  <a id="more"></a></li><li><p>命令: <code>set optimizer_switch='mrr=on';</code></p></li><li><p>适用条件: explain 的 type 为 range,ref,eq_ref 类型的查询,extra 会显示 using MRR</p></li><li><p>好处:</p><ol><li><p>MRR使<strong>辅助索引</strong>的回表访问变得较为顺序</p><p>在<strong>辅助索引</strong>中,首先根据得到的查询结果按照主键升序排序,再去回表查找</p><p>这样的好处是:</p><ol><li><p>磁盘和磁头不再需要来回做机械运动</p></li><li><p>可以充分利用磁盘预读</p><p>可以把后面可能用到的数据预先读出来</p></li><li><p>在一次查询中，每一页的数据只会从磁盘读取一次</p><p>即减少缓冲池中页被替换的次数,每次用完就不会重复再加载进来了</p></li></ol></li><li><p>批量处理对键值的查询操作</p></li><li><p>此外,MRR 还可以将某些范围查询,拆分为键值对,以此来进行批量数据查询</p><p>好处是在拆分过程中,直接过滤一些不符合查询条件的数据,保证取出的都是有效的数据,而不会直接先根据一个条件取数据,然后再根据第二个条件进一步过滤</p></li></ol></li><li><p>工作方式(InnoDB 和 MyISAM):</p><ol><li><p>优化器将二级索引查询到的记录放到一块缓冲区中,这时数据是根据二级键值排序的</p></li><li><p>如果二级索引扫描到文件的末尾或者缓冲区已满,则使用<strong>快速排序</strong>对缓冲区中的内容按照<strong>主键</strong>进行排序</p></li><li><p>用户线程调用 MRR 接口取 cluster index,然后根据 cluster index 取行数据</p></li><li><p>当根据缓冲区中的 cluster index 取完数据,则继续调用上述过程,直至扫描结束</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- InnoDB 和 MyISAM</title>
    <link href="/2020/4/15/MySQL-%E7%9F%A5%E8%AF%86-InnoDB-%E5%92%8C-MyISAM/"/>
    <url>/2020/4/15/MySQL-%E7%9F%A5%E8%AF%86-InnoDB-%E5%92%8C-MyISAM/</url>
    
    <content type="html"><![CDATA[<h2 id="区别"><a class="header-anchor" href="#区别">⚡</a>区别</h2><ol><li><p>InnoDB 支持事务,MyISAM 不支持事务</p> <a id="more"></a></li><li><p>InnoDB 是聚簇索引,MyISAM 是非聚簇索引</p><p>InnoDB 是聚簇索引,聚簇索引文件放在主键索引的叶子节点上,但是辅助索引需要两次查询:先查到主键,然后根据主键回表查到数据</p><p>对于 InnoDB 的聚集索引,就是<strong>表本身</strong></p><p>InnoDB 的聚集索引中,有主键列,事务 id,回滚指针,非主键列</p><p>MyISAM 是非聚簇索引,数据文件是分离的,索引保留的是数据文件的指针,主键索引和辅助索引是独立的</p></li><li><p>InnoDB 支持外键,MyISAM 不支持外键</p></li><li><p>InnoDB 不保存表的行数,MyISAM 保留了表的行数</p><p>所以 InnoDB 在 <code>count(*)</code> 会进行全表扫描</p></li><li><p>InnoDB 锁的最小粒度是行锁,MyISAM 最小粒度是表锁</p><p>MyISAM 在更新一行数据时会锁住整个表,限制并发量,这是 MySQL 5.2 将默认的 MyISAM 换成 InnoDB 的主要原因</p><p>不过 InnoDB 的行锁是实现在索引上的,所以如果没有命中索引行锁会退化成表锁</p></li><li><p>InnoDB 可以在崩溃后安全恢复,MyISAM 不行</p></li><li><p>InnoDB 键值一起保存，索引与数据一起载入InnoDB缓冲池;MyISAM键值分离，索引载入内存(key_buffer_size),数据缓存依赖操作系统</p></li></ol><h2 id="相同"><a class="header-anchor" href="#相同">⚡</a>相同</h2><p>索引都是 B+ 树结构</p>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识--索引</title>
    <link href="/2020/4/14/MySQL-%E7%9F%A5%E8%AF%86-%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/4/14/MySQL-%E7%9F%A5%E8%AF%86-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="几种索引"><a class="header-anchor" href="#几种索引">⚡</a>几种索引</h2><h3 id="聚集索引-聚簇索引-cluster-index-主键索引"><a class="header-anchor" href="#聚集索引-聚簇索引-cluster-index-主键索引">⚡</a>聚集索引 (聚簇索引 cluster index)(主键索引)</h3><p>聚集索引数据行的<strong>物理顺序</strong>与列值(一般是主键列)的逻辑顺序相同</p><a id="more"></a><p>注意,这里有一个很容易误解的点:</p><blockquote><p>这里说的是物理顺序,而不是物理上<strong>连续</strong></p><p>主要是由于是双向链表,而且会有页分裂时候的复制过程,那么在物理地址上,就肯定不是顺序的了</p></blockquote><p>聚簇表示数据行和相邻的键值(逻辑上)紧凑地存储在一起</p><p>因为无法同时把数据数据行存放在两个不同的地方,所以一个表中只能拥有<strong>一个聚集索引</strong></p><p>即对于 InnoDB 的聚集索引,就是表本身</p><ul><li><p>优点:</p><ol><li><p>把相关数据保存在一起,顺序读取,减少磁盘 IO</p></li><li><p>数据访问更快</p></li><li><p>覆盖索引扫描查询可以直接使用页节点的主键值</p></li></ol></li><li><p>缺点:</p><ol><li><p>虽然极大提高了 IO 密集应用的性能,但是如果数据全部放到内存中,访问顺序就没那么重要了</p></li><li><p>如果不是按照主键的顺序对表进行插入会非常慢(为了保持索引的物理顺序一致,可能在数据页中进行重排)</p></li></ol></li></ul><ol><li><p>更新索引列的代价很高,因为会强制将每个被更新的行移动到新的位置</p><ol><li><p>插入是可能面行页分裂问题,导致表占用更多的磁盘空间</p></li><li><p>可能导致全表扫描比较慢,尤其是行比较稀疏或者由于页分页导致数据存储不连续的时候</p></li><li><p>非聚簇索引可能要比想象的大,因为包含了所有引用行的主键列</p></li><li><p>回表成本</p></li></ol></li></ol><h3 id="非聚集索引-非聚簇索引-non-cluster-index-二级索引-辅助索引"><a class="header-anchor" href="#非聚集索引-非聚簇索引-non-cluster-index-二级索引-辅助索引">⚡</a>非聚集索引 (非聚簇索引 non cluster index)(二级索引,辅助索引)</h3><p>辅助索引是相对主键索引而言的,其实就是非聚集索引</p><p>聚集索引实际上不是一种单独的索引,而是一种数据存储方式</p><p>网上说:</p><blockquote><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的逻辑排列顺序是否一致</p></blockquote><p>实际上不对,我认为应该是:</p><p>聚集索引和非聚集索引的根本区别是聚集索引在叶子节点存储行,而非聚集索引则是存储指针</p><p>非聚集索引的叶子节点记录数据页的<strong>指针</strong>或者<strong>主键</strong>而不是数据,虽然不同引擎的非聚集索引都是指针,但是不同的引擎不同的指针类型不一样</p><p>MyISAM 引擎都是非聚集索引,而且索引的叶子节点存储的都是数据文件的指针</p><p>InnoDB 引擎的主键索引是聚集索引,主键索引叶子节点都是存一行记录,辅助索引是存储主键的值</p><p>在 InnoDB 里面主键索引是存储了<strong>一行的值</strong>,但是辅助索引(非聚集索引)仅仅存储<strong>主键</strong>,如果没有主键,则会自动选择一个可以唯一标识的字段,如果也没有,则存储默认隐含的 row id</p><p>如果用到了辅助索引,但是所选取的属性又没有存储,那么就会进行<strong>回表</strong>:先拿到主键,然后根据主键在主键索引上再进行查找,解决办法则可以用下面写到的覆盖索引</p><h3 id="覆盖索引-covering-index"><a class="header-anchor" href="#覆盖索引-covering-index">⚡</a>覆盖索引 (covering index)</h3><p>指查询语句的执行只用从索引中就能够获得,不必从表中读取,也可以称之为索引覆盖</p><p>一般多是联合索引</p><p>如果一个索引包含了(或覆盖了)查询语句中的字段和条件的数据就叫覆盖索引</p><p>索引覆盖成立时,SQL 只需要通过索引就可以返回查询的数据,避免了回表操作</p><p>覆盖索引使用 InnoDB 比 MyISAM 好,因为 InnoDB 使用聚集索引组织数据,如果二级索引中包含查询所需的数据,就不需要在聚集索引中查找了</p><p>explain 的 extra 中有 using index 表示用到了覆盖索引</p><p>(如果同时有 using index 和 using where 说明索引不仅仅用来读取数据,还被用来查找)</p><p>注意:</p><ol><li><p>覆盖索引一般不可 select *,而一般是索引中的,并且是所需要用到的列</p></li><li><p>不一定所有存储引擎都支持覆盖索引,并且不同的引擎实现方式都可能不同</p></li><li><p>Hash 索引和全文索引(FULL-Text)不存储值</p></li><li><p>最左匹配原则</p></li></ol><p>覆盖索引的优点:</p><ol><li><p>索引项一般比较小,可以访问更少的记录</p></li><li><p>索引按照值的大小记录,减少随机IO</p></li></ol><h3 id="全文索引-full-text-index"><a class="header-anchor" href="#全文索引-full-text-index">⚡</a>全文索引 (full text index)</h3><p>InnoDB 和 MyISAM 在 5.6 以后都支持全文索引</p><p>对于字符数量比较少的情况下,<code>like</code> 或者 <code>%</code> 都是常规解决方案,但是对于大量的文本数据检索，<code>like</code> 或者 <code>%</code> 是不可想象的</p><p>全文索引在大量的数据面前，能比 <code>like</code> 或者 <code>%</code> 快得多，速度不是一个数量级，但是全文索引可能存在精度问题</p><ul><li><p>倒排索引(inverted index): 它在辅助表中存储了单词和单词自身在一个或者多个文档中的位置映射,具体有两种表现形式:</p><ol><li><p>inverted file index,表现为 {单词,单词所在文档ID}</p></li><li><p>full inverted index,表现为 {单词,(单词所在文档ID,在文档中的具体位置)}</p></li></ol></li><li><p>InnoDB 采用 full inverted index 方式,将 (documentID,position)视为一个 ilist,单词视为 word,并且在 word 上建立索引</p><p>(word,ilist)就是两列,建立的表被称为 Auxiliary Table (辅助表),并且为了提升性能,一共有6张 Auxiliary Table</p><p>并且,由于有 position,所以可以进行模糊搜索</p></li><li><p>FTS Index Cache (全文检索索引缓存)</p><p>它是一个红黑树,根据(word,ilist)排序</p><p>所以可能写入数据的表已经更新,但是全文索引的更新数据还在 FTS 中,Auxiliary Table 还没有更新</p><p>InnoDB 会批量对 Auxiliary Table 进行批量更新,而不是一个个更新</p><p>这样当查询时,会首先将在 TFS 中对应的 word 字段合并到 Auxiliary Table 中,在进行查询</p><p>这种操作类似 Insert Buffer,不同的是 Insert Buffer 是持久对象,还是 B+ 树结构</p></li></ul><h3 id="哈希索引"><a class="header-anchor" href="#哈希索引">⚡</a>哈希索引</h3><p>基于哈希表实现</p><ul><li><p>缺点</p><ol><li><p>哈希冲突,对于每一个 hash 值相同的数据,查找时,必须进行逐行比较,而插入时也要维护相同 hash 值的数据</p></li><li><p>哈希索引只包含哈希值和行指针,而不存储字段值</p><ol><li><p>索引无法实现索引覆盖,必须回表</p></li><li><p>要么全部使用索引,要么不使用,无法使用部分索引加快查询速度</p></li><li><p>索引数据无法排序</p></li><li><p>必须精确匹配索引所有的列的查询才有效,不支持范围查询</p></li></ol></li></ol></li></ul><h3 id="其它索引"><a class="header-anchor" href="#其它索引">⚡</a>其它索引</h3><ul><li><p>外键索引: 对外键建立的索引,方便外键的级联</p></li><li><p>唯一索引: 索引值唯一</p></li></ul><h2 id="索引优化–建立高性能索引"><a class="header-anchor" href="#索引优化–建立高性能索引">⚡</a>索引优化–建立高性能索引</h2><ol><li><p>独立的列</p><p>SQL 语句的索引列不能是表达式的一部分,也不能是函数的参数 -&gt; 化简</p></li><li><p>前缀索引</p><p>如果索引是很长的字符列,使索引变得很大并且很慢,则可以在适当范围内降低索引的选择性,只对字符序列的前面几位建立索引</p><p>索引的选择性是指,不重复的索引值和记录总数的比值,选择性越高查询效率越高</p><p>缺点: 无法使用前缀索引做 order by 和 group by,也无法做覆盖扫描</p><p>如果有的列选择性都很低,例如 url 前面都是 www,那么我们可以尝试使用后缀索引,例如将 url 倒过来存 (类似的有爬虫中的倒排文档),再建立前缀索引</p></li><li><p>多列索引</p><p>MySQL 5.0 以后,其实查询可以同时使用多个单列索引进行扫描,并将结果合并 (explain 中 extra 的 <strong>index_merge</strong>)</p><p>虽然 MySQL 可以这样,但是实际上更多说明了表上的索引建的很糟糕:</p><blockquote><p>通常有多个 AND 条件,则一般需要包含所有相关列的多列索引,而不是多个独立的索引</p><p>通常有多个 OR 条件,则一般需要耗费大量 CPU 和内存资源在算法的缓存,排序和合并操作上,特别是索引的选择性不高,返回大量数据的时候</p><p>更重要的是,优化器不会把这些计算计算到查询成本中,优化器只关心随机读取</p><p>这样做不但更加消耗资源,还可能会影响查询的并发性</p></blockquote><p>在这种情况下,尽量建立多列索引甚至实现覆盖索引</p></li><li><p>选择合适的索引列顺序</p><blockquote><p>经验法则: 将选择性最高的索引放到最前列</p></blockquote><p>然而,这是不考虑排序和分组的情况下,只优化 where 条件的查找</p><p>如果可以的话,还是要考虑特殊的记录,例如,有一些特殊的记录,未登录的游客的session的记录查找就可能很庞大,这就需要我们在程序代码里面区分游客和普通用户了</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--JVM 和 JMM</title>
    <link href="/2020/4/14/JVM-%E7%9F%A5%E8%AF%86-JVM-%E5%92%8C-JMM/"/>
    <url>/2020/4/14/JVM-%E7%9F%A5%E8%AF%86-JVM-%E5%92%8C-JMM/</url>
    
    <content type="html"><![CDATA[<h2 id="JMM-解释"><a class="header-anchor" href="#JMM-解释">⚡</a>JMM 解释</h2><p>JMM (Java Memory Model) 定义了 Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM 是整个计算机虚拟模型，所以 JMM 隶属于 JVM</p><a id="more"></a><p>Java 虚拟机规范中试图定义一种 <code>Java 内存模型</code>,来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>,以实现 Java 程序在各种平台下都能达到一致的内存访问效果</p><p>JMM 主要目标就是定义程序中各个变量的访问规则,即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</p><p>JMM 决定一个线程对共享变量的写入何时对另一个线程可见</p><p>JMM 即 Java 线程之间的通信是采用共享内存模型</p><p>Java 内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步</p><p>这里的内存模型是指,在特定的操作协议下,对特定的内存或高速缓存进行读写访问的过程抽象</p><h2 id="JMM-问题和目标"><a class="header-anchor" href="#JMM-问题和目标">⚡</a>JMM 问题和目标</h2><p>当对象和变量可以存储在计算机中不同的内存区域时,会出现两个主要问题:</p><ol><li><p>线程更新(写)到共享变量的可见性</p></li><li><p>读取,检查和写入共享变量时的竞争条件</p></li></ol><p>JMM 是围绕并发过程中如何处理可见性,原子性和有序性这3个特征建立起来的</p><ol><li><p>可见性: volatile,synchronized,final</p></li><li><p>原子性: 一个操作或多个操作,要么全部执行不被打断,要么都不执行</p></li><li><p>有序性: 计算机在执行程序时,为了提高性能,会进行指令重排(包括: 编译器优化重排,指令并行重排,内存系统重排)</p><ol><li><p>as-if-serial: 即在指令重排时,无论怎么优化,单线程程序执行程序的结果不会改变</p></li><li><p>happens-before</p><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系</p><ol><li><p>程序顺序规则: 一个线程中的每个操作,happens-before 于线程中的任意后续操作</p></li><li><p>监视器锁规则: 一个锁的解锁,happens-before 于随后对这个锁的加锁</p></li><li><p>volatile 规则: 对一个 volatile 域的写,happens-before 于任意后续对这个 volatile 域的读</p></li><li><p>传递性: 如果 A happens-before B,且 B happens-before C,那么 A happens-before C</p></li></ol><blockquote><p>特别注意:</p><p>两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！</p><p>happens-before 仅仅要求前一个操作执行的结果对后一个操作<strong>可见</strong>,且前一个操作按顺序排在第二个操作之前</p></blockquote><p>最后一句话的意思是,前一个结果出来之后,后一个操作才能结束,前一个操作也可以比后一个操作后执行,但是一定是前一个操作先出结果</p></li></ol><p>这三个特征底层实现都是通过内存屏障实现的</p></li></ol><h2 id="JMM-结构"><a class="header-anchor" href="#JMM-结构">⚡</a>JMM 结构</h2><p><img src="/img/JMM.png" srcset="/img/loading.gif" alt="JMM"></p><p>(再看看和 CPU 的结构像不像)</p><p>当线程修改私有数据时,直接在工作空间修改</p><p>当线程1 和线程2 修改他俩共享的数据时,需要先从内存将数据复制到工作空间中,修改完成后,需要再刷入内存中</p><p>工作空间是 JMM 的一个抽象概念,并不真是存在,它包括了 cache, 寄存器等</p><ul><li><p>这样设计的好处是:</p><p>保证数据的<strong>隔离性</strong>,如果没有工作空间,一个线程读一个线程写,或者多个同时写入,就更容易混乱</p><p>而有了工作空间,<strong>读写分离</strong>,你修改你的变量,我读取甚至修改我的变量,相安无事</p></li><li><p>带来的缺点:</p><p>线程访问共享变量时,线程不安全</p><p>一个线程已经写完但是还没来得及刷入到内存中,但是另一个线程已经读入了,会导致脏数据</p></li></ul><h2 id="JMM-和-JVM-的区别和联系"><a class="header-anchor" href="#JMM-和-JVM-的区别和联系">⚡</a>JMM 和 JVM 的区别和联系</h2><ul><li><p>联系:</p><p>JVM 就是按照 JMM 来去划分的,而 JMM 又是</p><p>虚拟机栈和程序计数器就是工作空间</p></li><li><p>区别:</p><p>JVM 是将Java 虚拟机管理的内存空间的别名,是实际存在的存储空间</p><p>JMM 是规范,是抽象模型,并不真实存在</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 常用指令</title>
    <link href="/2020/4/11/MySQL-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/4/11/MySQL-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><p>修改字段 video 为 utf8mb4 编码</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> slaughter_sheep_info <span class="hljs-keyword">change</span> video video <span class="hljs-built_in">varchar</span>(<span class="hljs-number">250</span>) <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4</code></pre></div>  <a id="more"></a></li><li><p>查看表和字段 DDL 信息</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> slaughter_sheep_info</code></pre></div></li><li><p>修改数据库默认字符集编码</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> Sheep <span class="hljs-keyword">default</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4;</code></pre></div></li><li><p>查看数据库 DDL 信息</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> sheep</code></pre></div></li><li><p>导出</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment"># 表结构</span>mysqldump <span class="hljs-comment">--column-statistics=0 -h(ip) -P(port) -u(username) -p(password) -d (dbName) &gt; (dbName).sql;</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>shellCommand</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识--连接join</title>
    <link href="/2020/4/11/MySQL-%E7%9F%A5%E8%AF%86-%E8%BF%9E%E6%8E%A5join/"/>
    <url>/2020/4/11/MySQL-%E7%9F%A5%E8%AF%86-%E8%BF%9E%E6%8E%A5join/</url>
    
    <content type="html"><![CDATA[<ul><li><p>在 MySQL 中，只有一种 Join 算法，也就是 Nested Loop Join，没有其他很多数据库所提供的Hash Join，也没有Sort Merge Join</p><p>Nested Loop Join 实际上就是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果还有第三个参与Join，则再通过前两个表的Join 结果集作为循环基础数据，再一次通过循环查询条件到第三个表中查询数据，如此往复。</p></li><li><p>Nested Loop Join 就是多个表的for循环,以幂次增长</p>  <a id="more"></a><p>例如</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t2 <span class="hljs-keyword">on</span> t1.a = t2.a;<span class="hljs-comment"># 等价的是:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t1,t2 <span class="hljs-keyword">where</span> t1.a = t2.a;</code></pre></div><p>这时会以一个表作为<strong>驱动表</strong>,然后拿到一行记录就做为新的条件去另一个表过滤数据</p><p>类似</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(tt1 in t1)&#123;    <span class="hljs-keyword">if</span>(tt1 is <span class="hljs-keyword">true</span>)&#123;        <span class="hljs-keyword">for</span>(tt2 in t2)&#123;            <span class="hljs-keyword">if</span>(tt2 is <span class="hljs-keyword">true</span> <span class="hljs-keyword">for</span> condition)&#123;                <span class="hljs-keyword">return</span>            &#125;        &#125;    &#125;&#125;</code></pre></div></li><li><p>MySQL 就使用 BNL 算法以及 <code>join buffer</code> 优化:</p><p>BNL (Block Nested Loop Join)算法原理：将外层循环的行/结果集存入 join buffer,内存循环的每一行数据与整个 buffer 中的记录做比较,可以减少内层循环的扫描次数</p><ul><li><p>适用条件</p><p>join buffer 只有当我们的 join 类型为 ALL,index,rang 或者是index_merge 的时候才能够使用</p></li></ul>  <!-- 因为如果是表比较小还好,如果表很大,那么一次性可能不能从磁盘全部把驱动表加载进内存,那么读到一定程度就需要把前面读到的从内存中删掉,然后再从磁盘继续读,这样驱动表就会被读取很多遍,有很大的 IO 开销 --><p>直接嵌套查询效率肯定很低,因为当驱动表得到一条数据之后,就会在被驱动表里面找符合条件的数据,而被驱动表需要从磁盘加载到<strong>内存</strong>才能进行条件匹配</p><p>而每次访问被驱动表,都要进行一次IO,并且在内存中的每一条记录只会和驱动表结果集的一条记录做匹配,之后就会被从内存中清除掉,然后再从驱动表结果集中拿出另一条记录,再一次把被驱动表的记录加载到内存中一遍</p><p>周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了</p><p>MySQL 使用 join buffer 就是这么做的</p><p>它不再是每次从驱动表取出一条数据就在另一个表里面找,而是取出一定大小之后,再一起在另一张表里找,批量查找比单次查找效率高一些</p><blockquote><p>join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 join buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的多条驱动表记录做匹配，，所以这样可以显著减少被驱动表的 I/O 代价</p><p>最好的情况是 join buffer 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。这种加入了 join buffer 的嵌套循环连接算法称之为<strong>基于块的嵌套连接</strong>(Block Nested-Loop Join)算法</p><p>另外需要注意的是，驱动表的记录并不是所有列都会被放到join buffer中，只有查询列表中的列和过滤条件中的列才会被放到join buffer中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样可以在join buffer中放置更多的记录</p></blockquote><p>注意: join buffer 只是通过先查驱动表,在一起放到另一个表的条件里面,如果驱动表还是很多,应该还是会有多次读取驱动表的情况</p><ul><li><p>join 优化总结:</p><ol><li><p>让驱动表得到的数据尽可能的少,减少内层循环次数</p></li><li><p>优化内层循环次数,</p></li><li><p>被驱动表 join 字段加索引(使用 index nested loop join 优化)</p></li><li><p>join buffer,并增大 buffer size</p></li></ol></li></ul></li><li><p>消除外联接</p><blockquote><p>内连接的驱动表和被驱动表的位置可以相互转换，而左连接和右连接的驱动表和被驱动表是固定的。这就导致内连接可能通过优化表的连接顺序来降低整体的查询成本，而外连接却无法优化表的连接顺序</p></blockquote><blockquote><p>外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用子句中的过滤条件的记录，NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--对象</title>
    <link href="/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>对象布局 =  对象头(12个byte=96bit) + 实例数据 + 对齐填充 (变成8的倍数)</p><a id="more"></a><p>对象头 = mark word(64bit) + klass pointer(32bit)</p><p>klass pointer 指针指向元空间中保存类的模板信息的地址</p><blockquote><p>object header</p><p>Common structure at the beginning of every GC-managed heap object. (Every oop points to an object header.) Includes fundamental information about the heap object’s layout, type(类型), GC state (垃圾回收状态), synchronization state (同步状态), and identity hash code (hash code). Consists of two words(字长)(字长和机器有关,64位机字长就是64位). In arrays it is immediately followed by a length field. Note that both Java objects and VM-internal objects have a common object header format.</p></blockquote><p><img src="https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt="1"></p><div class="hljs"><pre><code class="hljs gherkin">|<span class="hljs-string">--------------------------------------------------------------------------------------------------------------</span>||<span class="hljs-string">                                              Object Header (128 bits)                                        </span>||<span class="hljs-string">--------------------------------------------------------------------------------------------------------------</span>||<span class="hljs-string">                        Mark Word (64 bits)                                    </span>|<span class="hljs-string">      Klass Word (64 bits)    </span>|<span class="hljs-string">       </span>|<span class="hljs-string">--------------------------------------------------------------------------------------------------------------</span>||<span class="hljs-string">  unused:25 </span>|<span class="hljs-string"> identity_hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1 </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">  无锁 01</span>|<span class="hljs-string">----------------------------------------------------------------------</span>|<span class="hljs-string">--------</span>|<span class="hljs-string">------------------------------</span>||<span class="hljs-string">  thread:54 </span>|<span class="hljs-string">         epoch:2      </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1 </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">  偏向锁 01</span>|<span class="hljs-string">----------------------------------------------------------------------</span>|<span class="hljs-string">--------</span>|<span class="hljs-string">------------------------------</span>||<span class="hljs-string">                     ptr_to_lock_record:62                            </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">  轻量锁 00</span>|<span class="hljs-string">----------------------------------------------------------------------</span>|<span class="hljs-string">--------</span>|<span class="hljs-string">------------------------------</span>||<span class="hljs-string">                     ptr_to_heavyweight_monitor:62                    </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">  重量锁 10</span>|<span class="hljs-string">----------------------------------------------------------------------</span>|<span class="hljs-string">--------</span>|<span class="hljs-string">------------------------------</span>||<span class="hljs-string">                                                                      </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">    GC 11</span>|<span class="hljs-string">--------------------------------------------------------------------------------------------------------------</span>|</code></pre></div><p>可以使用 jol 打印对象信息,不过注意,JVM默认是大端存储,所以注意顺序是锁标志位在输出的第一个八位数据的最后两位 <code>例如:00000101 是打印的第一个字节,其中最后的101表示偏向锁</code></p><h2 id="对象初始化过程"><a class="header-anchor" href="#对象初始化过程">⚡</a>对象初始化过程</h2><ol><li><p>加载字节码中的文件到内存中的方法区</p><p>虚拟机遇到 new 指令,首先去检查 new 指令的参数是否能在常量池中定位到一个类的符号引用,并且这个符号引用代表的类是否已被加载,解析和初始化过</p><p>如果没有,那么先执行相应的类加载过程</p></li><li><p>初始化 static 相关的成员变量和静态方法,称为<strong>类初始化</strong>(全部都在方法区)</p><ol><li><p>先把所有的 static 部分(成员与方法)申请空间,然后再给每一个 static 成员由上至下分配初始值</p></li><li><p>分配完空间之后,会有默认值,而不是指定的值</p></li><li><p>这时才执行显式赋值,静态代码块对变量进行赋值,执行顺序与代码一致</p></li></ol></li><li><p>通过 new 在堆内存中申请对象的内存空间,取得首地址</p><p>在类加载检查通过后,要创建的对象所需的内存大小已经确定了,虚拟机将一块确定大小的内存从堆中划分出来分配给对象</p><p>假设堆中所有用过的内存放在一边,空闲的内存放在另外一边,中间放一个指针作为分界点的指示器,那分配内存就是移动这个指针的过程,这种内存分配方式叫&quot;指针碰撞&quot;</p><p>但如果堆中的内存,空闲的和使用过的是交互相错的,不是规整的,那么虚拟机必须维护一个队列,记录哪些内存块是可用的,分配的时候,查找表找到一块足够大的空间划分给对象,并更新表信息,这种方式叫&quot;空闲列表&quot;</p><p>选择哪种分配方式是由堆是否规整决定的,而Java堆是否规则是由所采用的垃圾收集器是否带有压缩整理功能决定的</p><ul><li><p>还需要考虑的一个问题是,在虚拟机中创建对象是否是一个非常频繁的行为</p><p>即便是采用&quot;指针碰撞&quot;的方式,在并发的情况下,修改指针也不是线程安全的</p><p>对于这个问题,有两种解决方法:</p><ol><li><p>第一,对分配内存空间的操作进行同步处理 – 实际上虚拟机采用 CAS 加自旋的方式保证了更新操作的原子性</p></li><li><p>第二,每个线程在堆中预先分配一小块内存,叫本地线程分配缓冲(TLAB)</p><p>哪个线程要分配内存,就在哪个线程的 TLAB 上分配,只有 TLAB 用完并分配新的 TLAB 时,才需要同步锁定</p><p>内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头),如果使用 TLAB,这一过程也可以提前至 TLAB 分配时进行</p><p>这一操作保证了对象的实例字段在 Java 代码中可以不赋初始值就可以直接使用,程序能访问到这些字段的数据类型所对应的零值</p></li></ol></li></ul></li><li><p>接下来,虚拟机要对对象进行必要的设置,例如这个对象属于哪个类,如何才能找到类的元数据信息,对象的哈希码,对象的 GC 分代年龄等信息</p></li></ol><p>到现在为止,从 JVM 的角度来看,一个新的对象已经产生了</p><p>但从 Java 程序来看,还需要对其执行 init 方法,所有字段都还是零值</p><p>一般来说,执行 new 指令之后会接着执行 init 方法,把对象安照程序员的意愿进行初始化</p><ol><li><p>构造方法压栈,依次执行以下的操作</p><ol><li><p>把类的非静态成员变量加载到堆内存中并分配空间同时默认初始化,非静态成员方法加载到方法区中并分配空间,然后由上到下进行非静态成员变量的初始化</p></li><li><p>用构造代码块和显示赋值对成员变量进行赋值,执行顺序与代码顺序一致</p></li><li><p>执行构造函数</p></li></ol></li><li><p>整个对象初始化完成，返回首地址值</p></li></ol><p>如果有父类,则:</p><p>先进行父类静态初始化,然后进行子类静态初始化(加载类文件的先后)</p><p>在堆内存空间分配完毕后,然后父类对象初始化,在进行子类对象初始化</p><p>(堆内存的创建,在父类对象的基础上加东西变成子类对象)</p><h2 id="对象访问"><a class="header-anchor" href="#对象访问">⚡</a>对象访问</h2><p>目前主流的访问方式有使用句柄和直接直接指针两种</p><ol><li><p>如果使用句柄的话,那么堆中将划分出一块内存来作为句柄池,reference 中存储的就是对象的句柄地址,而句柄中包含了对象的实例数据与类型数据各自的具体地址信息</p><p>使用句柄来访问的最大的好处就是 reference 中存储的是稳定的句柄地址,而对象被移动时只会改变句柄中的实例数据指针,而 reference 本身不需要修改,提高了垃圾回收的效率</p></li><li><p>如果使用直接指针访问,那么堆对象的布局中就必须考虑如何访问对象访问类型数据的信息,而 reference 中存储的就是对象在堆中的地址</p><p>使用直接内存访问的最大的好处就是速度更快,它节省了一次指针定位的时间开销,由于对象的访问是非常频繁的,因此这类开销积少成多之后也是非常可观的</p></li></ol><p>HotSpot 虚拟机是采用直接内存访问方式进行对象访问的</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--内存溢出和内存泄漏</title>
    <link href="/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>内存溢出(MemoryOverflow)就是你要求分配的内存超出了系统给你的,导致系统无法再给你提供内存资源（内存资源耗尽）</p><a id="more"></a><p>内存泄漏(MemoryLeak)就是申请到了内存空间,但是没有及时清理内存垃圾,或者用到了不属于自己的内存,于是产生泄漏</p><p>例子:</p><ol><li><p>内存溢出则是一个时间点,即申请内存但是申请不到,没有多余的内存分配了</p><p>例如死循环 new 对象,但是又不用 (MemoryLeak),仅仅加入到 list 里面,最后还在继续申请但是已经没有内存空间了,结果发生 OOM (MemoryOverflow)</p></li><li><p>内存泄漏是指一个过程,或者说一段时间</p><p>泄漏是说<strong>程序逻辑问题</strong>,造成申请的内存无法正确释放,或者是你用到了不属于你的内存 (例如数组越界)</p><p>例如:堆栈调用过多,会导致超出虚拟机栈深度,StackOverFlowError,实际上也是一种内存泄漏</p><p>内存溢出是申请的内存空间没有被正确释放,导致后续程序里这块内存被永远占用（<strong>可达但无用</strong>）,这样会造成程序能使用的内存越来越少,内存空间就这么一点点被蚕食,再去申请就会没有多余的内存,会使程序抛出 OOM 异常,导致内存溢出</p><p>溢出是代码编写问题,这样无论多少内存,早晚都会被占用光的</p><p>比喻就是：比如有10张纸，本来一人一张，画完自己擦了还回去，别人可以继续画，现在有个坏蛋要了纸不擦不还，然后还跑了找不到人了，如此就只剩下9张纸给别人用了(泄漏)，这样的人多起来后，最后大家一张纸都没有了。(最终溢出)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--OOM的几种情况</title>
    <link href="/2020/3/31/JVM-%E7%9F%A5%E8%AF%86-OOM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <url>/2020/3/31/JVM-%E7%9F%A5%E8%AF%86-OOM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<ul><li><p>堆</p><ol><li><p>内存<strong>溢出</strong> (MemoryOverflow)</p> <a id="more"></a><p>程序中的确需要很多对象,但是没有多余的空间再放入一个新的对象了</p></li><li><p>内存<strong>泄漏</strong> (Memory Leak)</p><p>大量无用的对象产生导致没有空间了</p><p>使用工具查看泄漏对象到 GC Roots 的引用链,从而定位泄漏代码的位置</p></li></ol></li><li><p>栈</p><ol><li>栈扩容时没有办法申请到足够大的空间 (只有允许动态扩展栈容量的虚拟机上才会发生,HotSpot 不可以)</li></ol><ul><li><p>HotSpot 只有在多线程下,才会出现 OOM,而在单线程下,实际上是 StackOverFlowError</p><p>常见的 StackOverFlowError 是请求的栈深度大于实际的栈空间大小,并且发生错误会有明确的堆栈打印</p><p>而在多线程下,操作系统 os 分配给每个进程的内存是有限制的.对于 JVM,主要把这个内存分配给堆和栈</p><p>而如果在多线程下,栈越大,所占用的内存越多,越容易发生 OOM</p><p>如果是产生了过多的线程而导致 OOM 的异常的,且不能减少线程数或者更换64位虚拟机的情况下,就只能通过减少最大堆和减少栈容量来换取更多的线程</p></li></ul></li><li><p>方法区</p><ol><li><p>大量类信息,造成内存溢出</p></li><li><p>其实还包括运行时常量池的内存溢出</p></li></ol></li><li><p>程序计数器是 JVM 唯一没有定义 OOM 的地方</p></li><li><p>直接内存</p><ol><li><p>直接或间接用到了直接内存的地方 (间接用到常见的有 NIO)</p><p>一个明显的特征是 Heap Dump 文件中不会看见明显的异常</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--垃圾收集器</title>
    <link href="/2020/3/30/JVM-%E7%9F%A5%E8%AF%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2020/3/30/JVM-%E7%9F%A5%E8%AF%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>基于分代收集理论</h1><a id="more"></a><h2 id="新生代收集器-Minor-GC"><a class="header-anchor" href="#新生代收集器-Minor-GC">⚡</a>新生代收集器 (Minor GC)</h2><h3 id="Serial"><a class="header-anchor" href="#Serial">⚡</a>Serial</h3><ol><li><p>标记-复制算法</p></li><li><p>单线程: 不仅仅是只有一条收集线程,更是进行垃圾收集时必须暂停其他工作线程的工作</p></li><li><p>有 “STOP THE WORLD”,降低用户体验</p></li><li><p>优点是: 简单高效,仍然是 HotSpot 虚拟机客户端模式下的默认新生代收集器</p><p>因为它是所有收集器里额外内存消耗最小的,适用于内存资源受限的场景</p><p>由于没用线程交互的开销,可以获得最高的单线程收集效率</p></li><li><p>推荐搭配 Serial Old 使用</p></li></ol><h3 id="ParNew"><a class="header-anchor" href="#ParNew">⚡</a>ParNew</h3><ol><li><p>标记-复制算法</p></li><li><p>ParNew 实质上是 Serial 收集器的多线程版本</p></li><li><p>ParNew 是 HotSpot 虚拟机服务端模式下的默认新生代收集器</p></li><li><p>ParNew 在单线程的环境下绝对不会有比 Serial 收集器更好的效果</p></li><li><p>ParNew 最先退出历史舞台,只能和 CMS 一起使用</p></li></ol><h3 id="Parallel-Scavenge"><a class="header-anchor" href="#Parallel-Scavenge">⚡</a>Parallel Scavenge</h3><ol><li><p>标记-复制算法</p></li><li><p>多线程,能够并行收集</p></li><li><p>特点是保证一个可控的吞吐量<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>,而 CMS 保证的是一个缩短用户线程的停顿时间</p></li><li><p>也被成为&quot;吞吐量优先收集器&quot;</p></li></ol><h2 id="老年代收集器-Major-GC"><a class="header-anchor" href="#老年代收集器-Major-GC">⚡</a>老年代收集器 (Major GC)</h2><h3 id="Serial-Old"><a class="header-anchor" href="#Serial-Old">⚡</a>Serial Old</h3><ol><li><p>标记-<strong>整理</strong>算法</p></li><li><p>单线程</p></li><li><p>默认是 HotSpot 虚拟机客户端模式下默认的老年代收集器</p></li><li><p>如果在服务端下,有两种用途:</p><ol><li><p>JDK 5 以前,与 Parallel Scavenge 搭配使用</p></li><li><p>另一种就是作为 CMS 收集器发生失败时的后备预案,在并发收集时发生 Concurrent Mode Failure 时使用</p></li></ol></li></ol><h3 id="Parallel-Old"><a class="header-anchor" href="#Parallel-Old">⚡</a>Parallel Old</h3><ol><li><p>Parallel Scavenge 的老年代版本</p></li><li><p>标记-整理算法</p></li><li><p>多线程</p></li></ol><h3 id="CMS-Concurrent-Mark-Sweep"><a class="header-anchor" href="#CMS-Concurrent-Mark-Sweep">⚡</a>CMS (<strong>Concurrent Mark Sweep</strong>)</h3><ol><li><p>Old GC, CMS 独有</p></li><li><p>标记-<strong>清除</strong>算法</p></li><li><p>以获取最短回收停顿时间为目标</p></li><li><p>运作过程更复杂</p><ol><li><p>初始标记</p><p>仅仅标记 GC Roots 能够关联到的对象,速度快</p></li><li><p>并发标记</p><p>从 GC Roots 的直接关联对象开始遍历整个对象图,耗时长但是不用停顿用户线程</p></li><li><p>重新标记</p><p>修正并发标记期间,因用户线程继续运作而导致标记变动的一部分对象的标记记录,停顿时间比初始标记时间稍长</p></li><li><p>并发清除</p><p>清理删除掉已经标记死亡的对象</p></li></ol><p>初始标记和重新标记两个过程仍然需要 “Stop The World”</p></li><li><p>缺点:</p><ol><li><p>面向并发的程序对处理器资源比较敏感</p><p>虽然并发阶段不会导致用户线程停顿,但是由于占用了一部分资源,会导致应用程序变慢,降低总吞吐量</p></li><li><p>无法处理&quot;浮动垃圾&quot;</p><p>浮动垃圾是由于在并发标记和并发清除阶段,用户线程继续产生的垃圾对象,而此次垃圾收集不能回收他们,只能等到下一次再清除</p><p>而且需要留足够的内存空间提供给用户线程使用,因此 CMS 收集器不能像其他收集器那样,等老年代几乎完全满了再进行收集</p><p>如果预留内存无法满足程序分配新对象的需要,有可能出现 “Concurrent Mode Failure” 失败,此时虚拟机就会启动预备方案,临时启用 Serial Old 收集器执行 GC,但这样停顿时间就很长了</p></li><li><p>标记-清除产生的大量空间碎片</p><p>无法找到足够大的连续空间分配大对象,而不得不产生另一次完全 “Stop the World” 的 Full GC</p></li></ol></li></ol><!-- # 不分代垃圾收集 --><h2 id="其他"><a class="header-anchor" href="#其他">⚡</a>其他</h2><h3 id="G1-Garbage-First"><a class="header-anchor" href="#G1-Garbage-First">⚡</a>G1 (Garbage First)</h3><ol><li><p>Mixed GC</p></li><li><p>被 Oracle 称为&quot;全功能的垃圾收集器&quot;</p></li><li><p>不再分代收集,而是面向整个堆的任何部分组成回收集 Set 进行回收,同时也是面向局部收集</p><p>注意,收集范围还是整个堆,但将堆划分为每一个 Region 看做是一个局部,每个 Region 代表不同的代,具体是哪个代是动态的,而不是像以前那样的要么是新生代,要么是老年代,要么是整个堆</p><p>即以前都是什么区域决定什么对象,现在是<strong>对象决定区域</strong></p></li><li><p>是否回收衡量标准不是代数,而是哪块内存的多少,是回收的经验时间,即回收的收益大小</p><p>通过维护这样一个优先级列表,每次回收价值更大的对象</p></li><li><p>每一个 Region 可以扮演, Eden, Survivor, Major 或者 Humongous 区域</p></li><li><p>运作过程</p><ol><li><p>初始标记</p><p>仅仅标记 GC Roots 能直接关联的对象,暂停用户线程,但耗时较短</p></li><li><p>并发标记</p><p>唯一不用暂停用户线程的阶段</p><p>从 GC Roots 开始对堆中的对象进行可达性分析,递归扫描整个对象的对象图</p></li><li><p>最终标记</p><p>短暂暂停用户线程,用于处理并发标记时有引用变动的对象</p></li><li><p>筛选回收</p><p>更新 Region 的统计数据,对各个 Region 的回收价值和成本进行排序</p><p>根据用户期望的停顿时间来制定回收计划,可以把一部分 Region 的存活对象复制到空的 Region 当中,再清理旧 Region</p><p>并且,由于是按照 Region 清理,G1 不会产生内存碎片!</p></li></ol></li><li><p>里程碑:通过追求能够应付应用的内存分配速率</p><p>不追求一次把整个 Java 堆全部清理干净,而只要保证收集的速度能跟得上对象分配的速度就能工作的很完美</p></li><li><p>特点总结:</p><ol><li><p>不分代</p></li><li><p>建立可预测的时间停顿模型,可以指定最大停顿时间</p></li><li><p>分 Region 的布局,不会产生空间碎片</p></li><li><p>按照收益回收的红利</p></li></ol></li><li><p>缺点:</p><ol><li><p>内存占用大</p><p>和 CMS 一样,使用卡表来处理跨区指针,但是比 CMS 更加复杂,占用堆的20%空间甚至更多</p></li><li><p>执行负载</p><p>G1 除了使用写屏障来更新卡表之外,还为了实现原始快照搜索(STAB)算法,用写屏障来跟踪并发时的指针变化情况,导致用户线程在执行阶段有额外的负担</p></li></ol></li></ol><h2 id="低延迟垃圾收集器"><a class="header-anchor" href="#低延迟垃圾收集器">⚡</a>低延迟垃圾收集器</h2><p>几乎整个工作过程都是并发的,只有在初始标记,最终标记阶段有短暂的停顿,且停顿时间基本固定</p><h3 id="Shenandoah"><a class="header-anchor" href="#Shenandoah">⚡</a>Shenandoah</h3><ol><li><p>和 G1 有很多相似的地方</p><p>内存布局 初始标记,并发标记的思路 …</p></li><li><p>G1 就是由于合并了 Shenandoah 的代码才能获得多线程 Full GC 的支持</p><p>G1 修改的代码也会反映到 Shenandoah 上面</p></li><li><p>相比 G1 的改进</p><ol><li><p>G1 的筛选回收阶段是多线程并行但不是并发的,而 Shenandoah 可以</p></li><li><p>默认不使用分代收集</p></li><li><p>G1 中的记忆集变成了连接矩阵的全局数据结构 —— 二维表,减少维护消耗</p></li></ol></li><li><p>运作过程</p><ol><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记</p></li><li><p><strong>并发清理</strong></p><p>清理那些整个 Region 连一个存活对象都没有的</p></li><li><p><strong>并发回收</strong> (核心)</p><p>先把回收集里面的存活对象复制到未被使用的 Region</p><p>但是这个复制对象的过程是在并发时完成的, 就可能会出现一边复制,一边读的问题</p><p>而它是通过读屏障和被称为 Brooks Pointers 的转发指针来解决的</p></li><li><p>初始引用更新</p><p>把所有指向旧对象的引用修正到复制到的新地址</p><p>只是建议一个线程集合点,会产生短暂的暂停</p></li><li><p><strong>并发引用更新</strong></p><p>真正开始引用更新,不再需要沿着对象图进行搜索,只需要按照内存物理地址的顺序,顺序搜索出引用类型</p></li><li><p>最终引用更新</p><p>修正 GC Roots 中的引用</p></li><li><p>并发清理</p><p>经过并发回收和引用更新之后,整个回收集中所有的 Region 已再无存活对象, 最后再调用一次并发清理过程回收 Region 的空间</p></li></ol><ul><li><p>关于 Brooks Pointers</p><p>其实原来的解决方案是设置自陷陷阱,主动触发异常,再进入预设好的异常处理器中,再由代码逻辑吧访问转发到复制后的对象上.但是如果没有操作系统的支持,会导致用户态频繁转到内核态,代价很大</p><p>而在原有对象布局结构的最前面统一增加一个新的引用字段,在不处于并发移动的i情况下,该引用指向自己</p><p>这样,当对象有了一份新的副本时,只需要就对象指针的值,指向新对象.只要就对象的内存依然存在,虚拟机内存中所有通过旧引用地址访问代码便仍然可用,都会被转发到新对象上继续工作</p><ul><li><p>但是请注意,这个设计导致了必然会出现多线程竞争问题</p><p>例如当复制对象完成后,用户修改了旧对象,收集器线程才刚刚更新指针</p><p>所以,对指针转发的操作必须采用同步措施,在统一时间内只能让用户线程或者收集器线程其中之一访问</p></li><li><p>还有一点是执行频率问题</p><p>在面向对象编程的语言中,对象访问是非常重要的,非常频繁的,而 Shenandoah 同时设置读,写屏障,带来了数量庞大的性能开销</p></li></ul></li></ul></li></ol><h3 id="ZGC"><a class="header-anchor" href="#ZGC">⚡</a>ZGC</h3><ol><li><p>染色指针技术,将指针的高四位提取出来存储四个标志信息</p></li><li><p>运作过程</p><p>ZGC 的四个大阶段都是可以并发执行的,仅仅两个阶段中间会有短暂的停顿用户线程</p><ol><li><p>并发标记</p><p>和 G1, Shenandoah 类似,只不过标记是在指针上而不是在对象上进行的</p></li><li><p>并发预备重分配</p><p>根据特定的查询条件统计要清理的 Region, 将这些 Region 重新组成分配集,准备复制到其他的 Region 中</p></li><li><p>并发重分配 (核心)</p><p>把重分配集中的存活对象复制到新的 Region 上,并为重分配集中的每个 Region 维护一个转发表,记录从旧对象到新对象的转发关系</p><p>如果用户线程此时访问了位于重分配集中的对象,这次访问将会被预置的内存屏障所截获,然后立即根据 Region 上的转发表记录,将访问转发到新复制的对象,这种行为成为指针的 “自愈”</p><p>相比 Shenandoah 的转发指针,每次都会有转发的固定开销,ZGC 运行时的负载比 Shenandoah 要低一些</p></li><li><p>并发重映射</p><p>修正整个堆中只想重分配集中旧对象的所有引用,类似 Shenandoah 的并发引用更新</p><p>但是 ZGC 这个任务并不是那么迫切的,因为即使是旧引用,也是可以自愈的,也不过是一次转发和修正</p><p>因此,ZGC 把这个阶段的工作合并到了下一次垃圾收集的并发标记阶段,节省了一次遍历所有对象图的开销</p></li></ol></li></ol><ul><li><p>优点</p><p>由于 ZGC 完全没有记忆集,甚至没有分代,所以给用户线程的运行负担小很多</p></li><li><p>缺点</p><ol><li><p>ZGC 对整个堆回收的速度较慢,但是由于对象的分配速率很高,并且很多朝生夕灭,但是在此时又被当作是存活对象,没有标记回收,导致产生了很多浮动垃圾</p><p>因为较长的回收时间,和高速产生的对象,并且这个过程如果持续维持的话,堆中能够用于腾挪的空间会越来越小</p><p>目前解决办法是尽可能的增加堆的大小,但是要本质上解决,还是必须引入分代收集理论,将对象都在一个专门的区域创建,然后专门对这个区域进行更快,更频繁的收集</p></li></ol></li></ul><h3 id="Epsilon"><a class="header-anchor" href="#Epsilon">⚡</a>Epsilon</h3><p>不能够进行垃圾收集</p><h1>垃圾收集器的范围</h1><ul><li><h2 id="Partial-GC"><a class="header-anchor" href="#Partial-GC">⚡</a>Partial GC</h2><ul><li><h3 id="Minor-GC-Young-GC"><a class="header-anchor" href="#Minor-GC-Young-GC">⚡</a>Minor GC / Young GC</h3><p>仅仅是收集新生代</p></li><li><h3 id="Old-GC-CMS-独有模式"><a class="header-anchor" href="#Old-GC-CMS-独有模式">⚡</a>Old GC (CMS 独有模式)</h3><p>收集老年代</p></li><li><h3 id="Major-GC"><a class="header-anchor" href="#Major-GC">⚡</a>Major GC</h3><p>同 Old GC,收集老年代</p></li><li><h3 id="Mixed-GC-G1-独有模式"><a class="header-anchor" href="#Mixed-GC-G1-独有模式">⚡</a>Mixed GC (G1 独有模式)</h3><p>目标是收集整个新生代和老年代</p></li></ul></li><li><h2 id="Full-GC-Major-GC"><a class="header-anchor" href="#Full-GC-Major-GC">⚡</a>Full GC / Major GC</h2><p>收集整个 Java 堆和方法区</p></li></ul><p>注意:</p><blockquote><p>Major GC 有不同语义,要弄清楚到底是指与 Full GC 同样的整个堆和方法区的收集,还是值与 Old GC 类似的仅仅老年代堆的收集</p></blockquote><h1>并发和并行</h1><ol><li><p>并行 (Parallel): 多条垃圾收集器线程之间的关系,说明同一时间有多条这样的线程在协同工作,通常默认用户线程此时处于等待状态</p></li><li><p>并发 (Concurrent): 描述的是垃圾收集器线程和用户线程之间的关系,说明同一时间垃圾收集器线程和用户线程都在运行,但由于垃圾收集器线程占用了一部分系统资源,应用程序虽然还行响应,但是吞吐量会受到一定影响</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>吞吐量=(运行用户代码时间)/(运行用户代码+_垃圾收集的时间) <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识-硬件内存架构</title>
    <link href="/2020/3/29/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/3/29/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="CPU-工作机制"><a class="header-anchor" href="#CPU-工作机制">⚡</a>CPU 工作机制</h2><p>CPU 速度快,但是数据存放到内存中,而内存相对较慢,所以 CPU 中间加上 cache 多级高速缓存来提升数据读取速度</p><a id="more"></a><p><img src="/img/CPU.png" srcset="/img/loading.gif" alt="CPU"></p><h3 id="cache-缓存工作机制"><a class="header-anchor" href="#cache-缓存工作机制">⚡</a>cache 缓存工作机制</h3><ol><li><p>当 CPU 要去读取一个数据时,会先去缓存中查找,找不到再去内存中找</p></li><li><p>在内存中找到了,同时把这个数据所在的数据快调入缓存中</p><p>即把临近的共64 byte 的数据一同载入,因为临近的数据可能被访问的几率更大,下次就可以直接在缓存中查找数据,这样就增加了缓存的<strong>命中率</strong>(cache hit)了</p></li></ol><h3 id="CPU-缓存一致性问题"><a class="header-anchor" href="#CPU-缓存一致性问题">⚡</a>CPU 缓存一致性问题:</h3><p>如上图所示,cache 之和特定的 CPU 进行通信,多核 CPU 就会出现并发问题: 一个线程在读,另一个在写,导致数据不一致问题</p><ul><li>解决方案:<ol><li><p>总线锁</p><p>使用 CPU 提供的一个 LOCK# 信号,当一个处理器在总线上输入此信号,其他处理器的请求将被阻塞,那么该处理器就可以独占共享锁</p> <span class="label label-danger">todo为什么是共享锁?</span><p>粒度比较大,会降低 CPU 的吞吐量 [1]</p></li><li><p>缓存锁(缓存一致加锁)</p><p>控制锁的粒度,核心是缓存一致协议,不同的 CPU 厂商有不同的实现方式,例如 MESI: 当修改变量时,如果数据是共享变量,会将 cache line 置为无效,所以其他的 CPU 就从内存中读数据,不会再去 cache 中读取数据</p> <!-- <span class="label label-danger">todo解决了可见性,但是无法保证同步?</span> --></li></ol></li></ul><h3 id="线程和硬件架构"><a class="header-anchor" href="#线程和硬件架构">⚡</a>线程和硬件架构</h3><p>进程 -&gt; 线程 -&gt; os 内核线程 -&gt; CPU 线程</p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--JVM 内存区域</title>
    <link href="/2020/3/29/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <url>/2020/3/29/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-内存区域"><a class="header-anchor" href="#Java-内存区域">⚡</a>Java 内存区域</h2><ol><li>Java 虚拟机在执行 Java 程序的过程中将它所管理的内存区域分成若干个不同的数据区域,称为 Java 内存区域.(<strong>即运行时数据区</strong>)</li></ol><a id="more"></a><ol><li><p>分为五个部分:</p><p><code>程序计数器</code>,<code>虚拟机栈</code>,<code>本地方法栈</code>,<code>Java 堆</code>,<code>方法区</code></p><p>其中前三个是线程隔离的,后两个是线程共享的</p><p>其实还有<code>直接内存</code>是线程共享的,不过直接内存不属于 Java 运行时的内存区域</p></li><li><p>特别的,在 JDK 1.8 之后,原本也被称为永久代的方法区,就不要再称呼为永久代了,因为已经由一个叫做元空间的东西来实现了.</p></li></ol><h3 id="具体的每一个部分"><a class="header-anchor" href="#具体的每一个部分">⚡</a>具体的每一个部分:</h3><ol><li><p>程序计数器</p><p>它占用一小块内存空间,可以看作是当前线程所执行的字节码的行号指示器</p><p>Java 虚拟机的多线程是通过线程轮流切换,分配处理器执行时间的方式来实现的,因此,为了让每条线程切换后都能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,让各个线程的执行不相互影响</p><p><code>字节码解释器</code> 工作时就是通过改变这个计数器来选取下一条需要执行的字节码指令</p><p>JVM 内存区域中唯一一个没有定义 OOM 的区域</p></li><li><p>方法区:</p><ul><li><p>存储: 类信息,常量,static 变量, JIT (Java 即时编译)后的缓存</p></li><li><p>JIT 即时编译</p><p>对象被拆散为标量类型间接地在栈上分配内存</p></li><li><p>JDK 7 以前还叫 永久代, JDK 8 之后就是元空间,其实都是对方法区的实现</p><p>但是注意,元空间实际上不属于虚拟机内存,而是本地内存</p><ol><li><p>为什么改变:</p><ol><li><p>首先是 JDK 8 是 HotSpot 为了融合 JRocket 虚拟机,后者没有永久代</p></li><li><p>永久代经常用空间不够而发生内存溢出(MemoryOverflow),更换成永久代之后,元空间大小之取决于本地内存大小,减少 OOM 的发生</p></li></ol></li></ol></li></ul></li><li><p>Java 堆 (别名 GC 堆)</p><ul><li><p>存储:实例对象</p></li><li><p>具体还可分为:</p><ol><li><p>Eden</p></li><li><p>from survivor</p></li><li><p>to survivor</p><p>GC 发生前, to survivor 区一定是清空的</p><p>GC 时,首先把 Eden 区的对象 复制到 to survivor,对于 from survivor 要进行判断是否达到年龄阈值,如果达到了,就直接复制到老年代,没有则还是复制到 to survivor 区,并且此时对象年龄加一</p><p>如果 to survivor 区满了,那么直接把剩余的对象放入到老年代中</p><p>复制阶段完成后,可以视为 Eden 区 和 from survivor 区全部是死对象,最后 from 和 to 区会调换名字,在下次 GC 时, to 会变成 from</p></li><li><p>old</p></li></ol></li><li><p>对象分配规则</p><ol><li><p>对象优先分配在新生代 Eden 区，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC</p></li><li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）</p><p>这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>长期存活的对象进入老年代</p><p>虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加1，知道达到阀值对象进入老年区。</p><p>注意: JDK 7 可以设置年龄超过15,JDK 8 不可以,暂时不知道原因</p><p>不可以超过15很好理解:</p><p>对象头的 mark word 只设置了4个位来存储年龄信息,2^5-1=15,最多把一个字节用完也只能存到15</p></li><li><p>动态判断对象的年龄</p><p>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p></li><li><p>空间分配担保机制</p><p>每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC，如果小于检查 HandlePromotionFailure 设置，如果 true 则只进行 Minor GC ,如果false则进行Full GC。</p></li></ol></li></ul></li><li><p>虚拟机栈区 (内存模型)</p><p>是 Java <strong>方法</strong> 的运行时 <strong>内存模型</strong> Java Memory Model</p><p>因为线程之间的通信是通过 JMM 控制的</p><p>每一个栈帧对应一个方法,每一个方法的调用到执行完成就对应着一个栈帧在虚拟机从入栈到出栈的过程</p><p>栈帧中有: 局部变量表,操作数栈,动态连接,方法出口</p><p>局部变量表包括: <strong>基本数据类型,对象引用(可以是对象起始地址的引用指针,也可能是代表对象的句柄)</strong></p><p>局部变量表所需的内存在<strong>编译期间</strong>完成分配,分配多大空间是完全确定的,运行期间不会改变局部变量表的大小</p><p>注意:</p><blockquote><p>这里我之前不理解为什么是不会在运行时改变局部变量表的大小的,例如在 while- true 的循环里面,一直 new 对象,这个不就是动态增加的吗,数量是不确定的</p><p>然后我发现,new 对象是要显式赋值给一个引用对象的,或者加入到 list 里面,前者对象引用就在局部变量表里面,后者的引用则通过 list 的起始地址或者数组下标可以找到每个对象,实际上还是在局部变量表里面,没有区别</p></blockquote></li><li><p>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</p><ol><li><p>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</p></li><li><p>堆与栈的分离,使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</p></li><li><p>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</p></li><li><p>垃圾回收,</p></li><li><p>面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。</p></li></ol></li><li><p>为什么不把基本类型放堆中呢？</p><p>因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- Spring @Bean 和 @Component</title>
    <link href="/2020/3/21/Spring-%E7%9F%A5%E8%AF%86-Spring-Bean-%E5%92%8C-Component/"/>
    <url>/2020/3/21/Spring-%E7%9F%A5%E8%AF%86-Spring-Bean-%E5%92%8C-Component/</url>
    
    <content type="html"><![CDATA[<h2 id="我的理解"><a class="header-anchor" href="#我的理解">⚡</a>我的理解</h2><p>当学习 Spring 框架的时候,我们会使用 Java configuration + annotation 的方法配置依赖,例如使用 @Component 注解在 Service,dao,mapper 等类, 这样来注册给 IoC 容器,让它来管理这个 Bean 并且自动装配所需要的依赖</p><a id="more"></a><p>但是有个问题,@Component 也是用于 Bean 上,那么 @Bean 注解又是什么呢?</p><p>首先我们要知道 @Bean 在什么情况下会用到:</p><p>对于我们自己手动写的类,可能直接在类上加入 @Component 注解就可以直接让 Spring IoC 容器来管理对象的产生了</p><p>但是,对于需要用到的第三方的组件,这种情况下,除非将它的开源的代码重新整合到项目里面,否则我没有办法在它的 jar 包中的 class 文件反编译后的 Java 文件的类上加入 @Component 注解,但是这种整合源码的方法肯定是不可能的</p><p>而如果不加入 @Component ,我们自己去 new 这个对象也可以,这个时候就需要我们自己去管理这个对象,相当于做了一部分 IoC 容器做到事情,这样还是不太好</p><p>而且,如果这个对象还需要一些依赖,有些依赖甚至还需要从 Spring IoC 容器管理的依赖去取,自己管理的方法就不行了</p><p>也就是说,我们需要自己完成这个第三方对象的创建,但是,虽然创建我只需要 new Class() 就可以了,但是我还需要把这个创建好的对象交给 Spring IoC 容器来管理</p><p>此时,我们就可以在配置类上加上 @Configuration 注解,然后在创建对象的方法上面加上 <code>@Bean</code> 注解 (并且这个方法返回这个对象),这样就把我们手动生成的对象交给 Spring 的 IoC 容器进行管理了,如果这个类还需要依赖,只要你把所需要的依赖作为参数声明到方法上, Spring IoC 容器就可以将依赖自动传给这个方法,进而把依赖注入给这个类</p><hr><h2 id="官方文档"><a class="header-anchor" href="#官方文档">⚡</a>官方文档</h2><blockquote><p>The central artifacts in Spring’s new Java-configuration support are @Configuration-annotated classes and @Bean-annotated methods.</p><p>Spring 的新 Java Configuration支持中的主要构件是 @Configuration 注释的类和 @Bean 注释的方法。</p></blockquote><p>这句话意思是,@Configuration 和 @Bean 是 Spring 的 Java Configuration 编码方式中提供支持的</p><blockquote><p>The @Bean annotation is used to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring’s <beans/> XML configuration, the @Bean annotation plays the same role as the <bean/> element. You can use @Bean-annotated methods with any Spring @Component. However, they are most often used with @Configuration beans.</p><p>@Bean批注用于指示方法实例化，配置和初始化要由Spring IoC容器管理的新对象。对于那些熟悉Spring的<beans /> XML配置的人来说，@ Bean注释与<bean />元素具有相同的作用。您可以将@Bean注释的方法与任何Spring @Component一起使用。但是，它们最常与@Configuration bean一起使用。</p></blockquote><p>这段话是说,@Bean 可以等同于使用 Spring schema 编码方式中的 xml 中的 <code>&lt;bean&gt;</code></p><blockquote><p>Annotating a class with @Configuration indicates that its primary purpose is as a source of bean definitions. Furthermore, @Configuration classes let inter-bean dependencies be defined by calling other @Bean methods in the same class.</p><p>用@Configuration注释类表示该类的主要目的是作为Bean定义的来源。此外，@Configuration类允许通过调用同一类中的其他@Bean方法来定义Bean间的依赖关系。</p></blockquote><h3 id="Full-Configuration-vs-“lite”-Bean-mode"><a class="header-anchor" href="#Full-Configuration-vs-“lite”-Bean-mode">⚡</a>Full @Configuration vs “lite” @Bean mode?</h3><blockquote><p>When @Bean methods are declared within classes that are not annotated with @Configuration, they are referred to as being processed in a “lite” mode. Bean methods declared in a @Component or even in a plain old class are considered to be “lite”, with a different primary purpose of the containing class and a @Bean method being a sort of bonus there. For example, service components may expose management views to the container through an additional @Bean method on each applicable component class. In such scenarios, @Bean methods are a general-purpose factory method mechanism.</p><p>如果在未使用@Configuration注释的类中声明@Bean方法，则将它们称为以“精简”模式进行处理。在@Component或甚至在 POJO 中声明的Bean方法被认为是“精简版”，其中包含类具有不同的主要用途，而@Bean方法在那里具有一定的优势。例如，Service 组件中可以通过每个适用组件类上的其他@Bean方法将管理视图公开给容器。在这种情况下，@ Bean方法是一种通用的<strong>工厂方法</strong>机制。</p></blockquote><blockquote><p>Unlike full @Configuration, lite @Bean methods cannot declare inter-bean dependencies. Instead, they operate on their containing component’s internal state and, optionally, on arguments that they may declare. Such a @Bean method should therefore not invoke other @Bean methods. Each such method is literally only a factory method for a particular bean reference, without any special runtime semantics. The positive side-effect here is that no CGLIB subclassing has to be applied at runtime, so there are no limitations in terms of class design (that is, the containing class may be final and so forth).</p><p>与完整的@Configuration不同，lite @Bean方法无法声明Bean之间的依赖关系。取而代之的是，它们在其包含组件的内部状态上进行操作，并且还可以根据可能声明的自变量进行操作。因此，一个@Bean方法不应调用其他@Bean方法。每个此类方法实际上只是针对特定bean引用的工厂方法，而没有任何特殊的运行时语义。这里的积极副作用是，不必在运行时应用CGLIB子类，因此在类设计方面没有任何限制（即，包含类可以是最终类，依此类推）。</p></blockquote><blockquote><p>In common scenarios, @Bean methods are to be declared within @Configuration classes, ensuring that “full” mode is always used and that cross-method references therefore get redirected to the container’s lifecycle management. This prevents the same @Bean method from accidentally being invoked through a regular Java call, which helps to reduce subtle bugs that can be hard to track down when operating in “lite” mode.</p><p>在常见情况下，@ Bean方法将在@Configuration类中声明，以确保始终使用“完全”模式，因此跨方法引用将重定向到容器的生命周期管理。这样可以防止通过常规Java调用意外地调用同一@Bean方法，这有助于减少在“精简”模式下运行时难以跟踪的细微错误。</p></blockquote><h2 id="Bean-使用"><a class="header-anchor" href="#Bean-使用">⚡</a>@Bean 使用</h2><blockquote><p>You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.</p><p>你可以在 <strong><code>@Configuration</code></strong> 注释的类或 <strong><code>@Component</code></strong> 注释的类中使用@Bean注释。</p></blockquote><p>例如</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferServiceImpl <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();    &#125;&#125;</code></pre></div><blockquote><p>However, this limits the visibility for advance type prediction to the specified interface type (TransferService). Then, with the full type (TransferServiceImpl) known to the container only once, the affected singleton bean has been instantiated. Non-lazy singleton beans get instantiated according to their declaration order, so you may see different type matching results depending on when another component tries to match by a non-declared type (such as @Autowired TransferServiceImpl, which resolves only once the transferService bean has been instantiated).</p><p>但是，这将高级类型推断的功能的可见性限制为指定的接口类型（TransferService）。然后，仅使容器明白完整类型（TransferServiceImpl）一次，就可以实例化受影响的单例bean。非懒惰单例bean根据其声明顺序实例化，<strong>因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试通过未声明的类型进行匹配</strong>（例如@Autowired TransferServiceImpl，仅当transferService bean具有被实例化）。</p></blockquote><blockquote><p>If you consistently refer to your types by a declared service interface, your @Bean return types may safely join that design decision. However, for components that implement several interfaces or for components potentially referred to by their implementation type, it is safer to declare the most specific return type possible (at least as specific as required by the injection points that refer to your bean).</p><p>如果您通过声明的服务接口一致地引用同一类型，则@Bean返回类型可以安全地加入该设计决策。但是，<strong>对于实现多个接口的组件</strong>或由其实现类型潜在引用的组件，声明可能的<strong>最具体的返回类型</strong>（至少与引用您的bean的注入点所要求的具体类型一样）更为安全。</p></blockquote><blockquote><p>A @Bean-annotated method can have an arbitrary number of parameters that describe the dependencies required to build that bean. For instance, if our TransferService requires an AccountRepository, we can materialize that dependency with a method parameter, as the following example shows:</p><p>@Bean注释的方法可以具有任意数量的参数，这些参数描述构建该bean所需的依赖关系。例如，如果我们的TransferService需要一个AccountRepository，则可以使用方法参数来实现该依赖关系，如以下示例所示：</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">(AccountRepository accountRepository)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(accountRepository);    &#125;&#125;</code></pre></div><h2 id="Configuration-的使用"><a class="header-anchor" href="#Configuration-的使用">⚡</a>@Configuration 的使用</h2><blockquote><p>@Configuration is a class-level annotation indicating that an object is a source of bean definitions. @Configuration classes declare beans through public @Bean annotated methods. Calls to @Bean methods on @Configuration classes can also be used to define inter-bean dependencies.</p><p>@Configuration是类级别的注释，指示对象是Bean定义的源。@Configuration类通过公共@Bean注释方法声明bean。对@Configuration类的@Bean方法的调用也可以用于定义Bean之间的依赖关系。</p></blockquote><blockquote><p>This method of declaring inter-bean dependencies works only when the @Bean method is declared within a @Configuration class. You cannot declare inter-bean dependencies by using plain @Component classes.</p><p>仅当在@Configuration类中声明@Bean方法时，此声明bean间依赖性的方法才有效。您不能使用普通的@Component类声明Bean间的依赖关系。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据源和数据连接池</title>
    <link href="/2020/3/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/2020/3/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="数据源"><a class="header-anchor" href="#数据源">⚡</a>数据源:</h2><a id="more"></a><p>简单理解为数据源头，提供了应用程序所需要数据的位置。它是连接到实际数据库的一条路径而已，数据源中并无真正的数据，它仅仅记录的是你连接到哪个数据库，以及如何连接的</p><p>数据源保证了应用程序与目标数据之间交互的规范和协议，目标数据的存储可以是数据库，文件系统等等。</p><p>数据源定义了位置信息，用户验证信息和交互时所需的一些特性的配置，同时它封装了如何建立与数据源的连接，向外暴露获取连接的接口。</p><p>应用程序连接数据库无需关注其底层是如何如何建立的，也就是说应用业务逻辑与连接数据库操作是松耦合的。</p><p>数据源大致分为2种：不提供数据连接池和提供数据连接池管理。</p><h2 id="数据连接池"><a class="header-anchor" href="#数据连接池">⚡</a>数据连接池</h2><ul><li><p>JDBC操作的步骤：</p><ol><li><p>加载驱动程序</p></li><li><p>连接数据库</p></li><li><p>操作数据库</p></li><li><p>关闭数据库，释放连接</p></li></ol><p>但是当与数据库交互频繁时，这种模式会严重影响程序的性能。时间和空间消耗大多数消耗在连接和销毁中，而非数据库处理。</p><p>Spring 默认的 <code>Spring-jdbc</code> 的 DriverManagerDataSource 就是不提供连接池的,该数据源对于应用程序的每一个连接请求都建立新的连接，当应用程序使用完毕后，再执行销毁操作。</p></li><li><p>使用数据库连接池</p><p>数据库连接是负责分配、管理和释放数据库连接。数据库连接池里专门保存着全部的数据库连接，以后用户用数据库操作的时候不用再重新加载驱动、连接数据库之类的，而直接从此空间中取走连接，关闭的时候直接把连接放回到此空间之中。</p><p>Spring Boot 是采用 HikariCP 来作为默认的数据源。</p></li></ul><h2 id="Spring-中的常用数据访问技术"><a class="header-anchor" href="#Spring-中的常用数据访问技术">⚡</a>Spring 中的常用数据访问技术</h2><ol><li><p>JDBC</p><p>Java数据库连接，（Java Database Connectivity，简称 JDBC ）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序<strong>接口</strong>，用于在 Java 语言编程中与数据库连接的 API</p><p>也就是说,JDBC是一个规范，它提供了一整套接口( 是 API 而不是 interface ,但是只是低级 API 或者叫底层 API,因为它直接调用 SQL 命令 ,其他有各自封装好 JDBC 的高级 API, 例如 JDBI)，允许以一种可移植的访问底层数据库 API。使用 JDBC 驱动程序来访问数据库，并用于存储数据到数据库中.</p></li><li><p>Spring Data JPA</p><p>Spring Data JPA 基于 Hibernate，而 Hibernate 是一个让人又爱又恨的技术。</p><p>同原生 JDBC 相比，Hibernate 极大地简化了开发工作量；但另一方面，因为 Dirty Check、延迟加载、各种如 ManyToOne 等映射规则，又让 Hibernate 成为了一个复杂技术。而这些复杂性，平时很少直接用到，但是却增加了 Hibernate 的开发和调试难度。</p></li><li><p>Spring Data JDBC</p><p>Spring Data JDBC 的目的是为了给基于 JDBC 的数据库应用提供 Repository 封装。</p><blockquote><p>简单说，就是为了让大家用到类似于 Spring Data JPA 中 JpaRepository 的功能，但是不引入任何ORM框架。</p></blockquote><p>也就是我们经常在代码里看到 JDBCTemplate 这个辅助类进行开发</p></li><li><p>MyBatis</p><p>和 Hibernate 一样是第三方 ORM 数据库框架。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。</p><p>注意:</p><blockquote><p>Hibernate是全自动ORM框架，而Mybatis是半自动的。hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- Spring IOC 的应用</title>
    <link href="/2020/3/17/Spring-%E7%9F%A5%E8%AF%86-Spring-IOC-%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/3/17/Spring-%E7%9F%A5%E8%AF%86-Spring-IOC-%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Spring 实现IoC的思路和方法</p> <a id="more"></a><ol><li><p>Spring 实现 IoC 是通过配置信息来描述类与类之间的配置关系,然后由去解析这些配置信息</p><p>步骤:</p><ol><li><p>应用程序中提供类和依赖对象</p></li><li><p>通过配置,把所有需要用到的类交给容器 (schema,annotation,Java configuration)</p></li><li><p>再描述一遍类和依赖对象的关系</p></li></ol></li></ol></li><li><p>Spring IoC 使用例子:</p><ol><li><p>方式一: schema</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 声明类 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexDaoImpl"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 声明类 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"service"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexService"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 声明依赖对象 --&gt;</span>        <span class="hljs-comment">&lt;!-- 方法一: 基于 setter 方法,** name 和属性名无关,只和 setter 方法名有关** --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dao"</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- 方法二: 基于构造函数 --&gt;</span>        <span class="hljs-comment">&lt;!-- &lt;constructor-arg ref="dao"/&gt;--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>但是请注意,这里有一个很坑的点,或者说我基础不扎实的地方:</p><blockquote><p>当使用方法一的时候,不要写任何构造器,因为如果不写还好,JVM 可以自动给你生成默认的空构造方法</p><p>但是如果写了带依赖参数的构造器,那么 JVM 将不会为你生成默认的空构造方法,这样使用 setter 注入会报错 <code>No default constructor found</code></p><p>所以要么就不写带参数的构造方法(不和 <code>构造函数注入</code> 混用),要么,就再写上无参构造函数</p></blockquote> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 在主函数里面使用 ClassPathXmlApplicationContext 传入这个 xml 配置文件</span>ClassPathXmlApplicationContext classPathXmlApplicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:spring.xml"</span>);<span class="hljs-comment">// getBean 的参数是 service,和类名其实无关,之和 xml 的 id 有关</span>Service Service = (IndexService) classPathXmlApplicationContext.getBean(<span class="hljs-string">"service"</span>);service.test();</code></pre></div></li><li><p>方式二: annotation ( 与 schema 或者 Java Configuration 集成)</p><ol><li><p>方法一:annotation + schema</p><ol><li><p>首先需要开启 Spring 对注解的支持:</p><p>在 xml 里面写上 <code>&lt;context:component-scan base-package=&quot;ind.yinchao.ioc.test1&quot;/&gt;</code></p><p>这样离不开 xml,不太好</p></li></ol></li><li><p>方法二:annotation + Java Configuration 更改主函数的 Context (已经体现 <strong><code>自动装配</code></strong>)</p><p>新建 Java 配置文件</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// @configuration 就是生命这是代替 xml 的配置文件</span><span class="hljs-meta">@Configuration</span>()<span class="hljs-comment">// @componentScan 开启扫描</span><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"ind.yinchao.ioc.test2"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span></span>&#123;&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs java">AnnotationConfigApplicationContext annotationConfigApplicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre></div></li></ol><p>然后就可以使用注解了</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//声明类</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-comment">// 声明依赖关系</span>    <span class="hljs-meta">@Autowired</span>    Dao dao;&#125;&lt;!-- 声明类 --&gt;<span class="hljs-meta">@Component</span>(<span class="hljs-string">"dao"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DaoImpl</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"daoImpl1);</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;</span></code></pre></div></li><li><p>方式三: schema + annotation + Java Configuration 混合使用</p><p>在 Java Configuration + annotation 的基础上,在 Java 配置文件类 SpringConfiguration 中加上 <code>@ImportResource(&quot;SpringConfiguration.xml&quot;)</code> 以启用 schema</p></li><li><p>使用 <strong>schema</strong> 的问题:</p><p>如果我们类与类之间有了依赖关系,那么为什么还要在声明类的配置中来再描述一遍依赖对象呢?这样不就冗余了吗</p><p>解决:</p><p>使用 Spring 的 <strong>自动装配</strong> 完成上面的第三步,不需要在第二步完成类的描述之后再去进行冗余的类与依赖对象的描述</p><p>在 xml 配置文件的头部最后加上 <code>default-autowired = &quot;no|byType|byName|construct&quot;</code>,分别对应:</p><ol><li><p>no|default: 不自动装配</p></li><li><p>byType: 自动属性注入</p><p>需要 set 方法</p><p>type: 依赖属性的类型</p></li><li><p>byName 自动名字注入:</p><p>需要 set 方法</p><p>name: set方法按一定规律的名字</p><p>例如 setTest ,那么 xml 中对应的依赖类 id 就为 test</p></li><li><p>自动通过构造方法注入:需要带参构造方法</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在主程序的配置入口处配置 最后加上 default-autowired="byType"--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexDaoImpl"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"service"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexService"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dao"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li></ol></li><li><p>使用 annotation + Java Configuration 的问题 (schema 也类似,就不再举例)</p><p>实现类有两个:</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"dao2.1"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexDaoImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IndexDao</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"impl2.1"</span>);    &#125;&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"dao2.2"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexDaoImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IndexDao</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"impl2.2"</span>);    &#125;&#125;</code></pre></div><p>这时如果在 Service 类里面继续写依赖就会报错</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-meta">@Autowired</span>    IndexDao dao&#125;</code></pre></div><blockquote><p>No qualifying bean of type ‘test2.IndexDao’ available: expected single matching bean but found 2: dao2.1,dao2.2</p></blockquote><p>因为 @Autowired 默认是根据 byType 查找,这里出现了两个 IndexDao 的实现,那么就有两个相同的类型,就会出错</p><p>解决:</p><ol><li><p>方法一: @Autowired 是先根据 byType 如果没有找到,会使用 byName</p><p>这样,那我们只需要修改 Service 里面的依赖变量名 dao -&gt; indexDaoImpl1,这样就可以找到 IndexDaoImpl1 这个类了</p><p>注意,和 setter 方法无关</p></li><li><p>使用 @Resource 是根据 byName 查找的,解决方式同上</p></li><li><p>虽然还是使用 @Resource ,这里我们还可以使用 @Qualifier 指定 Bean 的名字</p></li></ol></li><li><p>作用域 Scope</p><p>一个很坑的点: singleton bean 需要 prototype bean 的时候, 被依赖的 prototype bean 可能只会初始化一次,那么 prototype 就失效了</p><p>解决</p><ol><li><p>implement ApplicationContextAware</p><p>需要用到 Spring 的 API 侵入性很强</p></li><li><p>通过 @Lookup(“indexDaoImpl1”)注解</p><p>@Lookup 写在一个 abstract 方法上,并返回依赖</p><p>再将这个类设置为 abstract</p><p>这个类就不需要 @Autowired 或者 @Resource 注解了,直接在外部调用 Service 的方法里面再调用那个 abstract 方法即可</p><p>@Lookup(“indexDaoImpl1”),可以通过指定 bean 来防止有多个同类型的 type</p><p>@Lookup() 实际上是<strong>依赖查找 DL</strong>!</p></li></ol></li><li><p>Bean 生命周期的<strong>回调</strong> (lifecycle callback)</p><p>创建 Bean 时的回调 (销毁时同理)</p><ol><li><p>方式一: 实现 InitializingBean 接口,重写 afterPropertiesSet 方法</p></li><li><p>方法二: 对于基于 xml 的情况,可以在 bean 标签里加上</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">default-init-method</span>=<span class="hljs-string">"init"</span>&gt;</span></code></pre></div><p>并指定方法名</p></li><li><p>方法三: 在方法上写一个注解 @PostConstruct</p></li></ol></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK(7和8) 源码搭建</title>
    <link href="/2020/3/11/JDK(7%E5%92%8C8)%20%E6%BA%90%E7%A0%81%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/3/11/JDK(7%E5%92%8C8)%20%E6%BA%90%E7%A0%81%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="方法一"><a class="header-anchor" href="#方法一">⚡</a>方法一:</h2><p><a href="https://blog.csdn.net/getyouwant/article/details/50428753" target="_blank" rel="noopener">能够用的方法,这样直接修改了源文件,感觉不太好</a></p><a id="more"></a><h2 id="方法二"><a class="header-anchor" href="#方法二">⚡</a>方法二:</h2><ol><li><p>首先去官网下载对应系统版本的 JDK7 和 JDK8</p><p>(因为 JDK 不同版本的实现可能不一样,例如 HashMap 的底层实现由链表改成红黑树,所以下两个版本更保险)</p><p><strong>注意一个很坑的地方:</strong></p><blockquote><p>不要下 Open JDK,之前下载了 OpenJDK7的源码,编译一直报错,但是去官网下载的 OracleJDK8 则没有问题!</p></blockquote></li><li><p>下好后解压,源文件路径在</p><blockquote><p>JDK 根目录(例如:/opt/jdk-8u212-linux-x64/jdk1.8.0_212/src.zip) 的 src.zip 解压后的文件</p></blockquote></li><li><p>IDEA 下创建 maven 项目</p><ol><li><p>创建好项目后,再创建两个 module: jdk7 和 jdk8,分别对应 jdk 的两个版本,对应的 language level 分别设定7和8</p><p>注意:</p><p>新建 module 的父 module 不能为空,一定要是原来的项目 module</p></li><li><p>把下好的源码包完整复制到对应 module 的src文件中,并且在 project structure 里面标记 src 文件夹为 source</p></li></ol></li><li><p>整合依赖</p><ol><li><p>打开 project structure, 找到最左边的 Libraries, 点击 + ,添加一个 新的 Project Library, 找到 jdk7 这个 module 的 src 文件夹,添加</p><p>jdk8 module 同理</p></li><li><p>Modules 侧边栏中， 选择 jdk7 module 上方的 dependencies, 在点击右侧的 + 号,添加 module dependency 可以看到之前添加的 Libraries jdk7,点击添加</p><p>jdk8 module 同理</p></li><li><p><strong>第二坑的环节是这个:</strong> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>上一步 Libraries 添加好对应的 module 后,还必须将后添加的 Library 的顺序排到原来 module JDK 的前面,否则点击对应的类,还是使用 JDK 的字节码反编译后的文件</p></li><li><p>要注意版本,要在每个 module的 pom.xml 文件里面指定 Java 版本(complier version 和 target version)</p><p>例如:</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre></div><p>运行时的环境要比较低,用1.7即可,而 各自 module 的版本可以自由设置更高一些的版本</p></li></ol></li><li><p>各自的模块编译一段时间没有报错后,就可以愉快的查看对应类的 .java 文件,而非字节码反编译的只读文件,还可以直接在源码上写注释啦!</p></li><li><p>如果想要测试,就可以直接在对应 JDK 的版本的 module 中写测试样例</p></li><li><p>如果想要 debug 那么就要在 settings --&gt; debug --&gt; Stepping --&gt; Do not step into the classes 下 , 把 Java.* 取消勾选</p><p>之后打上断点就可以看看 JDK 程序是如何一步步跳转调用的了</p><p>如果 debug 进入到了 URLClassLoader 里面,就去下方的 BreakPoints,把 Java Exception BreakPoints 取消勾选</p><p>如果有一些通用性的类不想进入,例如 Object,可在 settings 的 Do not step into the classes 中加入相关的类</p><p>但是需要注意:<br>如果要写注释,尽量不要增加行,否则调试的位置就会和本来的位置不一致</p><p>还以为可能是 JVM 去掉了注释的原因?但是源代码也有自己的注释,debug 时不会出问题</p><p>可以确认是由于类加载子系统的双亲委派模型的原因,导致即使在编辑器可以设定更改指向文件,但是对于 JVM 来说,只要你没有打破双亲委派模型,虚拟机就不会去加载你项目中的同名类</p><p>ps: 这里可以算得上是 JVM 知识在实际应用中的点,以后有空了可以试着打破双亲委派机制,也是一个亮点</p></li></ol><hr><p>开源项目:</p><ol><li><p>(<a href="https://github.com/kangjianwei/LearningJDK#start-of-content" target="_blank" rel="noopener">https://github.com/kangjianwei/LearningJDK#start-of-content</a>)</p></li><li><p>(<a href="https://github.com/raysonfang/jdk1.8-source-analysis" target="_blank" rel="noopener">https://github.com/raysonfang/jdk1.8-source-analysis</a>)</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/klordy_123/article/details/82915450" target="_blank" rel="noopener">参考博客</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- IOC、DIP、DI</title>
    <link href="/2020/3/10/Sping-%E7%9F%A5%E8%AF%86-IOC%E3%80%81DIP%E3%80%81DI/"/>
    <url>/2020/3/10/Sping-%E7%9F%A5%E8%AF%86-IOC%E3%80%81DIP%E3%80%81DI/</url>
    
    <content type="html"><![CDATA[<h2 id="控制反转-IOC-Inversion-of-Control"><a class="header-anchor" href="#控制反转-IOC-Inversion-of-Control">⚡</a>控制反转 IOC (Inversion of Control )</h2><ol><li><p><span id="IOC">IoC </span>是面向对象编程中的一种<strong>设计思想</strong>,用于降低代码的耦合度,可以说是一种目的,一个目标</p></li><li><p>IoC 是原则和目标,而具体<strong>实现的方式</strong>有多种,其中最常见的就是依赖注入 (DI) (dependency Injection),其他的方式还有依赖查找 (DP) ( dependency Lookup)和依赖拖拽等</p> <a id="more"></a></li><li><p>实现 IoC 的地方,我们可以称为 IoC 容器</p></li><li><p><span id="dependency">什么是依赖?</span></p><p>依赖是面向对象编程中的一个概念,因为是面向对象编程,一个类 A 可能要用到其它的类 B 的属性或者方法,那么就说 A 依赖 B</p></li><li><p>什么是控制反转?</p><p>如果 A 依赖 B,那么一般来说,我们要么需要在类 A 中显式使用 new 关键字来创建类 B 的对象</p><p>而使用 IoC,我们只需要声明一下我们需要用到哪些对象,不需要显式的通过 new 来生成依赖对象,反而把对象的创建交给一个 IoC 容器处理和<strong>管理</strong></p><ul><li><p>其控制就是指:创建依赖对象</p></li><li><p>反转就是指: 类 A 需要创建依赖对象 B,但是在类 A 里面不显式创建,而是把创建过程交给第三方,第三方创建好之后,在自动传给我(依赖注入,DI),或者我自己去找(依赖查找,dependency lookup,DL),即<strong>反转创建依赖对象这个过程</strong></p></li></ul></li><li><p>为什么要使用 IoC</p><ol><li><p>最主要原因:面向对象编程时,需要频繁的创建对象,而手动创建管理对象可能会出现问题</p><p>例如:ServiceA 依赖 ServiceB,ServiceB 依赖 ServiceC,而 ServiceC 则同时依赖 ServiceA 和 ServiceB</p><ol><li><p>考虑循环依赖的问题(Spring 解决循环依赖的方案是三级缓存)</p><p>如果我们考虑可能的循环依赖的问题直接new 对象可能会出问题,因为 ServiceB 依赖的对象 ServiceC 没有创建,这样我们就没法直接在 ServiceA 里面写 <code>new ServiceB()</code>,当然 new 其他 Service 同理,这样程序肯定会报错</p><p>那么如果我们不再类内部创建对象,而是通过<strong>构造函数</strong>,<strong>接口</strong>或者 <strong>setter 方法</strong>传入依赖对象,这样的可以在一定程度上避免在内部创建依赖对象的问题,把这三个对象的创建由其他用于管理的类执行,这样可能可行,但是非常麻烦,因为每一个对象我们都需要来手动管理,然后自己控制赋给相应的对象</p><p>并且,更重要的是,如果你这么做了,<strong>实际上就是实现了 IoC</strong>,而且是使用 DI 的方式:把依赖的创建权交给了第三方的类,而这个第三方的实现类就是 IoC 容器</p><p>不过,这个是你自己手动实现的,而 Spring 的 IoC 容器已经为我们实现了这个,那么我们直接使用即可</p></li><li><p>就算不考虑循环依赖,但是如果创建类之后有一些通用性的配置,每次要自己实现很麻烦</p><p>比如我想要在 Service 里实现事务,那么我就要在里面的每个方法里面自己实现,而业务代码里面充斥着这种模板性的代码就很不好,可读性和维护性都很差</p><p>而如果交给 IoC 容器,你可以通过一些标识(例如注解 @Transactional)告诉容器,容器在创建每一个对象的时候,就可以自己进行相关控制,有的需要加上事务或者是其他的配置,它就可以自动的加上</p></li></ol></li></ol></li><li><p>总结 IoC 的好处(统一管理,体现了<strong>自动装配</strong>)</p><ol><li><p>最重要的就是可以不用程序员手动创建对象,而是把对象的创建和相关管理交给 IoC 容器,IoC 容器自动给你组装好,使程序员可以专注于业务逻辑</p><p>上层无需知道下层的创建过程,将创建细节隐藏,降低了对象之间的耦合度,程序员不需要知道依赖对象如何创建的,将多余的创建对象的责任交给容器,增加了灵活性</p></li><li><p>将一些通用性的配置代码交给 IoC 容器统一配置,程序员不需要考虑与业务无关的东西,简化开发,IOC 容器自动给你配置好</p></li><li><p>IoC 容器容易控制实现单例模式,节省空间,效率高</p></li><li><p>方便单元测试 mock</p></li><li><p>…</p></li></ol></li></ol><h2 id="依赖倒置原则-DIP-Dependence-Inversion-Principle"><a class="header-anchor" href="#依赖倒置原则-DIP-Dependence-Inversion-Principle">⚡</a>依赖倒置原则 DIP (Dependence Inversion Principle)</h2><ol><li><p>依赖可能产生的问题</p><p>如果类 A 里面有一个属性是类 B,这样 A 直接依赖 B 会因为耦合过高产生一些问题,比如扩展性不好,牵一发而动全身等等</p><ol><li><p>例子</p><p>例如我之前用 Java 写过的一个 <a href="https://github.com/Chao-Yin-Github/JShell" target="_blank" rel="noopener">JShell Demo</a>,最开始我在主函数里面对用户输入的指令进行一个个 if-else 判断,再去创建对应的类来调用函数来实现相应的功能</p> <div class="hljs"><pre><code class="hljs java">...<span class="hljs-keyword">if</span>(<span class="hljs-string">"cd"</span>.equals(str))&#123;    Cd.apply(input);    <span class="hljs-comment">// 对于依赖是非静态的方法或者属性</span>    Cd cd = <span class="hljs-keyword">new</span> Cd(string);    cd.apply(input);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"exit"</span>.equals(str))&#123;    Exit.apply(input);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ...</code></pre></div><p>这样的代码耦合度就很大,因为功能的实现完全依赖其他的实现类,而主函数就需要对那些依赖类进行创建和管理</p><p>如果要增加新的指令,那么就必须修改主函数增加对命令的 if-else 判断,以此创建新的类,这样非常麻烦,扩展性不好</p></li></ol></li><li><p><span id="DIP">DIP: 是设计模式的一个原则,体现的是<strong>面向接口编程的思想</strong></span></p><ol><li><p>例子</p><p>第二次改良我就写了一个接口,所有不同具体的功能类就得去实现这个接口,需要根据字符串生成不同的类不是通过 if-else 判断,而是通过反射实例化对象</p><p>而这样的好处是,我在主函数里面调用接口的方法即可,不需要关心到底是哪一个具体实现类实现了这个接口,因为无论是哪个具体实现类,我们都是要调用那个接口的方法,这样就在主函数里面消除了冗余的 if-else 语句,同时使代码变得更有扩展性,也更加能够维护.</p><p>这样,主函数<strong>不依赖具体实现</strong>而是<strong>依赖接口</strong>,而具体实现类又通过自己的具体实现去<strong>依赖抽象接口</strong>,这样就实现了<strong>依赖倒置原则 DIP</strong></p></li></ol></li></ol><p>下面这段话摘自 Wikipedia: <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><blockquote><p>With the addition of an abstract layer, both high- and lower-level layers reduce the traditional dependencies from top to bottom<br>Nevertheless, the “inversion” concept does not mean that lower-level layers depend on higher-level layers<br>Both layers should depend on abstractions that draw the behavior needed by higher-level layers.</p><p>通过添加抽象层，高层和较低层都从上到下减少了传统的依赖关系。<br>但是，“反转”概念并不意味着较低层依赖于较高层。<br>这两层都应<strong>依赖于抽象</strong>，这些抽象描述出更高层所需要的行为</p></blockquote><ol><li><p>IoC 和 DIP 的关系</p><p>IoC 和 DIP 有关，但与之不同，后者涉及通过共享抽象来解耦高层和低层之间的依赖关系。</p><p>IoC 体现的是</p><ol><li><p>类及其依赖的<strong>产生</strong>通过容器统一管理并分发,是为了简化开发,实现 IoC 是通过 DI 或者 DL 之类的技术</p></li><li><p>而 DIP 是一种经验,体现面向抽象(接口)编程的一种思想</p><p>说白了,我认为,虽然 IoC 只关心类的生命周期,但是实现比较难,而且不用 IoC 框架就得自己实现,来解决类与类之前的关系</p><p>DIP 则不同,不实现 DIP 程序也能使用,但是扩展性和维护性很差,而实现了 DIP,程序可能就很优雅,增强了扩展性和可维护性</p></li></ol></li></ol><h2 id="依赖注入-DI-Dependence-Injection"><a class="header-anchor" href="#依赖注入-DI-Dependence-Injection">⚡</a>依赖注入 DI ( Dependence Injection)</h2><ol><li><p>在 Spring Framework 的 IoC 容器中，配置有三种:xml、annotation 以及 Java config.通过 IoC 容器的控制,把对象的从生成到销毁全部管理起来,再通过依赖注入 DI 的方式将生成的对象提供给所需的类</p></li><li><p>可以说依赖是问题,而注入则是解决方案,同理还有依赖查找和依赖拖拽</p></li><li><p>依赖注入如何实现</p><p>IoC 容器创建好对象后,</p><ol><li><p>通过构造函数传入对象</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    B b;    A(B b)&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre></div></li><li><p>通过 setter 方法传入对象</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    B b;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre></div></li><li><p>通过实现接口</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceName</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">implement</span> <span class="hljs-title">InterfaceName</span></span>&#123;    B b;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre></div><p>前两个可能好理解,但是第三个感觉可能有些鸡肋?</p><p>其实使用接口则是声明了一种依赖的能力,也是可以使用的,只不过 Spring 没有提供</p></li></ol></li><li><p>依赖注入和依赖查找的区别:</p><ol><li>依赖注入只是被动接收,而依赖查找则是需要自己主动去找</li></ol></li></ol><hr><p>总结:</p><ol><li><p>术语:</p><ol><li><p><a href="#dependency">依赖(dependencies)</a>:是面向对象编程中的一个概念,因为是面向对象编程,一个类 A 可能要用到其它的类 B,那么就说 A 依赖 B.</p></li><li><p><a href="#IOC">控制反转(Inversion of Control,简称 IoC)</a>:为了解偶,将依赖对象的创建交给一个特定的容器(实现了 IoC 的类)来管理对象的生命周期,而不由程序本身实现;是一种设计思想</p></li><li><p><a href="#DIP">依赖倒置原则(Dependencies Inversion Principle,简称 DIP)</a>:是设计模式的一个原则,体现的是<strong>面向接口编程的思想</strong></p></li><li><p><a href="#DI">依赖注入(Dependencies Injection,简称 DI)</a></p></li><li><p>上面好像各种实现方式都说有构造函数,setter 方法,接口,这个实际上就是<strong>传递依赖的三种方式</strong>,而无论是 DI、DIP、IoC,实际上解决的就是依赖的问题</p></li></ol></li><li><p>参考文献:</p><ol><li><p><a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" rel="noopener">IoC Wikipedia</a></p></li><li><p><a href="https://www.zhihu.com/question/23277575" target="_blank" rel="noopener">IoC 知乎</a></p></li><li><p><a href="https://blog.csdn.net/briblue/article/details/75093382" target="_blank" rel="noopener"> IoC 、DIP 和 DI</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">DIP Wikipedia</a></p></li></ol></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener">en</a> <a href="https://zh.wikipedia.org/wiki/%E4%25%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">zh</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitBook生成电子书(pdf)</title>
    <link href="/2020/3/3/GitBook%E7%94%9F%E6%88%90%E7%94%B5%E5%AD%90%E4%B9%A6(pdf)/"/>
    <url>/2020/3/3/GitBook%E7%94%9F%E6%88%90%E7%94%B5%E5%AD%90%E4%B9%A6(pdf)/</url>
    
    <content type="html"><![CDATA[<ol><li>先 clone 仓库 (前提是 gitbook 仓库)</li></ol><a id="more"></a><ol start="2"><li><p>安装 npm 和相关 module 以及其他插件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装 npm</span>sudo pacman -S npm<span class="hljs-meta">#</span><span class="bash"> 安装 gitbook 命令行工具</span>sudo npm install gitbook-cli -g<span class="hljs-meta">#</span><span class="bash"> 此时 gitbook -V 可以看到版本号</span><span class="hljs-meta">#</span><span class="bash"> 安装caliber</span>sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin<span class="hljs-meta">#</span><span class="bash"> 检查所需要的 ebook-convert 插件是否安装成功</span>ebook-convert --version</code></pre></div><p><a href="HTTPS://CALIBRE-EBOOK.COM/DOWNLOAD">CALIBER 全平台下载地址</a></p></li><li><p>准备生成 EBOOK</p> <div class="hljs"><pre><code class="hljs SHELL">cd [项目文件夹]<span class="hljs-meta">#</span><span class="bash"> 可以看到有 SUMMARY.md,cover.jpg 等,确认是一个 gitbook类型的仓库</span><span class="hljs-meta">#</span><span class="bash"> 安装所需插件</span>gitbook install <span class="hljs-meta">#</span><span class="bash"> 生成电子书以 pdf 为例</span>gitbook pdf<span class="hljs-meta">#</span><span class="bash"> 可以看到有一个 book.pdf 文件已经生成</span></code></pre></div></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux下添加环境变量</title>
    <link href="/2020/2/26/Linux%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2020/2/26/Linux%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="header-anchor" href="#写在前面">⚡</a>写在前面</h2><p>$PATH:决定了 shell 将到哪些目录中去寻找命令或程序，PATH 的值是一系列目录，当运行一个程序时，Linux 将在这些目录下进行搜寻编译链接</p><a id="more"></a><p>添加格式为：</p><blockquote><p>PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:------:<PATH N></p></blockquote><p>编辑完成之后，通过 source .bashrc(如果是 zsh 的话,就是 .zshrc)命令立刻生效</p><p>需要注意的是，最好不要把当前路径 “./” 放到 PATH 里，这样可能会受到意想不到的攻击。</p><p>完成后，可以通过 echo $PATH 查看当前的搜索路径。这样定制后，就可以避免频繁的启动位于 shell 搜索的路径之外的程序了。</p><h2 id="步骤"><a class="header-anchor" href="#步骤">⚡</a>步骤</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改 .zshrc 文件 （如果是 bash，则是 .bashrc）</span>vim ~/.zshrc<span class="hljs-meta">#</span><span class="bash"> 在文件最后加上这样一行</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-variable">$PATH</span> 后面就是路径</span>export PATH="$PATH:/opt/gtm.v1.3.5"<span class="hljs-meta">#</span><span class="bash"> 使修改立刻生效</span>source .zshrc</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ObjectBox</title>
    <link href="/2020/2/19/ObjectBox/"/>
    <url>/2020/2/19/ObjectBox/</url>
    
    <content type="html"><![CDATA[<ol><li><p>介绍:</p><p><a href="https://github.com/objectbox/objectbox-java" target="_blank" rel="noopener">github地址</a></p> <a id="more"></a><p><a href="https://objectbox.io/cn" target="_blank" rel="noopener">官方首页</a></p><p><a href="https://docs.objectbox.io/" target="_blank" rel="noopener">文档</a></p><p><a href="https://objectbox.io/features/" target="_blank" rel="noopener">好处</a>:</p><ol><li><p>速度快:</p><p>无论是传统的 sqlite 还是 Google 推荐的 realm 和 room , 甚至作者之前的产品 GreeDao 在速度上非常有优势.</p><p><img src="https://objectbox.io/wordpress/wp-content/uploads/2018/06/performance-front-page.png" srcset="/img/loading.gif" alt="比较"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/10/163e630d5cccaf06?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="比较2"></p><blockquote><p>从图上可以看出除了在加载 100k 的大量数据的时候 ObjectBox 的速度慢于 Realm，在执行其他数据操作的时候 ObjectBox 的性能对其他两位都是近乎碾压式的存在</p></blockquote><p>官方说是世界上最快的嵌入式数据库!</p><blockquote><p>为了提供高性能的数据库；我们开发ObjectBox。经过测试，ObjectBox是世界上最快的嵌入式数据库。</p></blockquote></li><li><p>是一个 NoSQL 第三方数据库(不是 ORM)</p><p>ObjectBox 并不是一个典型 ORM，它是完全为对象构建的；所以它没有行，列和数据库。没有行，列和 SQL —— ObjectBox 是一个从零开始的对象数据仓库（没有 ORM，没有 SQLite）。</p></li><li><p>调试方便：</p> <div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-comment">// 详情见下面的全局配置示例</span>AndroidObjectBrowser(boxStore).start(context.applicationContext)</code></pre></div> <div class="hljs"><pre><code class="hljs shell">adb forward tcp:8090 tcp:8090</code></pre></div><p>在浏览器输入<a href="http://localhost:8090/index.html" target="_blank" rel="noopener">http://localhost:8090/index.html</a>就可以在网页看到数据的内容了!</p></li></ol> <!-- 1. 其他 --> <!-- ObjectBox 的团队似乎对 RxJava 不太感冒，主要是介意引入RxJava 之后急剧增加的包体积和方法数，所以 ObjectBox 自己封装了一套支持 Reactive Extensions 的接口。 --></li><li><p>博客文章</p><p><a href="https://juejin.im/post/5b1c34fae51d4506ce34a56b" target="_blank" rel="noopener">https://juejin.im/post/5b1c34fae51d4506ce34a56b</a></p><p><a href="https://juejin.im/post/5a0e7bdc6fb9a0451a75f38e" target="_blank" rel="noopener">https://juejin.im/post/5a0e7bdc6fb9a0451a75f38e</a></p><p><a href="https://www.jianshu.com/p/e9996296a982" target="_blank" rel="noopener">https://www.jianshu.com/p/e9996296a982</a></p><p><a href="https://www.jianshu.com/p/e4ebaa433ae7" target="_blank" rel="noopener">https://www.jianshu.com/p/e4ebaa433ae7</a></p><p><a href="https://zhuanlan.zhihu.com/p/31146878" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31146878</a></p></li><li><p>项目例子:</p><ol><li><p>代码地址:</p><p><a href="mailto:git@github.com">git@github.com</a>:objectbox/objectbox-examples.git</p></li><li><p>心得体会</p><p>此项目有很多 module 使用 android-app-kotlin 这一个 module 就好</p><p>android-app-kotlin module 里面有两个类似的文件分别是 NoteActivity 和 ReactiveNoteActivity</p><p>其区别是,前者使用对数据进行更改需要刷新页面的时候,是使用重新查找全部内容然后重新渲染,并且调用 notifyDataSetChanged()方法实现,其思想较简单.</p><p>而 ReactiveNoteActivity 虽然也是重新查找数据并显示,但却是使用订阅观察者模式和多线程的方法,而和前者顺序顺序执行有所区别.</p><p>我猜测可能是基于效率和方便复用的考量</p><p>因为当用户增加文本的时候,会刷新全部数据,把最新的数据刷新上去,但是此时增加按钮应该是阻塞状态.(觉得这个想法有点牵强,不过也是因为这个比较简单的原因,如果是上传大文件或者是项目逻辑比较复杂的时候就应该很有用了)</p><p>复用是为了方便,因为不需要再每次的 addNote() 方法里面顺序调用 updateNotes() 方法重新查找并将数据保存到内存的list里面,而是隐式调用这个方法,减少模板代码的书写.</p></li></ol></li><li><p>注意事项</p><ol><li><p>先编译项目否则会提示有的类找不到</p></li><li><p>必须要一个自增 ID 才行, 用注解 @Id 标识</p></li><li><p>apply plugin: ‘io.objectbox’ 一定要添加到 dependencies 模块后面</p></li><li><p>但是,如果 put、find 这些方法全是同步的，对于大量数据的存和查都是耗时操作，如果直接写在主线程会阻塞主线程，尤其是 find 方法，而 ObjectBox 的 Reactive 封装显然没有 RxJava 那么强大，</p></li><li><p>尽量使用全局配置</p> <div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> ObjectBox &#123;    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> boxStore: BoxStore    <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;        boxStore = MyObjectBox.builder().androidContext(context.applicationContext).build()        <span class="hljs-keyword">if</span> (BuildConfig.DEBUG) &#123;            <span class="hljs-keyword">val</span> start = AndroidObjectBrowser(boxStore).start(context.applicationContext)            Log.d(App.TAG, <span class="hljs-string">"browser start status: <span class="hljs-variable">$start</span>)"</span>)        &#125;    &#125;&#125;</code></pre></div></li><li><p>(手机路径)默认保存位置在 /data/data/包名/files/objectbox/data.mdb</p></li><li><p>设置查询个数</p> <div class="hljs"><pre><code class="hljs kotlin">Query.find(<span class="hljs-built_in">Long</span> offset, <span class="hljs-built_in">Long</span> limit)</code></pre></div></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh</title>
    <link href="/2020/2/3/ssh/"/>
    <url>/2020/2/3/ssh/</url>
    
    <content type="html"><![CDATA[<h2 id="ssh免密登陆"><a class="header-anchor" href="#ssh免密登陆">⚡</a>ssh免密登陆</h2><a id="more"></a><div class="hljs"><pre><code class="hljs shell">cd ~/.ssh<span class="hljs-meta">#</span><span class="bash"> 生成公有和私有密钥id_rsa.pub和iid_rsa</span><span class="hljs-meta">#</span><span class="bash">需要输入的密码地方按回车即可</span>ssh-keygen -t rsa -C '标记'ls -alssh-copy-id -i id_rsa.pub java@218.199.68.208<span class="hljs-meta">#</span><span class="bash">验证登陆</span>ssh -i ./id_rsa java@218.199.68.208</code></pre></div><h2 id="ssh别名登陆"><a class="header-anchor" href="#ssh别名登陆">⚡</a>ssh别名登陆</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">没有config就创建</span>vim ~/.ssh/config</code></pre></div><div class="hljs"><pre><code class="hljs xml">#加入以下配置:Host feidianHostName 218.199.68.208User javaIdentityFile ~/.ssh/id_rsa.pubIdentitiesOnly yes#去相应服务器上用 vim .ssh/authorized_keys 查看是否已经添加</code></pre></div><h2 id="使用ssh连接到github"><a class="header-anchor" href="#使用ssh连接到github">⚡</a>使用ssh连接到github</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 先将~/.ssh目录下的id_rsa.pub文件内容粘贴,再去Github的个人设置的页面,把内容复制过去,在title写下标签,例如:Linux,方便以后管理</span><span class="hljs-meta">#</span><span class="bash"> 测试能否连接上</span>ssh -T git@github.com<span class="hljs-meta">#</span><span class="bash"> 一般来说第一次会出现提示让你确定是否继续连接输入yes即可</span><span class="hljs-meta">#</span><span class="bash"> 如果要等待很长一段时间或者出现timeout的情况,那么可能是本机的防火墙端口配置出现了问题,则修改~/.ssh/config文件</span>vim ~/.ssh/config</code></pre></div><div class="hljs"><pre><code class="hljs xml">Host github.com# 把下方的Email改成自己的EmailUser YourEmailHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa## 修改端口号为443Port 443</code></pre></div><p>再次ssh -T测试即可</p><h2 id="ssh连接Gitlab"><a class="header-anchor" href="#ssh连接Gitlab">⚡</a>ssh连接Gitlab</h2><p>和Github配置同理,如果出现timeout,则修改配置文件:</p><div class="hljs"><pre><code class="hljs xml">Host gitlab.com# 把下方的Email改成自己的EmailUser YourEmailHostname altssh.gitlab.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
      <tag>shellCommand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidSetting</title>
    <link href="/2020/1/25/AndroidSetting/"/>
    <url>/2020/1/25/AndroidSetting/</url>
    
    <content type="html"><![CDATA[<h1>Android Studio配置</h1><a id="more"></a><ul><li><p>解决Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 1.6. Please specify proper ‘-jvm-target’ option</p><p>在app/build.gradle文件内添加以下内容</p>  <div class="hljs"><pre><code class="hljs gradle">android &#123;    ...    compileOptions &#123;        <span class="hljs-keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8        <span class="hljs-keyword">targetCompatibility</span> JavaVersion.VERSION_1_8    &#125;    kotlinOptions &#123;        jvmTarget = JavaVersion.VERSION_1_8.toString()    &#125;&#125;</code></pre></div></li><li><p>加入toasty</p><p>在app/build.gradle文件中加入:</p>  <div class="hljs"><pre><code class="hljs gradle"><span class="hljs-keyword">allprojects</span> &#123;    <span class="hljs-keyword">repositories</span> &#123;    ...    maven &#123; url <span class="hljs-string">"https://jitpack.io"</span> &#125;    &#125;&#125;</code></pre></div><p>在module/build.gradle文件中加入:</p>  <div class="hljs"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;    <span class="hljs-comment">// add Toasty</span>    implementation <span class="hljs-string">'com.github.GrenderG:Toasty:1.4.2'</span>&#125;</code></pre></div></li><li><p>使用viewBinding</p><p>在app/build.gradle文件中加入:</p>  <div class="hljs"><pre><code class="hljs xml">android&#123;    ...    viewBinding&#123;        enabled = true    &#125;&#125;...dependencies &#123;    // add viewBinding    implementation 'cz.kinst.jakub:viewmodelbinding:2.0.0'&#125;</code></pre></div><p>如果想要在生成 binding class 时忽略某个布局文件, 我们需要在该布局文件的根元素添加 <code>tools:viewBindingIgnore=&quot;true&quot;</code> 属性.</p><p>注意:</p><blockquote><p>目前ViewBinding的功能还不够完善，比如XML中使用了 inClude 标签时无法对view进行引用。</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cron表达式</title>
    <link href="/2020/1/10/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/1/10/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Cron表达式是一个字符串，以五个或者六个空格隔开，分为6或7个域，每一个域代表一个含义</p><a id="more"></a><p>秒 (0～59)<br>分 (0～59)<br>小时 (0～23)<br>天 (0-31/28/30) <strong>月的第几天</strong><br>月 （0-11）<br>星期 (1-7) <strong>星期几</strong><br>年份 (1970~2099)</p><p>每个元素可以是:</p><ul><li><p>一个具体值</p></li><li><p>一个连续区间(9-12)</p></li><li><p>一个间隔时间</p><p>0/5: 表示从0开始每间隔5，写到哪个元素就表示间隔的是哪个元素，如果写到了秒，那么表示从0开始，每隔5秒执行一次。</p></li><li><p>一个列表</p><p>(1,3,5): 表示第1,3,5时间执行</p></li><li><p>通配符</p><p>(，- * / L W #)</p><p>月份的日期和星期的日期这两个元素是互斥的，必须对其中一个设置通配符 <code>？</code></p></li></ul><p>通配符的详解</p><ul><li><code>*</code> 所有可能的值</li><li><code>/</code> 指定数值的增量</li><li><code>？</code> 表示不指定值</li><li><code>L</code> 表示最后，只能用在<code>日</code>或者<code>周</code>那一栏</li><li><code>W</code> 离指定日期最近的那个工作日(周一至周五), 只能在<code>日</code>那一栏使用。</li><li><code>#</code> 表示每月的第几个周几</li></ul><p><strong>注意</strong>：</p><ol><li><p>基本都允许的字符： ， - * ？</p></li><li><p>特别的:</p><p>表示<code>日</code>的域还可以用 L W</p><p>星期也可以用 L</p></li></ol><p>例如：</p><ol><li><p>0 55 23 L * ? 表示每月的最后一天的23:55分</p></li><li><p>0 0/30 9-17 * * ? ? ? 朝九晚五工作时间内每半小时</p></li><li><p>0 0 12 ? * WED 表示每个星期三中午12点</p></li><li><p>0 0 12 * * ? 每天12点触发</p></li><li><p>0 15 10 ? * * 每天10点15分触发</p></li><li><p>0 * 10 * * ? 每天10:00-10:59每分钟触发一次</p></li><li><p>0 0/5 10 * * ? 每天 10:00-10:59每隔5分钟触发</p></li><li><p>0 0/5 10,15 * * ? 每天10:00-10:59,15:00-15:59(每隔5分触发)</p></li><li><p>0 0-5 15 * * ? 每天15:00-15:05每分触发</p></li><li><p>0 10,55 14 ? 3 WED 3月份每周三14:10触发 ,14:55触发</p></li><li><p>0 15 10 ? * MON-FRI 从周一到周五每天10:15分触发</p></li><li><p>0 15 10 15 * ? 每月15号10:15分触发</p></li><li><p>0 15 10 L * ? 每月最后一天的10:15分触发</p></li><li><p>0 15 10 ? * 6L 每月最后一周的星期五的10:15分触发</p></li><li><p>0 15 10 ? * 6L 2017-2020 从2017年到2020年每月最后一个星期五的10:15分触发</p></li><li><p>0 15 10 ? * 6#3 每月的第三周的星期五10:15触发</p></li><li><p>0 0 12 1/5 * ? 每月的第一天开始每隔5天的12:00触发一次</p></li><li><p>0 11 11 11 11 ? 每年的11月11号 11点11分触发(光棍节)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java聊天器</title>
    <link href="/2019/12/14/Java%E8%81%8A%E5%A4%A9%E5%99%A8/"/>
    <url>/2019/12/14/Java%E8%81%8A%E5%A4%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>项目地址</h1><p><a href="https://github.com/Chao-Yin-Github/javaChartDemo" target="_blank" rel="noopener">https://github.com/Chao-Yin-Github/javaChartDemo</a></p><a id="more"></a><h1>项目介绍</h1><ul><li><p>开发环境</p><ul><li><p>Manjaro 18.1.4 Juhraya</p></li><li><p>JDK:1.8.0_212</p></li><li><p>intellij-idea 2019.3</p></li></ul></li><li><p>本项目基于Java NIO开发，使用到了以下技术:</p><ol><li><p>Java NIO</p><p>使用ServerSocketChannel和SocketChannel，完成客户端和服务端socket通道的建立，来实现数据传输</p></li><li><p>使用slf4j日志框架进行日志管理和程序信息输出</p></li><li><p>使用lombok简化Java Bean的Setter和Getter方法、构造方法、toString等模板化方法的撰写</p></li><li><p><strong>自定义数据传输协议</strong>(Transmission.java)**</p></li></ol></li><li><p>技术栈分析</p><ul><li><p>NIO</p><ul><li><p>背景</p><p>NIO是jdk1.4才引入的，有人称作Non-Blocking-IO(非阻塞IO)，还有人喜欢把他成为New-IO。</p><p>我认为各自都有理，首先Non-Blocking-IO就不用说了，因为NIO提供了非阻塞的IO模式，这和传统的BIO(Blocking-IO)有了明显区别。</p><p>那为什么New-IO也是可以的呢，因为NIO是面向缓冲的(Buffer oriented)，基于通道(Channel)(双工，既能读也能写)的IO操作方法，这样就和老式的BIO面向流(Stream oriented)(单方向，只能读或者只能写)的操作，有了本质的区别，所以把它称作New-IO也不无道理。</p></li></ul></li><li><p>使用自定义协议传输数据(Transmission.java)</p><ul><li><p>背景:</p><p>当我在基本分别完成传输字符串和传输文件的功能时，遇到了一个问题，NIO的Server是单线程的，那么就不能通过一般的方式解决传输文件和文本字符串的问题。</p><p>因为如果是多线程的服务端，可以在有一个新的连接到服务端时，服务端就开启一个线程专门处理这个客户端的连接，多个客户端之间不会混乱。</p><p>这样，我这个用户1可以先发送一个标识符来标识一下，我接下来将要发送文本字符串还是文件。如果有客户2同时发送别的信息，服务端的这两个线程之间是不会受到任何影响的。</p><p>但是通过NIO写的服务端是单线程处理连接的，这样，一个用户1发送一个标识符表示接下来会发送一个字符串，但是这时，又有另外一个用户把文件发送过来，服务端是没法分辨出到底是哪一个客户端发送的标识符，也无法分辨出是哪一个客户端发送的数据，这样服务端就会混乱掉。</p></li><li><p>解决办法</p><ol><li><p>方法一：</p><p>最容易想到的是：</p><p>既然服务端无法标识用户，那么客户端就可以规定一个长度一定的标识，然后后面接着数据一起发送给服务端，那么服务端就可以直接把标识信息和数据一起读出来。</p><p>我传输文件用的是FileChannel，然后再使用transferFrom和transferTo方法来实现传到SocketChannel里面和从SocketChannel里面读取数据到FileChannel。</p><p>这样转化其实是可行的，但是我觉得有些麻烦也不够优雅。</p></li><li><p>方法二：</p><p>和方法一一样，都是把标识信息和数据一起传输，但是方式略有不同。</p><p>对于发送方的客户端，我们可以把信息和数据全部封装成一个类，然后我们就可以把这个类序列化成字符串，再把字符串转化为字节数组用SocketChannel传输。</p><p>而服务端则将接收的字节数组反序列化成对象，从中提取需要的信息，再序列化传输给另一个客户端。</p><p>至于另一个接收方的客户端，则同理，将获得的字节数组反序列化成对象，就可以拿到数据进行处理获取相应的内容了。</p></li></ol></li><li><p>选择方法二的理由</p><p>我认为方法二比方法一更好的理由是:如果自定义一个类传输数据，我们就可以把这个类称作为一种数据传输协议。</p><p>因为像http传输协议就是一个基于tcp/ip的传输协议，它定义了请求/响应行(Request/Response Line)，请求/响应头(Request/Response Header)，空行和请求/响应数据(Request/Response Body)，所有使用http协议都要有它所规定的这些结构。</p><p>而这个Transmission类其实也是一样的道理，声明了数据的类型(TransmissionType)，也保存了数据内容(content)本身，还有消息目的方的信息(destinationNumber)等等信息。</p><p><strong>由此，我可以大胆把这个Transmission类称作为我自己的一个聊天器协议！</strong></p></li><li><p>Transmission.java</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transmission</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 数据内容</span><span class="hljs-comment">     */</span> <span class="hljs-keyword">private</span> String content;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文件类型</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> TransmissionType transmissionType;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送目的客户编号</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> destinationNumber;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 原客户编号</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sourceNumber;&#125;</code></pre></div></li><li><p>TransmissionType.java</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> TransmissionType implements Serializable &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文件类型</span><span class="hljs-comment">     */</span>    FILE,        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文本字符串</span><span class="hljs-comment">     */</span>    STRING,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 信息</span><span class="hljs-comment">     */</span>    MESSAGE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * id标识</span><span class="hljs-comment">     */</span>    UUID&#125;</code></pre></div></li><li><p>那这个Transmission类如何传输文本字符串和文件这两种数据呢？</p><p>对于文本字符串自不必说，把要发送的字符串存到content字段里即可，接收方可以直接获取content字段内容。</p><p>至于传输文件，我是先把文件转化成字节数组，再用Base64加密以防字符集乱码，再转化成字符串存到content里。</p><p>接收数据时，则跟发送数据时的操作正好相反，先把读到的字节数组转化成Transmission类，再拿到content字段内容之后，先用Base64解密，再转化为文件保存下来。</p></li></ul></li></ul></li><li><p>可能时由于网络速度的限制加上NIO的特性，这个在本地测试没问题，可是一放到服务器上就出现超过一定大小文件就发送失败的问题。可能和服务器的网速太慢还有NIO非阻塞的特性两者综合作用的结果。因为网速较慢，所以有时服务端接收到一半就认为没有数据了，而客户端的数据还没有发送上来，而服务端又是NIO非阻塞的特性，所以很可能数据读到一半就停止了，开始转化信息，但是数据不完整就会出错。这个由于时间问题还没有解决，以后有空的时候还是想找找其他方法解决一下。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中对象和对象引用的区别</title>
    <link href="/2019/12/6/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/12/6/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="对象"><a class="header-anchor" href="#对象">⚡</a>对象</h2><p>对象是什么?</p><p>在《Java编程思想》里，是这样解释的：</p><a id="more"></a><blockquote><p>“按照通俗的说法，每个对象都是某个类（class）的一个实例（instance），这里，‘类’就是‘类型’的同义词。”</p></blockquote><p>所以对象是类的实例。而类就是类型的意思。</p><h2 id="对象引用"><a class="header-anchor" href="#对象引用">⚡</a>对象引用</h2><p>同样是《Java编程思想》里面的一句话：</p><blockquote><p>“每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。”</p></blockquote><p>用一个例子来理解</p><div class="hljs"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();</code></pre></div><p>A a则仅仅是对象的声明，是在栈上创建了一个对象引用。</p><p>即a是一个对象引用而非对象本身。</p><p>而只有当new A()这个操作调用之后，才在堆上创建一个类A的对象，或者说是实例。</p><p>而a = new A()；才是真正把a这个对象引用和对象本身关联上。</p><h2 id="对象和对象引用的区别"><a class="header-anchor" href="#对象和对象引用的区别">⚡</a>对象和对象引用的区别</h2><p>下面看一个例子</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">int</span> b = a[<span class="hljs-number">0</span>];        b = <span class="hljs-number">123</span>;        System.out.println(a[<span class="hljs-number">0</span>]);    &#125;&#125;</code></pre></div><p>如果我们认为Java中的引用和C中的指针是同一个东西的话，上面这段Java程序就应该对应的下面这段c++程序</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">1</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> *b = a;*b = <span class="hljs-number">123</span>;<span class="hljs-built_in">cout</span>&lt;&lt;a[<span class="hljs-number">0</span>];<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>这段C++程序的结果当然是123。</p><p>但上面第一段Java程序输出结果当然是0而不是123。</p><p>这是因为Java中的引用虽然和C++的指针看似好像一样，都是描述变量的工具，但实际上还是有差别的。</p><hr><p>Java中的变量只有两种类型，一种是基本数据类型，还有一种是引用类型。</p><p>当作为参数传递给一个方法时，处理这两种类型的方式是相同的。Java中都是<strong>按值传递</strong>，没有引用传递。即：</p><p>按值传递意味着传递的是原始值的一个副本。这样，即使函数改变了值，改变的也是原始值的副本，而非原始值本身。</p><p>而引用传递则意味着函数接收的就是原始值本身，这样当函数修改这个值，那么对应的原始值也会被修改。</p><p>看一个例子</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinchao</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewClassForTest</span> </span>&#123;    <span class="hljs-keyword">int</span> a;    String name;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinchao</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMethod</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        String string = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"123"</span>);        NewClassForTest newClassForTest = <span class="hljs-keyword">new</span> NewClassForTest();        newClassForTest.a = <span class="hljs-number">1</span>;        newClassForTest.name =  <span class="hljs-string">"test1"</span>;        change(string,newClassForTest);        System.out.println(string);        System.out.println(newClassForTest.a+<span class="hljs-string">"\n"</span>+newClassForTest.name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(String newString,NewClassForTest newClassForTest)</span> </span>&#123;        newString = <span class="hljs-string">"1234"</span>;        newClassForTest.a = <span class="hljs-number">2</span>;        newClassForTest.name = <span class="hljs-string">"test2"</span>;    &#125;&#125;</code></pre></div><blockquote><p>结果：<br>123<br>2<br>test2</p></blockquote><p>那么在此处为什么同样是通过change方法，string的结果没变，而newClassForTest的改变了?</p><ul><li><p>对于string因为在change方法中，newString = &quot;1234&quot;实际上是newString = new String(&quot;1234);</p><p>newString这个对象引用已经不再指向原来的对象&quot;123&quot;了，在new String的过程中，newString这个对象引用已经把原来的指向取消，而且建立了一个新的指向到这个新的String “1234”。“1234”，而原来的string还是指向到原来的&quot;123&quot;，并没有收到对象引用副本改变指向的影响。</p></li><li><p>对于newClassForTest，newClassForTest.a = 2;实际上是把对象的属性赋了新的值。函数形参和实参都是对象的引用，而且都是指向同一个对象，和副本并无关系，和是否在函数内也没有关系。这两个newClassForTest并没有主从之分，一个对象引用改变的对象的属性,另一个对象引用的对象当然也会随之改变。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql中的相关子查询和不相关子查询</title>
    <link href="/2019/10/28/SQL%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8C%E4%B8%8D%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <url>/2019/10/28/SQL%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8C%E4%B8%8D%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<ul><li><p>不相关子查询：</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ×<span class="hljs-keyword">from</span> tableOneName<span class="hljs-keyword">where</span> columnName <span class="hljs-keyword">in</span> (    <span class="hljs-keyword">select</span> columnName    <span class="hljs-keyword">from</span> tableTwoName    <span class="hljs-keyword">where</span> condition);</code></pre></div>  <a id="more"></a><p>类似上面这种<strong>先执行子查询</strong>，得到一个集合或者值，然后将这个集合或者值作为一个<strong>常量</strong>，再带入到父查询中作为父查询的一个条件。</p></li><li><p>相关子查询</p><p>通俗来说，相关子查询就是：子查询要用到父查询中的值。</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> *<span class="hljs-keyword">from</span> tableOneName<span class="hljs-keyword">where</span> columnOneName <span class="hljs-keyword">in</span> (    <span class="hljs-keyword">select</span> columnOneName    <span class="hljs-keyword">from</span> tableTwoName    <span class="hljs-keyword">where</span> tableTwoName.columnTwoName = tableOneName.columnTwoName)</code></pre></div><p>先扫描副查询的数据表中的<strong>每一条</strong>记录，然后将当前这条记录中的子查询会用到的数据，<strong>带入到子查询中</strong>，然后<strong>再执行子查询</strong>，得到结果，然后再将这个结果<strong>回代</strong>到父查询中，判断父查询的值是否为true，如果为true则把这条记录放回到结果集中，反之，如果为false，则不会把这条记录放到结果集中。</p><blockquote><p>此时，子查询就用到了父查询的结果</p></blockquote></li><li><p>如何判断是相关的还是不相关的子查询？</p><p>如果子查询不能脱离父查询单独执行，那么就是相关子查询。</p></li><li><p>EXISTS</p><p>exists的概念和相关子查询的概念相似，它的作用就是判断子查询得到的<strong>结果集是否是一个空集</strong>。</p><p>它和相关子查询一样，在子查询中用到父查询的条件。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql中having 和 where的区别</title>
    <link href="/2019/10/24/SQL%E4%B8%ADhaving%E5%92%8Cwhere%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/10/24/SQL%E4%B8%ADhaving%E5%92%8Cwhere%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ul><li><p>having 是对结果进行筛选</p><p>having是一个过滤声明，所谓过滤是在查询数据库的结果返回之后进行过滤，即在结果返回之后起作用，并且having后面可以使用“聚合函数”。</p>  <a id="more"></a></li><li><p>where 是在查询数据的时候直接对数据库进行筛选</p><p>where是一个约束声明，在查询数据库的结果返回之前对数据库中的查询条件进行约束，即在结果返回之前起作用，且where后面不能使用“聚合函数”。</p></li><li><p>聚合函数，是对一组值进行计算并且返回<strong>单一值</strong>的函数。聚合函数一定是返回一个结果。</p></li><li><p>where后面之所以不能使用聚合函数是因为where的执行顺序在聚合函数之前</p></li><li><p>having 是对查出来的结果进行过滤，这样就不能对没有查出来的值进行过滤。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 -- 状态模式(state)</title>
    <link href="/2019/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F(state)/"/>
    <url>/2019/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F(state)/</url>
    
    <content type="html"><![CDATA[<h2 id="一句话概括"><a class="header-anchor" href="#一句话概括">⚡</a>一句话概括</h2><p>状态模式<strong>允许对象在内部状态时改变它的行为，对象看起来好像修改了它所属的类。</strong></p><a id="more"></a><p>用途：</p><p>主要是解决当控制一个对象装换的条件表达式过于复杂的时候，把状态判断逻辑转移到表示不同状态的一系列类当中。<strong>可以把复杂的判断逻辑简化。</strong></p><h2 id="例子"><a class="header-anchor" href="#例子">⚡</a>例子</h2><p>现在有这样一个需求：</p><blockquote><p>有一个糖果机，当有人把25美分的硬币放到机器里，转动曲柄，这个机器就会弹出糖果。<br>但是，这个机器有好几种状态，在某些状态下可以弹出糖果，而在某些状态下不能。</p></blockquote><p>如下图所示，用圆圈表示状态，箭头表示行为。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/289823/1571417665158-d62d91cf-f506-44b2-a01f-203f80039da0.png" srcset="/img/loading.gif" alt="糖果机"></p><h3 id="if-else-switch-case-大法"><a class="header-anchor" href="#if-else-switch-case-大法">⚡</a>if-else / switch case 大法</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GumBall</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 糖果机状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> State state;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 糖果数目</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;GumBall(<span class="hljs-keyword">int</span> number) &#123;<span class="hljs-keyword">if</span> (number &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">this</span>.number = number;state = State.NO_QUARTER_STATE;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">this</span>.number = <span class="hljs-number">0</span>;state = State.NO_CANDY_STATE;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 投入一个25美分硬币买糖果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"投入硬币"</span>);<span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",已经放有硬币，请稍候"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">",售罄"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">",正在出货，请等待"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 允许投入硬币的情况</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",成功投入一枚硬币"</span>);state = State.HAS_QUARTER_STATE;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 拿回硬币</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"退款"</span>);<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">",已售罄"</span>);&#125;<span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",没有硬币"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">",硬币已存入"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",退还硬币成功"</span>);state = State.NO_QUARTER_STATE;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 转动曲柄</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"转动曲柄"</span>);<span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",未付款，请先投入硬币"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">"，已售罄"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">"，请稍候正在出货"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">""</span>);state = State.GOING_TO_PRODUCE_STATE;dispense();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 分发糖果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"分发糖果"</span>);<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">",没有糖果，无法出货"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",没有硬币，请先付款"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",请先转动曲柄"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">",出货成功"</span>);number--;<span class="hljs-keyword">if</span> (number == <span class="hljs-number">0</span>) &#123;System.out.println(<span class="hljs-string">"糖果卖完了"</span>);state = State.NO_CANDY_STATE;&#125; <span class="hljs-keyword">else</span> &#123;state = State.NO_QUARTER_STATE;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"state:"</span> + String.valueOf(state) + <span class="hljs-string">"\tinventory:"</span> + number;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 装填糖果</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> number 新加入糖果数量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refill</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;System.out.println(<span class="hljs-string">"before refill:"</span> + <span class="hljs-keyword">this</span>.number);<span class="hljs-keyword">this</span>.number += number;<span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span> || state == State.NO_CANDY_STATE) &#123;state = State.NO_QUARTER_STATE;&#125;System.out.println(<span class="hljs-string">"after refill:"</span> + <span class="hljs-keyword">this</span>.number);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> State &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 没有25美分</span><span class="hljs-comment"> */</span>NO_QUARTER_STATE,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 有25美分</span><span class="hljs-comment"> */</span>HAS_QUARTER_STATE,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 即将产生糖果</span><span class="hljs-comment"> */</span>GOING_TO_PRODUCE_STATE,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 售罄</span><span class="hljs-comment"> */</span>NO_CANDY_STATE&#125;&#125;</code></pre></div><p>主函数测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;GumBall gumBall = <span class="hljs-keyword">new</span> GumBall(<span class="hljs-number">2</span>);System.out.println(gumBall.toString());<span class="hljs-comment">// 正常流程</span>gumBall.insertQuarter();gumBall.turnCrank();System.out.println(gumBall.toString());<span class="hljs-comment">// 直接退款无效</span>gumBall.ejectQuarter();System.out.println(gumBall.toString());<span class="hljs-comment">// 投钱再取出,再转动曲柄，无效</span>gumBall.insertQuarter();gumBall.ejectQuarter();gumBall.turnCrank();System.out.println(gumBall.toString());<span class="hljs-comment">// 投钱再转动曲柄,再取出，有效</span>gumBall.insertQuarter();gumBall.turnCrank();gumBall.ejectQuarter();System.out.println(gumBall.toString());<span class="hljs-comment">// 没货了</span>gumBall.insertQuarter();gumBall.ejectQuarter();gumBall.turnCrank();System.out.println(gumBall.toString());&#125;&#125;</code></pre></div><p>输出：</p><blockquote><p>state:NO_QUARTER_STATEinventory:2</p></blockquote><blockquote><p>投入硬币,成功投入一枚硬币<br>转动曲柄<br>分发糖果,出货成功<br>state:NO_QUARTER_STATEinventory:1</p></blockquote><blockquote><p>退款,没有硬币<br>state:NO_QUARTER_STATEinventory:1</p></blockquote><blockquote><p>投入硬币,成功投入一枚硬币<br>退款,退还硬币成功<br>转动曲柄,未付款，请先投入硬币<br>state:NO_QUARTER_STATEinventory:1</p></blockquote><blockquote><p>投入硬币,成功投入一枚硬币<br>转动曲柄<br>分发糖果,出货成功<br>糖果卖完了<br>退款,已售罄<br>state:NO_CANDY_STATEinventory:0</p></blockquote><blockquote><p>投入硬币,售罄<br>退款,已售罄<br>转动曲柄，已售罄<br>state:NO_CANDY_STATEinventory:0</p></blockquote><p>到目前为止好像都很顺利?</p><hr><p>然后，最讨厌的部分还是来了，<strong>改需求！?</strong></p><blockquote><p>现在，糖果机为了增加销量增加，有10%的几率会在转动曲柄的时候出来两颗糖果。</p></blockquote><p>这样糖果机会多出一个 <strong>'中奖’</strong> 状态</p><p>那么，此时就要修改原来写好的代码逻辑：</p><p>在insetQuarter、ejectQuarter、turnCrank（）、dispense（）等方法里，每个方法再加上一个if条件判断-&gt;是否为中奖状态。</p><p>而且turnCrank方法会变得特别复杂，因为这里就需要考虑是转变为<strong>中奖状态(winner_state)<strong>还是</strong>即将销售状态(Going_to_produce_state)</strong>。</p><p>存在的问题:</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/289823/1571416247293-a5fb488a-852c-46af-a9b8-3189bbfe809c.png" srcset="/img/loading.gif" alt="存在的问题"></p><p>这样的程序就更像是一般我们写C++的顺序的，或者说是过程化的编程范式，没有用到面向对象的设计思想，而且扩展性很差。</p><p>无独有偶，在《重构：改善既有代码的设计》一书中，提到一个概念：<br><strong>代码的坏味道(bad smell)：</strong></p><p>其中一种就是Long Method(过长的方法)</p><p>由此，状态模式就出场了⬇。</p><hr><h3 id="状态模式"><a class="header-anchor" href="#状态模式">⚡</a>状态模式</h3><ul><li><p>新的设计:</p><blockquote><p>将<strong>状态对象</strong>封装到各自类中，然后在动作发生时<strong>委托</strong>给当前状态。</p></blockquote></li><li><p>步骤：</p><ol><li><p>定义一个State<strong>接口</strong>。</p><p>糖果机的每个动作都有一个对应的<strong>方法</strong>,然后把所有动作封装好。</p></li><li><p>为机器中每个状态实现<strong>状态类</strong>。</p><p>这些具体状态类负责在对应状态下进行机器的行为。</p></li><li><p>将动作委托到状态类。</p></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/289823/1571416193267-d7c6251c-33f0-4a04-a6f0-13bec77ae5fc.png" srcset="/img/loading.gif" alt="类图"></p><ul><li><p>代码</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">turnGrank</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 没有硬币状态</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoQuarterState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span>()</span>&#123;NewGumball newGumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NoQuarterState</span><span class="hljs-params">(NewGumBall newGumBall)</span></span>&#123;<span class="hljs-keyword">this</span>.newGumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"成功投入一枚硬币"</span>);newGumBall.setState(newGumBall.getHasQuarterState());&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"没有硬币，退款失败"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"请先投入硬币再转动曲柄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"请先投入硬币"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"NoQuarterState"</span>);&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 没有糖果状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoCandyState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<span class="hljs-keyword">private</span> NewGumBall newgumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NoCandyState</span><span class="hljs-params">(NewGumBall newGumBall)</span> </span>&#123;<span class="hljs-keyword">this</span>.newgumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"NoCandyState"</span>;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 即将出货状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoingToBeProduceState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<span class="hljs-keyword">private</span> NewGumBall newGumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GoingToBeProduceState</span><span class="hljs-params">(NewGumBall newGumBall)</span> </span>&#123;<span class="hljs-keyword">this</span>.newGumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"正在出货，请勿重复投币"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;newGumBall.releaseCandy();<span class="hljs-keyword">if</span> (newGumBall.getCandyNumber() &gt; <span class="hljs-number">0</span>) &#123;newGumBall.setState(newGumBall.getNoQuarterState());&#125; <span class="hljs-keyword">else</span> &#123;System.out.println(<span class="hljs-string">"最后一个糖果已卖出"</span>);newGumBall.setState(newGumBall.getNoCandyState());&#125;System.out.println(<span class="hljs-string">"出货成功"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"退款失败，硬币已投入"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"正在出货，请勿转动曲柄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"GoingToBeProduceState"</span>;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 有硬币状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasQuarterState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<span class="hljs-keyword">private</span> NewGumBall newGumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HasQuarterState</span><span class="hljs-params">(NewGumBall newGumBall)</span> </span>&#123;<span class="hljs-keyword">this</span>.newGumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"已投入硬币，请勿重复投入"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"请转动曲柄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"退款成功"</span>);newGumBall.setState(newGumBall.getNoQuarterState()); &#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"转动曲柄，等待出货"</span>);newGumBall.setState(newGumBall.getGoingToBeProduceState());&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"HasQuarterState"</span>;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 全新的糖果机</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewGumBall</span> </span>&#123;<span class="hljs-keyword">private</span> State state;<span class="hljs-keyword">private</span> State goingToBeProduceState;<span class="hljs-keyword">private</span> State HasQuarterState;<span class="hljs-keyword">private</span> State NoCandyState;<span class="hljs-keyword">private</span> State NoQuarterState;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> candyNumber = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NewGumBall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> candyNumber)</span> </span>&#123;goingToBeProduceState = <span class="hljs-keyword">new</span> GoingToBeProduceState(<span class="hljs-keyword">this</span>);HasQuarterState = <span class="hljs-keyword">new</span> HasQuarterState(<span class="hljs-keyword">this</span>);NoCandyState = <span class="hljs-keyword">new</span> NoCandyState(<span class="hljs-keyword">this</span>);NoQuarterState = <span class="hljs-keyword">new</span> NoQuarterState(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">if</span> (candyNumber &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">this</span>.candyNumber = candyNumber;state = NoQuarterState;&#125; <span class="hljs-keyword">else</span> &#123;state = NoCandyState;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseCandy</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"糖果已出货"</span>);<span class="hljs-keyword">if</span> (candyNumber &gt; <span class="hljs-number">0</span>) &#123;candyNumber--;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;<span class="hljs-keyword">this</span>.state = state;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCandyNumber</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> candyNumber;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getGoingToBeProduceState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> goingToBeProduceState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getHasQuarterState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> HasQuarterState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getNoCandyState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> NoCandyState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getNoQuarterState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> NoQuarterState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;state.insertQuarter();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;state.turnCrank();state.dispense();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;state.ejectQuarter();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"state:"</span> + state + <span class="hljs-string">"\t inventory:"</span> + candyNumber;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;NewGumBall newGumBall = <span class="hljs-keyword">new</span> NewGumBall(<span class="hljs-number">2</span>);System.out.println(newGumBall.toString());<span class="hljs-comment">// 正常流程</span>newGumBall.insertQuarter();newGumBall.turnCrank();System.out.println(newGumBall.toString());<span class="hljs-comment">// 直接退款无效</span>newGumBall.ejectQuarter();System.out.println(newGumBall.toString());<span class="hljs-comment">// 投钱再取出,再转动曲柄，有效</span>newGumBall.insertQuarter();newGumBall.ejectQuarter();newGumBall.turnCrank();System.out.println(newGumBall.toString());<span class="hljs-comment">// 投钱再转动曲柄,再取出，无效</span>newGumBall.insertQuarter();newGumBall.turnCrank();newGumBall.ejectQuarter();System.out.println(newGumBall.toString());<span class="hljs-comment">// 没货了</span>newGumBall.insertQuarter();newGumBall.ejectQuarter();System.out.println(newGumBall.toString());&#125;&#125;</code></pre></div><p>输出：</p><blockquote><p>state:NoQuarterSate inventory:2</p></blockquote><blockquote><p>成功投入一枚硬币<br>转动曲柄，等待出货<br>糖果已出货<br>出货成功<br>state:NoQuarterSate inventory:1</p></blockquote><blockquote><p>没有硬币，退款失败<br>state:NoQuarterSate inventory:1</p></blockquote><blockquote><p>成功投入一枚硬币<br>退款成功<br>请先投入硬币再转动曲柄<br>请先投入硬币<br>state:NoQuarterSate inventory:1</p></blockquote><blockquote><p>成功投入一枚硬币<br>转动曲柄，等待出货<br>糖果已出货<br>最后一个糖果已卖出<br>出货成功<br>售罄<br>state:NoCandyState inventory:0</p></blockquote><blockquote><p>售罄<br>售罄<br>售罄<br>售罄<br>state:NoCandyState inventory:0</p></blockquote><ul><li><p>好处？</p><ol><li><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开。</p><p>局部化：将具有普适性的行为抽象出来，放到一个抽象对象中封装起来。</p><p>这样，当有新的状态加入时，我们可以通过定义新的状态类来实现接口/继承父类，来<strong>消除庞大的条件分支语句</strong>来判断状态。</p><p>原理:把逻辑分布到State子类之间，来减少相互间的依赖。</p></li><li><p>而且当从这个状态对象转化为另为一个状态对象时，封装起来的行为潜在的改变，但是用户对此毫不知情。</p></li></ol></li><li><p>缺点:</p><p>子类太多，不好管理。</p></li><li><p>适用情况:</p><ol><li><p>当一个对象有很多种状态，而且他的行为依赖于他的状态，并且在运行时可能动态改变。</p></li><li><p>一个对象中含有庞大的条件分支语句，并且这些分支依赖于该对象的状态。</p></li></ol></li></ul></li></ul><hr><h2 id="设计模式之外的部分"><a class="header-anchor" href="#设计模式之外的部分">⚡</a>设计模式之外的部分</h2><ol><li><p>多范式编程语言: 支持超过一种编程范型语言</p></li><li><p>编程范型: 一类典型编程风格，如:</p><blockquote><p>并发编程，约束编程，数据流编程，声明性编程，分布式的编程，函数式编程，泛型编程，命令式(指令式)编程，逻辑编程，元编程，面向对象编程</p></blockquote><p>过程式编成: 主要采取程序调用（procedure call）或函数调用（function call）的方式来进行流程控制。</p><p>编程范型提供并决定程序员对程序执行的看法</p><p>Scala是一门多范式的编程语言，集成面向对象和函数式编程的特性。</p><p>C++支持过程化，面向对象，范型编程</p></li><li><p>符合迪米特法则(得墨忒耳定律 Law of Demeter -&gt; LoD、最小知识原则)：</p><p>迪米特法则可以简单说成：talk only to your immediate friends。</p><p>一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p><ol><li><p>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；</p></li><li><p>每个单元只能和它的朋友交谈：不能和陌生单元交谈；</p></li><li><p>只和自己直接的朋友交谈。</p></li></ol><p>得墨忒耳定律使得软件更好的可维护性与适应性。</p><p>因为对象较少依赖其它对象的内部结构，可以改变对象容器（container）而不用改变它的调用者（caller）。</p><blockquote><p>一个简单例子是，人可以命令一条狗行走(walk)，但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p></blockquote></li><li><p>卫语句</p><p>如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为“卫语句”。</p><p>常用到的地方: if语句使用“卫语句 ”减少层级嵌套。</p></li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>拥有[短方法] (short methods)的对象会活得比较好、比较长。不熟悉面向对象技术的人，常常觉得对象程序中只有无穷无尽的delegation(委托)，根本没有进行任何计算。和此类程序共同生活数年之后，你才会知道，这些小小方法有多大价值。［间接层］所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型方法支持的。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring MVC 知识 -- 接收 Post 请求的几种方式</title>
    <link href="/2019/9/16/Spring-MVC-%E7%9F%A5%E8%AF%86-%E6%8E%A5%E6%94%B6-Post-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2019/9/16/Spring-MVC-%E7%9F%A5%E8%AF%86-%E6%8E%A5%E6%94%B6-Post-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Content-Type以application/x-www-form-urlencoded进行传输</p><p>此种传输方式是构造form表单的普通post请求的方式进行传输</p> <a id="more"></a><p>controller中需要有两个参数，同时这个两个参数不能加@RequestBody或者是加@RequestParam，参数会以字符串和数组的形式填充到参数里面</p></li><li><p>Content-Type以application/json的方式进行传输</p><p>此种方式需要传输一个json格式的字符串</p><p>controller中需要以一个字符串来进行接受这个json字符串</p><p>如果用注解的话需要添加@RequestBody</p><p>如果不用注解，需要从request域里面把body内容读取出来，然后将此字符串进行json反序列化成对象，如果想让他自动转化成对象，需要在SpringMVC的配置里面配置json序列化工具。</p><p>接收参数：多个单一属性的一个对象</p></li><li><p>以键值对方式发送请求</p><p>这样发送参数在请求头，即每个参数使用@RequestParam注解即可</p><p>接受参数：多个单一参数</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Spring MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器搭建手记(Ubuntu)</title>
    <link href="/2019/9/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%89%8B%E8%AE%B0(Ubuntu)/"/>
    <url>/2019/9/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%89%8B%E8%AE%B0(Ubuntu)/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="软件安装"><a class="header-anchor" href="#软件安装">⚡</a>软件安装</h2>  <a id="more"></a><ul><li><h3 id="mysql"><a class="header-anchor" href="#mysql">⚡</a>mysql</h3>  <div class="hljs"><pre><code class="hljs shell">sudo apt-get update<span class="hljs-meta">#</span><span class="bash"> 直接装老版本5.7</span>sudo apt-get install mysql-server</code></pre></div><ul><li><p>修改root用户密码</p><p>在debain系的Linux下，mysql是有默认的debian-sys-maint用户的</p><p>其密码在/etc/mysql/debain.cnf下</p>  <div class="hljs"><pre><code class="hljs shell">mysql -udebian-sys-maint -ppassword</code></pre></div>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">use</span> mysql;<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> authentication_string=<span class="hljs-keyword">password</span>(<span class="hljs-string">'root'</span>) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">'root'</span> <span class="hljs-keyword">and</span> Host=<span class="hljs-string">'localhost'</span>;<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">plugin</span>=<span class="hljs-string">"mysql_native_password"</span>;        <span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;quit;</code></pre></div></li><li><p>创建用户，授予权限</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment"># 创建用户</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">'guest'</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'密码'</span>;<span class="hljs-comment"># 授予databaseName数据库的所有权限</span>grants all privileges on databaseName.* to 'guest'@'%' with grant option;<span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;<span class="hljs-comment"># 或者授予mysql所有权限</span>grants all privileges on *.* to 'guest'@'%' with grant option;<span class="hljs-comment"># 查看权限</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">grants</span> <span class="hljs-keyword">for</span> guest;</code></pre></div></li><li><p>开启远程连接</p>  <div class="hljs"><pre><code class="hljs shell">cd /etc/mysql/mysql.conf.d/sudo vim mysqld.cnf</code></pre></div>  <div class="hljs"><pre><code class="hljs cnf"># 把下面这行注释掉bind-address &#x3D; 127.0.0.1</code></pre></div>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 重启</span>sudo systemctl restart mysql</code></pre></div></li></ul></li><li><p>JDK8(Oracle)</p><p>网上ppa源的办法已失效，只能手动去官网下载jdk8的tar.gz包</p><ol><li><p>在本地下载好scp传到服务器</p></li><li><p>在服务器端解压</p></li></ol></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
      <tag>shellCommand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux软链</title>
    <link href="/2019/9/1/Linux%E8%BD%AF%E9%93%BE/"/>
    <url>/2019/9/1/Linux%E8%BD%AF%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="写在前面"><a class="header-anchor" href="#写在前面">⚡</a>写在前面</h2><p>在Linux系统中，内核为每一个新创建的文件分配一个inode(索引结点)，每个文件有一个唯一的inode号。文件属性保存在inode里。</p>  <a id="more"></a><p>在访问文件时，inode被复制到内存里，从而实现文件的快速访问。</p></li><li><h2 id="链接是什么？"><a class="header-anchor" href="#链接是什么？">⚡</a>链接是什么？</h2><p>链接是一种共享文件和访问它的用户的若干目录项之间建立联系的一种方法。</p><p>在windows下，我们称为快捷方式。</p></li><li><h2 id="硬链接"><a class="header-anchor" href="#硬链接">⚡</a>硬链接</h2><p>如果一个inode对应多个文件名，则称这些文件为硬链接。</p><p>换言之，硬链接就是一个文件的多个别名。也可以认为是以inode作为文件指针。</p><ul><li><p>特性:</p><ul><li><p>文件inode相同</p></li><li><p>只能对已存在的文件进行创建</p></li><li><p>不能交叉文件系统进行硬链接的创建</p></li><li><p>不能对目录进行创建，只能对文件</p><p>但是可以通过*通配符进行文件夹中的文件统一创建</p></li><li><p>删除一个硬链接文件不影响其它相同inode文件，只是结点连接数减少。</p><p>只要结点连接数不是0，文件就一直存在。</p><p>而且此时就不再区分源文件和链接文件，只要任一文件被修改，所有文件都会同步修改。</p></li><li><p>只有超级用户才可以为目录创建硬链接。</p></li></ul></li><li><p>创建硬链接</p>  <div class="hljs"><pre><code class="hljs shell">link existingFile newFile</code></pre></div><p>这样当前目录下就出现了一个和existingFile一模一样的文件newFile</p></li></ul></li><li><h2 id="软链接，也成为符号链接"><a class="header-anchor" href="#软链接，也成为符号链接">⚡</a>软链接，也成为符号链接</h2><p>软链接就是一个普通文件，它有着自己的inode号。</p><p>软链接就是另一文件的指向。可以认为是以文件路径名作为文件指针。</p><ul><li><p>特性:</p><ul><li><p>有自己的文件属性和权限</p></li><li><p>可以对不存在的文件或目录创建</p></li><li><p>可以交叉文件系统</p></li><li><p>删除软链接并不影响原文件，但若原文件被删除，相关软链接则被称为死链接</p></li></ul></li><li><p>创建软链</p>  <div class="hljs"><pre><code class="hljs shell">link -s sourceFile newFile</code></pre></div></li><li><p>删除软链</p><p>注意软链接newFile后面不能加<code>/</code>，否则会删除原文件。</p>  <div class="hljs"><pre><code class="hljs shell">rm -rf newFile</code></pre></div></li><li><p>修改软链接</p>  <div class="hljs"><pre><code class="hljs shell">ln -snf sourceFile newFile</code></pre></div><p>这样就把newFile的指向指到了sourceFile的路径了。</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
      <tag>shellCommand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java重载和重写</title>
    <link href="/2019/8/30/Java%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99/"/>
    <url>/2019/8/30/Java%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99/</url>
    
    <content type="html"><![CDATA[<ul><li><p>重载</p><p>overload</p><p>在<strong>同一个类</strong>中，方法名字相同，参数不同。</p></li></ul><a id="more"></a><div class="hljs"><pre><code>和返回值没有关系。无法以返回值类型作为重载函数的区分标准。以类的多态性表现。</code></pre></div><ul><li><p>重写</p><p>override (覆盖)</p><p><strong>方法的名字和参数列表被称为方法签名</strong></p><p>如果子类中定义了一个与超类方法签名相同的方法，那么就实现了覆盖或者叫重写。</p><p>即是子类和父类之间的关系。</p><p>注意：</p><ol><li><p>在实现覆盖的时候，子类的方法<strong>不能低于</strong>超类方法的可见性。</p></li><li><p>重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其<strong>子类</strong>；</p></li><li><p>返回类型可以和超类不同，但是必须为超类返回值的<strong>子类</strong>。</p></li><li><p>超类的方法如果用final修饰，则子类不允许覆盖。</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的对象</title>
    <link href="/2019/8/29/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/8/29/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="PO"><a class="header-anchor" href="#PO">⚡</a>PO</h2><p>persistent object (持久对象)</p><p>一般看成是与数据库中的表相映射的java对象。</p><p>po中应该<strong>不包含任何</strong>对数据库的操作</p>  <a id="more"></a></li><li><h2 id="VO"><a class="header-anchor" href="#VO">⚡</a>VO</h2><p>view object (value object) 表现层对象</p><p>和po一样仅仅包含数据，并且是页面显示<strong>所需要</strong>的数据。</p></li><li><h2 id="BO"><a class="header-anchor" href="#BO">⚡</a>BO</h2><p>business object (业务对象)</p><p>把业务逻辑封装为一个对象，可以包含其他几个或多个对象。</p><p>通常需要把BO转化为PO，才能进行数据持久化;<br>反之，从数据库中得到PO，转化成BO才能在业务层使用。</p></li><li><h2 id="POJO"><a class="header-anchor" href="#POJO">⚡</a>POJO</h2><p>plain old java object (简单无规则java对象)</p><p>宽泛的概念</p><blockquote><p>POJO转化之后 =&gt; PO<br>POJO传输过程中 =&gt; DTO<br>POJO用作表现层 =&gt; VO</p></blockquote></li><li><h2 id="DAO"><a class="header-anchor" href="#DAO">⚡</a>DAO</h2><p>data access object (数据访问对象)</p><p>几种理解:</p><ol><li><p>是sun的一个标准J2EE设计模式，这个模式中有个接口就是DAO，负责将PO持久化到数据库发，也负责将数据库查询结果集映射为PO。</p></li><li><p>为业务层提供接口，<strong>此对象用于访问数据库(CRUD操作)</strong></p></li></ol><p>通常和PO结合使用，DAO中包含了各种数据库的操作方法，提供数据库的CRUD操作。</p></li><li><h2 id="DTO"><a class="header-anchor" href="#DTO">⚡</a>DTO</h2><p>data transform object (数据传输对象)</p><p>有几种理解:</p><ol><li><p>用在需要跨进程或者远程传输时，它不应该包含业务逻辑</p></li><li><p>一个例子:</p><blockquote><p>一张表有100个字段，PO就有100个属性，但是有一些属性比如密码，是不能展示出来的，我们只展示10个字段。那么我们就没必要把PO传给客户端，而可以把只有需要的10个属性的DTO传给客户端，这样也不会暴露表结构。到达客户端之后，这个对象用来展示对应数据，那么它就变成了VO。</p></blockquote></li></ol></li></ul><p><img src="https://raw.githubusercontent.com/YME86/PersonalResourcePlan/master/picture/Java%E5%AF%B9%E8%B1%A1.jpeg" srcset="/img/loading.gif" alt="Java对象大集合"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bug记录 -- 前端传值 null</title>
    <link href="/2019/8/27/Bug%E8%AE%B0%E5%BD%95-%E5%89%8D%E7%AB%AF%E4%BC%A0%E5%80%BCnull/"/>
    <url>/2019/8/27/Bug%E8%AE%B0%E5%BD%95-%E5%89%8D%E7%AB%AF%E4%BC%A0%E5%80%BCnull/</url>
    
    <content type="html"><![CDATA[<p>在后台开发经常会遇到的一个需求：</p><p>用户输入id，我们就根据这个id去数据库里面找相应的数据。</p><!-- more --><p>但是，用户还可以选择在id的同时传入一段时间，（start和end）在这段时间内查找数据。</p><p>甚至，用户还可以选择第三个条件上传者uploader，需要我们同时根据id，时间，和上传者三个条件同时查找数据。</p><p>不过解决方法其实很简单，我们不需要在java程序里进行复杂的条件判断到底哪几个条件为空，在每个条件下单独写sql语句。</p><p>我们只需要在mybatis的mapper.xml里，进行if判断即可。</p><div class="hljs"><pre><code class="hljs xml">select *from tableNamewhere id = #&#123;id,jdbcType = INTEGER&#125;<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">"start!=null and start !='' and end !=null and end != ''"</span>&gt;</span>and date between #&#123;start,jdbcType=TIMESTAMP&#125; and #&#123;end,jdbcType=TIMESTAMP&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">uploader!</span>=<span class="hljs-string">null</span> <span class="hljs-attr">and</span> <span class="hljs-attr">uploader</span>!=<span class="hljs-string">''</span> "&gt;</span>and uploader = #&#123;uploader,jdbcType=VARCHAR&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></code></pre></div><p>这样，如果用户输入的某一个条件为空，那么就不会用于sql的条件判断里。</p><p>经过测试事实也的确是这样</p><p>当前端传了uploader=，后面没有值的时候，没有问题</p><div class="hljs"><pre><code class="hljs json">&#123;    id: 1    uploader:&#125;</code></pre></div><p>当前端不传uploader，也没有问题</p><div class="hljs"><pre><code class="hljs json">&#123;    id:1&#125;</code></pre></div><p><strong>但是！！！！</strong></p><p>当前端传的是</p><div class="hljs"><pre><code class="hljs json">&#123;    id:1    uploader:null&#125;</code></pre></div><p>这时传入的就是null这个<strong>字符串</strong>!!!</p><p>虽然前端返回的<strong>的的确确返回的就是<code>null(空)</code></strong>，但是后台在接收的时候就变成了**<code>null(字符串)</code>**</p><p>由此，我们可以大胆的把if判断改成如下格式</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">'uploader != "null" and uploader!=null and uploader!="" '</span>&gt;</span>and uploader = #&#123;uploader,jdbcType=VARCHAR&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></code></pre></div><p>注意单双引号有所改变</p><hr><p>还有一个很坑的点，后台时间参数是Date类型时，传入的必须是<code>2019/08/27 23:26:41</code>这样的时间格式</p><p>而传入参数为<code>2019-08-27 23:26:41</code>时，后台就必须为String类型的，否则会出现参数不匹配的错误(MisMatch)</p><p>而且，当参数是String时，无需担心和Date类型不匹配，直接传入String到mapper.xml里，不过记得jdbcType还是写TIMESTAM即可。可能mybatis框架会有优化吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2019/8/27/%E5%BC%82%E5%B8%B8/"/>
    <url>/2019/8/27/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>异常的几种类型:</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Chao-Yin-Github/PersonalResourcePlan/master/picture/TypeOfException.png" srcset="/img/loading.gif" alt="异常的几种类型"></p><p>以旅行实例说明异常的分类：</p><ul><li><p>武汉发生地震，属于不可抗因素，对应**<code>Error</code>**错误，这个我们根本想不到具体发生的原因。例如，突然没有权限往硬盘上写数据的能力了。这种就只能老老实实的把错误信息返回（如果有的话），程序无法处理。</p></li><li><p>堵车，或者航班延误，属于异常**<code>Exception</code><strong>，确切来说属于异常中的</strong><code>checked</code>**，即受检异常，对于这种异常，我们虽然可以预料，但是预料到了也无能为力，只有监测并关注。</p></li><li><p>没有带驾驶证，或者忘记机票，属于异常中的**<code>unchecked</code><strong>类型。具体则属于</strong>可预测的异常**这些完全可以预测并且返回相应的提示。</p></li><li><p>需捕捉异常，例如:汽车抛锚，我们就需要采取公共汽车作为解决的方式</p></li><li><p>检票机坏掉了，属于可透出异常，交由航空公司处理即可，我们无法处理。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bug 记录 -- Maven 错误记录合集</title>
    <link href="/2019/8/25/Bug%E8%AE%B0%E5%BD%95-Maven-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%E5%90%88%E9%9B%86/"/>
    <url>/2019/8/25/Bug%E8%AE%B0%E5%BD%95-Maven-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ul><li><p>运行mvn package提示-source 1.5，编译失败</p>  <!-- more --><p>设置maven中的Java版本为8</p>  <div class="hljs"><pre><code class="hljs shell">sudo vim /opt/maven/conf/setting.xml</code></pre></div><p>找到注释掉的example—profile，或者直接在最后添加</p>  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>JDK1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span></code></pre></div></li><li><p>java -jar maven打包后的jar文件，提示没有主清单程序</p><p>这是因为项目中有多个main函数入口，这样就必须在pom文件中指明主程序入口。</p>  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">transformers</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span> <span class="hljs-attr">implementation</span>=<span class="hljs-string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.example.project.mianApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">transformers</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>其中<code>com.example.project</code>是入口类所在的包名，即<code>groupId</code>和<code>artifactID</code>拼接而成的结果</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis使用</title>
    <link href="/2019/8/22/Mybatis%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/8/22/Mybatis%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="idea下使用Spring-Boot-搭建Mybatis框架"><a class="header-anchor" href="#idea下使用Spring-Boot-搭建Mybatis框架">⚡</a>idea下使用Spring Boot 搭建Mybatis框架</h2><a id="more"></a><ul><li><p>添加maven依赖</p></li><li><p>在application.properties文件中，添加Mybatis的配置：</p>  <div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">mybatis.config-location=classpath:mybatis-config.xml</span></code></pre></div></li><li><p>在resources下新建mybatis-config.xml，具体配置请见文件。</p></li><li><h2 id="parameter-和-parameter-的区别"><a class="header-anchor" href="#parameter-和-parameter-的区别">⚡</a>#{parameter} 和 ${parameter} 的区别</h2><p><strong>#是占位符号，$是拼接符号</strong></p><ol><li><p>参数预处理</p><ul><li><p><code>#</code> 将传入的数据当成一个字符串，会自动对传入数据<strong>加双引号</strong></p></li><li><p><code>$</code> 将传入的数据直接显示，而不处理</p></li></ul></li><li><p>sql注入</p><ul><li><p><code>$</code> 不能防止sql注入</p></li><li><p><code>#</code> 可以防止sql注入</p></li></ul></li><li><p><strong><code>$</code></strong> 一般用于传入<strong>数据库对象</strong>，例如表名、列名</p></li><li><p>尽量使用<code>#</code></p></li><li><p>order by动态参数需要用<code>$</code></p></li></ol></li><li><h2 id="trim"><a class="header-anchor" href="#trim">⚡</a>trim</h2></li></ul><table><thead><tr><th style="text-align:center">trim的几个属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">prefix</td><td style="text-align:center">当 trim 元素包含有内容时， 增加 prefix 所指定的前缀</td></tr><tr><td style="text-align:center">prefixOverrides</td><td style="text-align:center">当 trim 元素包含有内容时， 去除 prefixOverrides 指定的 前缀</td></tr><tr><td style="text-align:center">suffix</td><td style="text-align:center">当 trim 元素包含有内容时， 增加 suffix 所指定的后缀</td></tr><tr><td style="text-align:center">suffixOverrides</td><td style="text-align:center">当 trim 元素包含有内容时， 去除 suffixOverrides 指定的后缀</td></tr></tbody></table><p>下面的语句表示为：trim标签中有内容时，添加 where ，而当第一个为and 或者 or 时，会把 and 或者 or 去掉。而如果trim标签中没有内容，则不会添加where语句。(此语句和<where> 标签等价)</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"where"</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">"AND | OR"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre></div><p>同理，还有类似<set> 标签的trim</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"set"</span> <span class="hljs-attr">suffiexOverrides</span>=<span class="hljs-string">","</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre></div><p>当trim中有内容时，添加set，当最后一个为<code>,</code>时，去掉它。</p>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SwaggerUI</title>
    <link href="/2019/8/20/SwaggerUI/"/>
    <url>/2019/8/20/SwaggerUI/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="SwaggerUI简述"><a class="header-anchor" href="#SwaggerUI简述">⚡</a>SwaggerUI简述</h2><p>Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件</p>  <a id="more"></a><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>总体目标是使客户端和文件系统作为服务器以同样的速度来更新。</p><p>文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步</p></li><li><h2 id="Spring-Boot-Maven-依赖"><a class="header-anchor" href="#Spring-Boot-Maven-依赖">⚡</a>Spring Boot Maven 依赖</h2>  <div class="hljs"><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!--swagger2--&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><h2 id="配置"><a class="header-anchor" href="#配置">⚡</a>配置</h2><p>在configuration包下，新建SwaggerUIConfiguration</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*在类上加入注解*/</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-meta">@Configuration</span><span class="hljs-comment">/* 控制swagger是否开启，当application.properties设置中swagger.enable=true,即符合havingValue的期望值时配置生效 */</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"swagger"</span>, value = &#123;<span class="hljs-string">"enable"</span>&#125;, havingValue = <span class="hljs-string">"true"</span> )<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerUIConfiguration</span></span>&#123;<span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestfulApi</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)        .apiInfo(apiInfo())        .select()        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.example"</span>))        .paths(PathSelectors.any())        .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()        .titile(<span class="hljs-string">"title"</span>)        .description(<span class="hljs-string">"====================\n"</span>        +<span class="hljs-string">"项目名称:xxx\n"</span>        +<span class="hljs-string">"项目分支:xxx\n"</span>        +<span class="hljs-string">"项目成员:xxx\n"</span>            +<span class="hljs-string">"====================\n"</span>            +<span class="hljs-string">"项目简介:后端采用Spring Boot + Mybatis框架,使用Mysql数据库\n"</span>        +<span class="hljs-string">"====================\n"</span>        +<span class="hljs-string">"注意事项:\n"</span>        +<span class="hljs-string">"1. 后端服务端口号:xxx\n"</span>        +<span class="hljs-string">"2. develop分支为开发版本,master分支为稳定版本\n"</span>        +<span class="hljs-string">"3. 每次提交认真写git commit\n\n"</span>        +<span class="hljs-string">"====================\n"</span>)        .termsOfServiceUrl(<span class="hljs-string">""</span>)        .version(<span class="hljs-string">"1.0"</span>)        .build();    &#125;&#125;</code></pre></div></li><li><h2 id="注解介绍"><a class="header-anchor" href="#注解介绍">⚡</a>注解介绍</h2></li></ul><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">@Api</td><td style="text-align:center"></td><td style="text-align:center">用在Contoller控制器类上,标志这个类是Swagger的资源</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">value</td><td style="text-align:center">[没有效果]</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">tags</td><td style="text-align:center">控制器说明</td></tr><tr><td style="text-align:center">@ApiOperation</td><td style="text-align:center"></td><td style="text-align:center">用在接口方法上,描述方法的作用</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">value</td><td style="text-align:center">方法说明</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">note</td><td style="text-align:center">增加说明</td></tr><tr><td style="text-align:center">@APiImplicitParams</td><td style="text-align:center"></td><td style="text-align:center">用在接口方法上,包装器,用{}包含多个ApiImplicitParam</td></tr><tr><td style="text-align:center">@ApiImpicitParam</td><td style="text-align:center"></td><td style="text-align:center">定义在ApiImplicitParams内  ,描述单个参数的详细信息</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">ParamType</td><td style="text-align:center">获取参数的位置</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">header -&gt; @RequestHeader</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">query -&gt; @RequestParam</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">path -&gt; @PathVariable</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">body: 以流的形式提交,进支持post</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">form: 以form表单形式提交,仅支持post</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">name</td><td style="text-align:center">参数名</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">dataType</td><td style="text-align:center">参数的数据类型,有<strong>Long</strong> 和String，但是用Long会出现格式错误问题，所以数字统一也用String</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">required</td><td style="text-align:center">是否为必须参数true/false</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">value</td><td style="text-align:center">参数说明</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">defaultValue</td><td style="text-align:center">参数默认值</td></tr><tr><td style="text-align:center">@ApiResponses</td><td style="text-align:center"></td><td style="text-align:center">用在接口方看法上,用{}包含多个@ApiResonse</td></tr><tr><td style="text-align:center">@ApiResponse</td><td style="text-align:center"></td><td style="text-align:center">表示一个错误信息</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">code</td><td style="text-align:center">状态码[200、201、403、404、500等]</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">message</td><td style="text-align:center">状态信息</td></tr><tr><td style="text-align:center">@ApiModel</td><td style="text-align:center"></td><td style="text-align:center">用在类上,描述对象的作用</td></tr><tr><td style="text-align:center">@ApiModelProperty</td><td style="text-align:center"></td><td style="text-align:center">描述对象中字段的作用 ,一般用在请求对象或者返回结果对象</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- 注解 -- @Resource 和 @Autowired</title>
    <link href="/2019/7/28/Spring-%E7%9F%A5%E8%AF%86-%E6%B3%A8%E8%A7%A3-@Resource-%E5%92%8C-@Autowired/"/>
    <url>/2019/7/28/Spring-%E7%9F%A5%E8%AF%86-%E6%B3%A8%E8%A7%A3-@Resource-%E5%92%8C-@Autowired/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="相同点："><a class="header-anchor" href="#相同点：">⚡</a>相同点：</h2><ol><li><p>都是bean注入时使用</p></li><li><p>二者都可以写在字段上用来消除Setter和Getter方法</p></li><li><p>也可以写在Setter方法上</p></li></ol></li></ul><a id="more"></a><ul><li><h2 id="不同点："><a class="header-anchor" href="#不同点：">⚡</a>不同点：</h2><ol><li><h3 id="包"><a class="header-anchor" href="#包">⚡</a>包</h3><p>@Resource 是属于Java EE的，在Javax包下</p><p>@Autowired 是属于Spring boot的</p></li><li><h3 id="自动装配的类型-Resource"><a class="header-anchor" href="#自动装配的类型-Resource">⚡</a>自动装配的类型-<code>@Resource</code></h3><p>@Resource 默认按照byName注入，但也可以用byType注入</p><p>spring将其注解的name属性解析为bean的名字，而type属性解析为bean的类型。</p><ol><li><p>若同时指定了name和type属性，则从spring上下文中找到唯一的匹配的bean进行装配，找不到则抛出异常。</p></li><li><p>如果指定了name，则从上下文中查找名称（id）匹配的bean，找不到同上。</p></li><li><p>如果指定了type，则从上下文中查找类似匹配的bean，找不到或者<strong>找到多个</strong>都会抛出异常。</p></li><li><p>如果既不指定name，也不指定type，这时将通过反射机制使用默认的byName，没有匹配则退为一个原始类型进行匹配。</p></li></ol></li><li><h3 id="自动装配的类型-Autowired"><a class="header-anchor" href="#自动装配的类型-Autowired">⚡</a>自动装配的类型-<code>@Autowired</code></h3><p>默认通过byType自动注入，如果 byType 找不到或者找到了多个，则通过属性的 byName 注入，如果 byName 也找不到，则报错。</p><p>默认情况下它要求依赖的对象必须存在，如果允许 null，则可以将它的 required 属性设置为 false。</p><p>如果想按照名字来自动装配，则需结合 <code>@Qulifier</code> 注解使用：</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-meta">@Qulifier</span>(<span class="hljs-string">"userDao"</span>)<span class="hljs-keyword">private</span> UserDao userDao;</code></pre></div></li></ol></li></ul><p>个人感觉用Autowired会更整齐，而且也方便。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok</title>
    <link href="/2019/7/27/Lombok/"/>
    <url>/2019/7/27/Lombok/</url>
    
    <content type="html"><![CDATA[<ul><li><p>@Setter、@Getter、@ToString、@NonNull</p></li><li><p>@NoArgsConstructor、@AllArgsConstructor</p>  <a id="more"></a><p>有final修饰的变量无法使用NoArgsConstructor</p></li><li><p>@RequiredConstructor</p><p>生成类中所有@NonNull注释或者是final修饰的变量的构造函数</p><p>三种注释都不能用在含有静态数据成员的类上</p></li><li><p>@Data</p><p>包含了以下注解：</p><p>@Setter、@Getter、@ToString、@equals、@hashCode</p></li><li><p>@value与@Data类似，只不过前者会把所有变量没，默认为pirvate final，并且不会生成setter方法(final不可修改)。</p></li><li><p>@SneakyThrows: 捕获异常。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Commit 规范</title>
    <link href="/2019/7/14/Git-Commit-%E8%A7%84%E8%8C%83/"/>
    <url>/2019/7/14/Git-Commit-%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="git-commit-规范"><a class="header-anchor" href="#git-commit-规范">⚡</a>git commit 规范</h2><ul><li><p>Header</p><p>type (scope) : subject</p>  <a id="more"></a><p>type的几种类型</p><ul><li><p>feat: 新功能</p></li><li><p>fix: 修补bug</p></li><li><p>docs: 文档</p></li><li><p>style: 格式</p></li><li><p>refactor: 重构</p></li><li><p>test: 测试</p></li><li><p>chore: 构建工程或者辅助工具的变动</p></li></ul><p>subject:</p><ul><li><p>以动词开头，使用<strong>第一人称现在时</strong></p></li><li><p>第一个字母小写</p></li><li><p>结尾不加符号</p></li></ul></li><li><p>Body</p></li><li><p>Footer</p><p>适用情况:</p><ul><li><p>不兼容变动</p><p>当前代码和上一个版本不兼容，则以<code>BREAKING CHANGE</code>开头</p></li><li><p>关闭issue</p><p>Closes #123</p><p>关闭123号issue</p></li><li><p>revert</p><p>撤销以前的commit，以<code>revert:</code>开头，后面紧跟着被撤销Commit的Header</p></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+Github Pages搭建博客指南</title>
    <link href="/2019/7/12/hexo-Github%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    <url>/2019/7/12/hexo-Github%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<ol><li><h2 id="hexo-ndoejs安装"><a class="header-anchor" href="#hexo-ndoejs安装">⚡</a>hexo+ndoejs安装</h2><p>hexo:</p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">具体说明请看官方文档</a></p><p>node + npm:</p> <div class="hljs"><pre><code class="hljs shell">sudo pacman -S nodejs npm</code></pre></div><p><a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">npm 权限问题</a></p></li><li><h2 id="主题配置"><a class="header-anchor" href="#主题配置">⚡</a>主题配置</h2><ol><li><p>选择一个主题克隆下来</p><p>例如：<a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">alpha-dust</a></p> <div class="hljs"><pre><code class="hljs shell">git clone https://github.com/klugjo/hexo-theme-alpha-dust themes/alpha-dustgit clone</code></pre></div></li><li><p>修改所需配置</p><ol><li><p>author，discription等等</p></li><li><p>修改favicon</p><ol><li><p><a href="http://www.faviconico.org/favicon" target="_blank" rel="noopener">在线生成ico</a></p></li><li><p>把生成的文件放到 blog/source目录下</p><p>并修改文件名为favicon.ico</p></li><li><p>(并没有效果) 修改blog/_config.yml</p> <div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 增加一行</span><span class="hljs-string">favicon:/favicon.ico</span></code></pre></div></li></ol></li></ol></li><li><p>使用hexo</p><ol><li><p>生成草稿或者新的markdown文件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 生成草稿</span>hexo new draft test<span class="hljs-meta">#</span><span class="bash"> 生成markdown文件</span>hexo new post blog</code></pre></div></li><li><p>将draft草稿发布</p> <div class="hljs"><pre><code class="hljs shell">hexo publish post test</code></pre></div></li><li><p>部到 git</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装插件</span>npm install hexo-deployer-git  --save</code></pre></div></li></ol></li><li><p>插件</p><ul><li><p>live2d</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo npm install hexo-helper-live2d --save</span><span class="hljs-meta">#</span><span class="bash"> shizaku是model的名字</span><span class="hljs-meta">$</span><span class="bash"> sudo npm install live2d-widget-model-shizuku --save</span></code></pre></div><p>_config.yml加入如下配置</p>  <div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># Live2D</span><span class="hljs-comment">## https://github.com/EYHN/hexo-helper-live2d</span><span class="hljs-attr">live2d:</span><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">jsdelivr</span> <span class="hljs-comment"># 默认</span><span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span> <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span> <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span> <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><span class="hljs-comment"># scriptFrom: jsdelivr # jsdelivr CDN</span><span class="hljs-comment"># scriptFrom: unpkg # unpkg CDN</span><span class="hljs-comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span><span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><span class="hljs-attr">model:</span><span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-shizuku</span> <span class="hljs-comment"># npm-module package name</span>    <span class="hljs-attr">scale:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">hHeadPos:</span> <span class="hljs-number">0.5</span>    <span class="hljs-attr">vHeadPos:</span> <span class="hljs-number">0.618</span><span class="hljs-attr">display:</span>    <span class="hljs-attr">superSample:</span> <span class="hljs-number">2</span>    <span class="hljs-attr">width:</span> <span class="hljs-number">125</span>    <span class="hljs-attr">height:</span> <span class="hljs-number">125</span>    <span class="hljs-attr">position:</span> <span class="hljs-string">left</span>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">30</span>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-20</span><span class="hljs-attr">mobile:</span>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">scale:</span> <span class="hljs-number">0.05</span><span class="hljs-attr">react:</span>    <span class="hljs-attr">opacityDefault:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">opacityOnHover:</span> <span class="hljs-number">0.2</span></code></pre></div><p>想要其他的model可以去<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">官方博客找</a></p></li><li><p>Browsersync 实时预览编辑</p>  <div class="hljs"><pre><code class="hljs shell">npm install hexo-browsersync --save</code></pre></div></li><li><p>hexo-deployer-shell 同步服务器</p>  <div class="hljs"><pre><code class="hljs shell">npm install hexo-deployer-shell --save</code></pre></div><p>修改 root 的 _config.yml</p>  <div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">shell</span>  <span class="hljs-attr">command:</span> <span class="hljs-string">&lt;your</span> <span class="hljs-string">deploy</span> <span class="hljs-string">command&gt;</span>  <span class="hljs-attr">options:</span>  <span class="hljs-attr">timeout:</span> <span class="hljs-number">2000</span></code></pre></div></li><li><p><a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">置顶</a></p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm uninstall hexo-generator-index --save</span><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-index-pin-top --save</span></code></pre></div><p>如果要置顶,就在文章首的 font-matter 里面添加:<br>top: True</p></li><li><p>markdown 脚注</p><p><a href="https://github.com/hexojs/hexo-renderer-markdown-it" target="_blank" rel="noopener">换新的引擎</a></p>  <div class="hljs"><pre><code class="hljs shell">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save</code></pre></div><p>可选的配置</p>  <div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">markdown:</span>    <span class="hljs-attr">render:</span>        <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span>        <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">linkify:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">typographer:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">quotes:</span> <span class="hljs-string">'“”‘’'</span>    <span class="hljs-attr">plugins:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-ins</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span>    <span class="hljs-attr">anchors:</span>    <span class="hljs-attr">level:</span> <span class="hljs-number">2</span>    <span class="hljs-attr">collisionSuffix:</span> <span class="hljs-string">'v'</span>    <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">permalinkClass:</span> <span class="hljs-string">'header-anchor'</span>    <span class="hljs-attr">permalinkSide:</span> <span class="hljs-string">'left'</span>    <span class="hljs-attr">permalinkSymbol:</span> <span class="hljs-string">'⚡'</span>    <span class="hljs-attr">case:</span> <span class="hljs-number">0</span>    <span class="hljs-attr">separator:</span> <span class="hljs-string">''</span></code></pre></div><p>换了引擎还要 clean 一下</p><p><a href="https://zhanghuimeng.github.io/post/add-footnote-plugin-for-hexo-blog/" target="_blank" rel="noopener">参考博客</a></p></li><li><p><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">RSS</a></p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-feed --save</span></code></pre></div><p>对于 fluid 主题,我们可以在关于页里面修改 icons 支持 rss,link 就写 <code>/atom.xml</code></p></li><li><p><a href="https://github.com/HCLonely/hexo-online-server" target="_blank" rel="noopener">hexo-online-server</a></p><p>在线编辑</p><p>坑(2020.4.17版本):</p><ol><li><p>展示的配置注释要删</p></li><li><p>配置里面的 secret 要随便输一些东西,否则会报错:</p><p>Error: secret option required for sessions</p></li></ol></li></ul></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用指令</title>
    <link href="/2019/7/11/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2019/7/11/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ol><li><p>从本地上传文件到服务器</p> <a id="more"></a> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> scp -r /home/yysir/dist java@218.199.68.208:/tmp</span></code></pre></div><p>即可将本地dist文件夹上传到服务器的tmp文件夹下，</p><p>然后即可连接服务器将文件移动到相应文件夹中【因为目标文件夹可能没有写入权限，所以先放入具有全部权限的tmp文件夹下，再进行移动】</p></li><li><p>从服务器下载文件到另一服务器或者本机</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">注意：这是在服务器端，要求必须要有公网ip才能传到对应电脑，否则，只能先退出服务器，在本机然后再从服务器上下载文件。</span><span class="hljs-meta">$</span><span class="bash"> scp java@218.199.68.208:/tmp/test.txt yysir@ip:/home/yysir/Download</span></code></pre></div></li><li><p>查看服务器图片</p><p>python3:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python -m http.server 8080</span></code></pre></div><p>python2:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python -m simpleHTTPServer 8080</span></code></pre></div><p>如果服务器8080端口防火墙打开了的话，在浏览器输入服务器的ip地址和端口，即可在本地查看服务器的图片。</p> <!-- more --></li><li><p>rar解压</p><p>linux没有直接解压rar的功能，先去<a href="https://www.rarlab.com/download.htm" target="_blank" rel="noopener">rarlab下载</a></p><p>解压到/opt目录下，进入rar文件夹，<code>sudo make</code>即可</p><p>语法：</p><p>unrar x [fileName] 解压</p><p>rar a [rarName.rar] fileName</p></li><li><p>ubuntu下开启防火墙端口</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo su</span><span class="hljs-meta">#</span><span class="bash">开启8080端口</span><span class="hljs-meta">$</span><span class="bash"> iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /etc/network/</span><span class="hljs-meta">#</span><span class="bash">目录下如果没有iptables.up.rules</span>iptables-save &gt;/etc/network/iptables.up.rules<span class="hljs-meta">$</span><span class="bash"> vim iptables.up.rules</span><span class="hljs-meta">#</span><span class="bash">把新加入的8080端口新加入的那一行移动到合适位置【其实直接将第一行命令加到这里相应位置就可以】</span><span class="hljs-meta">#</span><span class="bash"> accept一定要放到reject的前面!!</span><span class="hljs-meta">$</span><span class="bash"> iptables-apply</span><span class="hljs-meta">#</span><span class="bash">检查程序是否运行中，端口是否开启</span><span class="hljs-meta">#</span><span class="bash">特别的，在沸点的项目需要向学校申请开放端口</span></code></pre></div></li><li><p>命令行下查看wifi</p> <div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有wifi</span>$ nmcli device wifi list<span class="hljs-comment"># 连接wifi</span>$ nmcli device wifi connect <span class="hljs-string">'SSID'</span> password <span class="hljs-string">'password'</span><span class="hljs-comment"># 显示一个所有连接过网络的UUID列表</span>$ nmcli connection show<span class="hljs-comment"># 查看所有的网络设备和状态</span>$ nmcli device</code></pre></div></li><li><p>查看端口</p><ol><li><p>查看端口是否被占用：【注意<strong>root权限</strong>】</p><ul><li>netstat -anp |grep 8080</li><li>lsof -i:8080</li></ul></li><li><p>查看端口是否在防火墙放行</p><ul><li><p>netstat -ntpl【tcp类型端口】</p></li><li><p>netstat -nupl【udp类型端口】</p></li><li><p>/sbin/iptables -L -n</p></li><li><p>telnet ip【ip地址】 port【端口】</p></li><li><p>可以连接则显示</p>  <div class="hljs"><pre><code class="hljs bash">Trying ip ...Connected to ip...Escape character is <span class="hljs-string">'^]'</span>.</code></pre></div><p>输入’]'后，进入telnet,键入quit退出</p></li><li><p>不能连接则显示</p>  <div class="hljs"><pre><code class="hljs bash">Trying ip...telnet: connect to address ip: No route to host</code></pre></div></li></ul></li></ol></li><li><p>内网穿透</p><p>我如果连接外网时连接内网的主机,输入192.168.1.110这样的内网ip肯定是无法连接的,这样就需要内网穿透</p><ol><li><p>方案一:</p><p>用有公网ip的服务器,搭建ngrok进行内网穿透,这个就需要买服务器,然后自己搭ngrok了。我现在暂时还用不到服务器,就没有采取这个方案。</p></li><li><p>方案二:</p><p>用ngrok现成的，<a href="https://dashboard.ngrok.com/get-started" target="_blank" rel="noopener">官网</a> 注册一个帐号，下载zip文件，解压到opt</p> <div class="hljs"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /opt<span class="hljs-comment"># 安装screen使ngrok可以在后台运行</span>$ sudo pacman -S screen<span class="hljs-comment"># 启动screen,-S 后面的ngrok就是一个名字而已</span>$ screen -S ngrok<span class="hljs-comment"># 开启ssh默认的22端口</span>./ngrok tcp 22<span class="hljs-comment"># 记下端口和host</span><span class="hljs-comment"># 看到启动成功后，按下 ctl+A+D，使ngrok在后台运行</span><span class="hljs-comment"># 连接外网测试ssh</span>$ ssh -p prot yysir@0.tcp.ngrok.io</code></pre></div><hr><p>更新：</p><p>我必须在本机的命令行开一个命令行界面才能连上，否则有迷之网络连接失败</p></li></ol></li><li><p>在服务器上后台运行程序</p><blockquote><p>前些时候（大概四到五月份）做帐号中心的项目，才开始真正熟悉Linux的各种操作和Spring Boot的学习。具体踩过的坑一时半会都说不完。不过今天又发现了一些新的问题值得记录一下⬇</p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 之前仅仅是用 &gt;file 来重定向输出文件，还有 &amp; 来保持程序后台运行，具体命令如下：</span><span class="hljs-meta">$</span><span class="bash"> java -jar demo-SNAPSHOT.jar &gt;accountcenter.out &amp;</span></code></pre></div><p>可是最近发现每过一段时间(大概一个月左右)，程序就会自动停止，然后我就又不得不重新连服务器，把后台提起来。</p><p>今天上网查了查，找到一个可能的疏漏：要用nohup来保持程序后台运行<br>（具体不确定，站坑，等过一个月再来答）</p><p>(过了好久，终于填坑，果然是需要nohup)</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nohup java -jar demo-SNAPSHOT.jar &gt;accountcenter.out &amp;</span></code></pre></div></li><li><p>nginx</p><ol><li><p>安装：</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S nginx</span></code></pre></div></li><li><p>开启服务&amp;测试</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl status nginx</span><span class="hljs-meta">$</span><span class="bash"> sudo systemctl start nginx</span><span class="hljs-meta">$</span><span class="bash"> sudo nginx -t</span></code></pre></div><p>如果测试出现如下错误：</p><blockquote><p>nginx: [warn] could not build optimal types_hash, you should increase either types_hash_max_size: 2048 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size</p></blockquote><p>解决方案：</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/nginx/nginx.conf</span></code></pre></div><p>在http模块下，server子模块前，添加如下配置:</p><blockquote><p>types_hash_max_size 2048;<br>server_names_hash_max_size 2068;<br>types_hash_bucket_size 1024;</p></blockquote> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重启</span><span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart ngxin</span><span class="hljs-meta">#</span><span class="bash">测试</span><span class="hljs-meta">$</span><span class="bash"> sudo nginx -t</span><span class="hljs-meta">#</span><span class="bash">出现以下提示即可：</span><span class="hljs-meta">#</span><span class="bash">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><span class="hljs-meta">#</span><span class="bash">nginx: configuration file /etc/nginx/nginx.conf <span class="hljs-built_in">test</span> is successful</span></code></pre></div><p><a href="http://127.0.0.1" target="_blank" rel="noopener">本地nginx主页</a></p></li><li><p>配置反向代理</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/nginx/nginx.conf</span></code></pre></div><p>&lt;一、通过域名访问&gt;<br>添加如下配置</p> <div class="hljs"><pre><code class="hljs xml">server &#123;    listen 80;    server_name yinchao;    root /opt/BlogFile/.deploy_git    location /&#123;        index index.html;        try_files $uri $uri/ /index.html;    &#125;&#125;</code></pre></div><p>&lt;二、通过端口访问&gt;</p> <div class="hljs"><pre><code class="hljs xml">server &#123;    listen 8888;    server_name localhost;    root ~;    location / &#123;        index ~;        try_files $uri $uri/ ~;    &#125;&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs shell">sudo systemctl restart nginx</code></pre></div><p>即可通过http://yinchao/ 或localhost:8888访问。</p></li></ol><ul><li><p>前端部署的坑：</p><ul><li><p>如果是vue等可以用</p>   <div class="hljs"><pre><code class="hljs shell">npm run build</code></pre></div><p>命令打包为dis文件的，直接就可以了</p></li><li><p>如果是原生的html+css+javascript</p><p>就要把文件归类，html平行的就是css和js</p><p>而且nginx的配置文件要配置好</p><blockquote><p>从昨天22：30到夜里1点多，再从今天早上9：20到下午1点，终于把这个原生页面部署上去了😩</p></blockquote></li></ul></li></ul></li><li><p>查看文件编码</p><div class="hljs"><pre><code class="hljs shell">file fileName<span class="hljs-meta">#</span><span class="bash"> 还可以错略通过换行符判断Windows/Unix系统</span></code></pre></div></li><li><p>数据库备份和还原</p><p>备份：</p><div class="hljs"><pre><code class="hljs shell">mysqldump -uroot -proot databaseName &gt; databasesName.sql;</code></pre></div><p>还原的前提：必须先建立database，然后才能在其中添加数据,否则会报错</p><div class="hljs"><pre><code class="hljs shell">mysql -uroot -proot databaseName &lt; databaseName.sql;</code></pre></div></li><li><p>网络相关</p><ol><li><p>www和不加www域名的区别：</p><p>前者是后者的子域名</p><p>后者被称为裸域名,好处是简短容易记忆，常见于个人博客等。坏处是不能把裸域设定为另外域名的别名等<a href="https://www.zhihu.com/question/20414602" target="_blank" rel="noopener">详情见知乎</a>。</p></li></ol></li><li><p>ls命令</p><ul><li><p>按文件大小进行排序</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls -hlSa</span></code></pre></div><p>-a: --all</p><p><code>-h</code>:–human-readable，显示人类可读的文件大小</p><p><code>-S</code>:以文件大小降序方式排序</p><p><strong><code>-r</code></strong>:–reverse，反向排序</p></li><li><p>按文件时间顺序排序</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls -hlta</span></code></pre></div><p><code>-t</code>: sort by modification time,newest first，即按修改时间对文件进行<strong>降序</strong>排序</p></li></ul></li><li><p>命令记录</p><ul><li><p><code>ldd</code> [path]: 查看依赖库</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ldd /usr/bin/mysqld</span></code></pre></div><p>注意要写<strong>完整路径</strong>,如果写成<br>$ ldd mysql<br>会提示mysql NOT FOUND</p></li><li><p><code>LD_DEBUG=libs</code> [path]:</p><blockquote><p>LD_DEBUG 是 glibc 中的 loader 为了方便自身调试而设置的一个环境变量。<br>通过设置这个环境变量，可以方便的看到 loader 的加载过程,使用ldd命令可以知道程序依赖于哪些库。<br>在找不到这些库的时候，使用LD_DEBUG可以知道系统在哪些路径下进行了尝试</p></blockquote></li></ul></li><li><p>gitlab</p><p>昨天（2019.8.18）程时坤重启了 gitlab 500的错误，但是没办法用ssh克隆导致我晚上调了很久，最后发现是url不对!!!</p><p>应该是 <a href="http://xn--rcaaa.edu.cn" target="_blank" rel="noopener">×××.edu.cn</a>，结果现在的url为 <a href="http://xn--rcaaa.edu.cn.com" target="_blank" rel="noopener">×××.edu.cn.com</a>，然后用ssh克隆就一直提示需要使用密码。</p><p>解决办法：</p><div class="hljs"><pre><code class="hljs ssh"># 登上服务器,获取超级用户权限$ ssh feidian$ sudo su# 进入gitlab配置目录,进行相应配置$ cd &#x2F;etc&#x2F;gitlab$ vim gitlab.rb# 发现external_url是&#39;http:&#x2F;&#x2F;git.feidian.hzau.edu.cn.com&#39;# 修改,把最后的.com去掉即可# 更坑的来了,之前在网上找到的命令是 gitlab-ctl reconfigure,执行之发现刚刚修改的gitlab.rb的数据被重置了!!!# 尝试多次发现show-config才是正确的$ gitlab-ctl show-config# 成功</code></pre></div></li><li><p>banner</p><ul><li><p>生成banner</p></li><li><p>登录前banner:</p></li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/issue</span></code></pre></div><div class="hljs"><pre><code class="hljs properties"><span class="hljs-attr">Manjaro</span> <span class="hljs-string">Linux \r  </span><span class="hljs-attr">server</span> <span class="hljs-string">name: (\n) </span><span class="hljs-attr">user</span>: <span class="hljs-string">(\l)</span><span class="hljs-attr">version</span>: <span class="hljs-string">(\v)</span><span class="hljs-attr">OS</span> <span class="hljs-string">Name:(\s)</span><span class="hljs-attr">time</span>: <span class="hljs-string">(\t)</span><span class="hljs-attr">hard</span> <span class="hljs-string">ware level: (\m)</span></code></pre></div><ul><li>登录后banner</li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/motd</span></code></pre></div><div class="hljs"><pre><code class="hljs properties">  <span class="hljs-attr">___</span>    <span class="hljs-string">___  ___      ________           ________      ___  ___      ________      ________     </span> <span class="hljs-meta">|\ </span> <span class="hljs-string">\  /  /||\  \    |\   ___  \        |\   ____\    |\  \|\  \    |\   __  \    |\   __  \    </span> <span class="hljs-attr">\ \ </span> <span class="hljs-string">\/  / /\ \  \   \ \  \\ \  \       \ \  \___|    \ \  \\\  \   \ \  \|\  \   \ \  \|\  \   </span>  <span class="hljs-attr">\ \ </span>   <span class="hljs-string">/ /  \ \  \   \ \  \\ \  \       \ \  \        \ \   __  \   \ \   __  \   \ \  \\\  \  </span>   <span class="hljs-attr">\/</span>  <span class="hljs-string">/  /    \ \  \   \ \  \\ \  \       \ \  \____    \ \  \ \  \   \ \  \ \  \   \ \  \\\  \ </span> <span class="hljs-meta">__/</span>  <span class="hljs-string">/ /       \ \__\   \ \__\\ \__\       \ \_______\   \ \__\ \__\   \ \__\ \__\   \ \_______\</span><span class="hljs-meta">|\___/</span> <span class="hljs-string">/         \|__|    \|__| \|__|        \|_______|    \|__|\|__|    \|__|\|__|    \|_______|</span><span class="hljs-attr">\|___|/</span></code></pre></div></li><li><p>根据端口号直接杀死进程</p><div class="hljs"><pre><code class="hljs shell">fuser -k -n tcp 8099</code></pre></div></li><li><p>获取日志中一定范围的</p> <div class="hljs"><pre><code class="hljs java">cat 日志 | grep -E <span class="hljs-string">'2018:2[0-2]:[0-9][0-9]:[0-9][0-9]'</span></code></pre></div></li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>shellCommand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro安装手记</title>
    <link href="/2019/7/11/Manjaro%E5%AE%89%E8%A3%85%E6%89%8B%E8%AE%B0/"/>
    <url>/2019/7/11/Manjaro%E5%AE%89%E8%A3%85%E6%89%8B%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="安装-设置"><a class="header-anchor" href="#安装-设置">⚡</a>安装&amp;设置</h2></li></ul><ol><li><p>安装manjaro</p> <a id="more"></a><ol><li><p>在官网下载<strong>gnome</strong>版本.iso文件</p></li><li><p>用rufus刻录</p><p><strong>注意</strong>:在开始刻录是选择刻录方式为<strong>DD模式!</strong>,而不是一般的iso!</p></li><li><p>进入安装,在grub界面将</p><p><code>语言</code>为中文</p><p><code>Driver</code>设置<strong>no-free</strong></p><p>在<code>boot</code>那一行按<code>e</code> 确认nouveau.modeset=0来禁用开源nouveau驱动</p><p>如果进不去桌面,还要在quit 后面 加上</p> <div class="hljs"><pre><code class="hljs shell">acpi_osi=! acpi_osi='Windows 2009'</code></pre></div><p>否则无法驱动独立显卡</p></li><li><p>等待安装</p></li><li><p>安装完成,重启进入manjaro时注意也要在grub界面修改acpi</p></li><li><p>进入桌面</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">排列并选择软件源</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman-mirrors -i -c China -m rank</span><span class="hljs-meta">#</span><span class="bash">排列源</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman-mirrors -g</span><span class="hljs-meta">#</span><span class="bash"> 安装archlinuxcn-keyring</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S archlinuxcn-keyring</span><span class="hljs-meta">#</span><span class="bash">更新系统</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -Syu</span><span class="hljs-meta">#</span><span class="bash">安装vim</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S vim</span><span class="hljs-meta">#</span><span class="bash">修改grub</span><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/default/grub</span><span class="hljs-meta">#</span><span class="bash">修改为</span>GRUB_CMDLINE_LINUX_DEFAULT="quiet nouveau.modeset=0 systemd.show_status=1 acpi_osi=! acpi_osi='Windows 2009'"<span class="hljs-meta">#</span><span class="bash">查看驱动</span><span class="hljs-meta">$</span><span class="bash"> glxgears</span><span class="hljs-meta">$</span><span class="bash"> mhwd</span><span class="hljs-meta">$</span><span class="bash"> sudo optirun nvidia-settings -c :8</span></code></pre></div></li><li><p>grub rescure</p><p>这次可能是分区位置或者顺序或者方案不对,导致删掉之前预留的20G硬盘里存了manjaro的引导,在windows删除这个预留空间再进入linux显示没找到引导,以下是修复过程</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ls查看设备和磁盘分区</span><span class="hljs-meta">$</span><span class="bash"> ls</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span>查看路径和分区</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">set</span></span><span class="hljs-meta">#</span><span class="bash"> 接下来就是一个个用ls (hdx,gptx)试验,找到Manjaro的引导,这次运气很好,虽然都显示是unknown filesystem,而没有显示住文件夹,但是我没有放弃.我就先试着把root定在了hd2的gpt5下,结果一次就成功了</span><span class="hljs-meta">#</span><span class="bash"> root 指定启动系统分区</span><span class="hljs-meta">$</span><span class="bash"> root=(hd2,gpt5)</span><span class="hljs-meta">#</span><span class="bash"> prefix 设置grub启动路路径</span><span class="hljs-meta">$</span><span class="bash"> prefix=(hd2,gpt5)/boot/grub</span><span class="hljs-meta">#</span><span class="bash"> insmod加载制定模块</span><span class="hljs-meta">$</span><span class="bash"> insmoe normal</span><span class="hljs-meta">$</span><span class="bash"> normal</span><span class="hljs-meta">#</span><span class="bash"> 自动重启,之后就可以看到之前的grub界面了</span><span class="hljs-meta">#</span><span class="bash"> 当然,不能每次都这样吧,进入正常图形界面后,输入一下命令</span><span class="hljs-meta">$</span><span class="bash"> sudo update-grub</span><span class="hljs-meta">#</span><span class="bash"> 当然,这个nvme0n1p5应该是对应上面的gpt5,但是我也不知道到底对不对,好在这次运气真的好,猜的没错,重启之后就没有grub rescure了</span><span class="hljs-meta">$</span><span class="bash"> grub-install /dev/nvme0n1p5</span></code></pre></div></li></ol></li><li><p>解决连接有限网络连接失败问题<code>「玄学」</code></p><ol><li><p>安装以使用ifconfig</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 首先查看网线接口名称,若没有网线插口应该是网卡驱动问题</span><span class="hljs-meta">$</span><span class="bash"> ifconfig</span><span class="hljs-meta">#</span><span class="bash"> 连接网络失败可能是获取不到ip</span><span class="hljs-meta">$</span><span class="bash"> sudo dhclinet enp2s0f1</span></code></pre></div><p>不知道发生了什么就解决了? !</p></li><li><p>快捷键设置</p><ol><li><p>进入设置-&gt;设备-&gt;keyboard,最后添加快捷键</p></li><li><p>名称 terminal ,命令 gnome-terminal ,快捷键<code>Ctrl</code>+<code>Alt</code>+<code>T</code></p><p>名称文件管理器,命令nautilus,快捷键<code>win</code>+<code>e</code></p><p>找到隐藏所有选项,设置快捷键<code>win</code>+<code>D</code></p></li></ol></li><li><p>美化</p><ol><li><p><a href="https://www.gnome-look.org/p/1276072/" target="_blank" rel="noopener">grub主题1:Cyber Security theme</a></p><p>注意Manjaro的grub文件<strong>注释和配置写在一起</strong>,不要以为下面的都是注释!</p></li><li><p>将解压后的文件移动到/boot/grub/themes</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改grub文件</span><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/default/grub</span><span class="hljs-meta">#</span><span class="bash">这一行改为grub界面15秒的选择时间</span><span class="hljs-meta">$</span><span class="bash"> GRUB_TIMEOUT=15</span><span class="hljs-meta">#</span><span class="bash">主题文件路径</span><span class="hljs-meta">$</span><span class="bash"> GRUB_THEME=<span class="hljs-string">"/boot/grub/themes/Cyber-Security/theme.txt"</span></span>        <span class="hljs-meta">#</span><span class="bash">这个分辨率修改为1280x1024是因为作者说明这是最好的分辨率</span><span class="hljs-meta">$</span><span class="bash"> GRUB_GFXMODE=1280x1024</span>        <span class="hljs-meta">#</span><span class="bash">注释掉这一行，否则不会有图形界面</span><span class="hljs-meta">#</span><span class="bash">GRUB_TERMINAL_OUTPUT=<span class="hljs-string">"console"</span></span><span class="hljs-meta">#</span><span class="bash"> 更新grub</span><span class="hljs-meta">$</span><span class="bash"> grub-mkconfig -o /boot/grub/grub.cfg</span><span class="hljs-meta">#</span><span class="bash"> 或者</span><span class="hljs-meta">$</span><span class="bash"> sudo update-grub</span><span class="hljs-meta">#</span><span class="bash">注意如果是是grub2引导，用这个命令</span>grub2-mkconfig -o /boot/efi/EFI/Manjaro/grub.cfg<span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div><p><a href="https://www.opendesktop.org/p/1228974/" target="_blank" rel="noopener">grub主题2链接</a></p><p><a href="https://www.gnome-look.org/p/1220920/" target="_blank" rel="noopener">grub主题3链接</a></p></li><li><p><a href="https://www.gnome-look.org/p/1275087/" target="_blank" rel="noopener">shell: McMojave theme</a></p><p>下载解压到/usr/share/themes即可</p></li><li><p><a href="https://www.gnome-look.org/p/" target="_blank" rel="noopener">鼠标主题 Mac cursor theme</a></p><p>下载解压到/usr/share/icons</p></li><li><p><a href="https://www.gnome-look.org/s/Gnome/p/1305429" target="_blank" rel="noopener">Majave 图标主题</a></p></li></ol></li><li><p>修改中文文件夹名</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span>=en_US</span><span class="hljs-meta">$</span><span class="bash"> xdg-user-dirs-gtk-update</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> LANG=zh_CN.UTF-8</span><span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div></li><li><p>解决没声音问题</p><p><a href="https://blog.csdn.net/juncoder/article/details/39269595" target="_blank" rel="noopener">CSDN</a></p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试是否静音,以及声卡驱动,如果没有异常输出,则证明驱动没有问题</span><span class="hljs-meta">$</span><span class="bash"> amixer sset Master unmute</span><span class="hljs-meta">#</span><span class="bash"> 调整试一下</span><span class="hljs-meta">$</span><span class="bash"> alsamixer</span><span class="hljs-meta">#</span><span class="bash"> 测试有没有声音,能听到分别左右的两个声道的声音就是正常的</span><span class="hljs-meta">$</span><span class="bash"> speaker-test 1.1.3</span><span class="hljs-meta">#</span><span class="bash"> 查看设备,正常输出则驱动正常</span><span class="hljs-meta">$</span><span class="bash"> aplay -l</span><span class="hljs-meta">$</span><span class="bash"> amixer scontrols</span><span class="hljs-meta">#</span><span class="bash"> 如果上面输出没有<span class="hljs-string">"master"</span>,则没有配置</span><span class="hljs-meta">$</span><span class="bash"> amixer -c 0 scontrols</span><span class="hljs-meta">#</span><span class="bash"> 出现<span class="hljs-string">"Master"</span>则正确</span><span class="hljs-meta">$</span><span class="bash"> vim .asoundrc</span>pcm.!default &#123;    type hw    card 0&#125;ctl.!default &#123;    type hw    card 0&#125;<span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div></li><li><p>加入sysrq</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /etc/sysctl.d/</span><span class="hljs-meta">$</span><span class="bash"> sudo vim 99-sysctl.conf</span><span class="hljs-meta">#</span><span class="bash"> 加入内容为:</span><span class="hljs-meta">$</span><span class="bash"> kernel.sysrq = 1</span><span class="hljs-meta">#</span><span class="bash"> 保存重启后,即可用<span class="hljs-string">"busier"</span>命令强制重启</span></code></pre></div></li><li><p>配置默认编辑器</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 用ranger发现默认文本编辑器是nano,想修改为vim</span><span class="hljs-meta">$</span><span class="bash"> vim ~/.zshrc</span>export EDITOR=vim<span class="hljs-meta">#</span><span class="bash"> 重启即可</span></code></pre></div></li><li><p>解决windows双系统时间不一致问题</p><p>(占坑,具体不记得了,只记得点击设置一下就好)</p></li></ol></li></ol><ul><li><h2 id="软件"><a class="header-anchor" href="#软件">⚡</a>软件</h2></li></ul><ol><li><p>输入法:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">安装谷歌拼音</span>sudo pacman -S fcitx-im fcitx-configtool fcitx-googlepinyin<span class="hljs-meta">#</span><span class="bash">创建.xprofile文件</span>vim ~/.xprofile<span class="hljs-meta">#</span><span class="bash">复制加入以下内容</span>export LC_ALL=zh_CN.UTF-8export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx"<span class="hljs-meta">#</span><span class="bash"> 添加emoji表情</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ~/.config/fxitx/data</span><span class="hljs-meta">$</span><span class="bash"> curl -<span class="hljs-comment">#C - -O https://raw.githubusercontent.com/levinit/fcitx-emoji/master/QuickPhrase.mb &amp;&amp; cat ./QuickPhrase.mb &gt;&gt; ~/.config/fcitx/data/QuickPhrase.mb &amp;&amp; rm ./QuickPhrase.mb</span></span><span class="hljs-meta">#</span><span class="bash"> 添加颜文字</span><span class="hljs-meta">$</span><span class="bash"> wget https://raw.githubusercontent.com/rainlime/fcitx-quick-phrase-emoji/master/QuickPhrase.mb &amp;&amp; cat ./QuickPhrase.mb &gt;&gt; ~/.config/fcitx/data/QuickPhrase.mb &amp;&amp; rm ./QuickPhrase.mb</span><span class="hljs-meta">#</span><span class="bash"> 将下载的QuickPhrase.mb.1文件中的数据复制到QuickPhrase.mb，重启即可</span></code></pre></div><p><a href="https://blog.felixc.at/2012/05/kitty-for-fcitx-quickphrase/" target="_blank" rel="noopener">颜文字对照表</a></p></li><li><p>常用软件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S vim zsh ranger htop cmatrix yay oneko etronic-wechat typora netease-cloud-music tmux aria2 oneDriveLinux tree go rust ruby</span><span class="hljs-meta">#</span><span class="bash"> 图片查看器</span>nomacs</code></pre></div></li><li><p>解决.vimrc E488:多余的换行符问题:</p><p>不要用<code>#</code>写注释,而要用<code>&quot;</code></p></li><li><p>thefuck</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 没有pip先安装pip</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S python-pip</span><span class="hljs-meta">#</span><span class="bash"> 安装thefuck</span><span class="hljs-meta">$</span><span class="bash"> sudo pip install thefuck</span><span class="hljs-meta">#</span><span class="bash"> 配置</span><span class="hljs-meta">$</span><span class="bash"> fuck</span><span class="hljs-meta">#</span><span class="bash"> root用户安装</span><span class="hljs-meta">$</span><span class="bash"> sudo su</span><span class="hljs-meta">$</span><span class="bash"> pip insall thefuck</span><span class="hljs-meta">$</span><span class="bash"> fuck</span></code></pre></div></li><li><p>java</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看openjdk版本</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -Q |grep jdk</span><span class="hljs-meta">#</span><span class="bash"> 卸载openjdk</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -R jre*</span><span class="hljs-meta">#</span><span class="bash"> 查看是否删除</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -Q |grep jdk</span><span class="hljs-meta">$</span><span class="bash"> java -version</span><span class="hljs-meta">#</span><span class="bash"> 安装:去官网下载jdk8,解压到/opt</span><span class="hljs-meta">$</span><span class="bash"> sudo ln -s /opt/jdk-8u212-linux-x64/jdk1.8.0_212/bin/java /usr/bin/java</span><span class="hljs-meta">#</span><span class="bash"> 如果创建符号链接失败,则是之前的openjdk的影响,删除/usr/bin/java即可</span><span class="hljs-meta">$</span><span class="bash"> java -version</span></code></pre></div></li><li><p>软件安装</p><p>直接在软件搜索deepin.com.qq.office, idea, mysql安装</p></li><li><p>electron-ssr</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 从githb上下载pacman安装包到/opt下</span><span class="hljs-meta">#</span><span class="bash"> pacman本地安装</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -U electron-ssr-0.2.6.pacman</span></code></pre></div></li><li><p>codeblocks配置:</p><ol><li><p>下载完之后，cd ~/.config/codeblocks/ ，在官网复制主题代码，修改default.conf文件，保存。</p></li><li><p>进入/usr/include/bits文件夹下，sudo vim stdc++，将代码复制，保存。</p></li><li><p>在settings-&gt;environment-&gt;Gerneral settings-&gt;Terminal to launch console programs:-&gt;下拉单选择gnome-terminal -t $TITLE -x，变更控制台。</p></li><li><p>进行start和splash页面，utf-8，字体[monospace bold]等设置……</p></li></ol></li><li><p>mysql</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在软件直接搜mysql,安装</span><span class="hljs-meta">#</span><span class="bash"> 初始化</span><span class="hljs-meta">$</span><span class="bash"> sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><span class="hljs-meta">#</span><span class="bash">上面初始化失败,提示libicu63没找到:</span><span class="hljs-meta">$</span><span class="bash"> mysqld: error <span class="hljs-keyword">while</span> loading shared libraries: libicuuc.so.63: cannot open shared object file: No such file or directory</span><span class="hljs-meta">#</span><span class="bash"> 进入/usr/lib/icu,发现只有64版本</span><span class="hljs-meta">#</span><span class="bash"> 安装icu63</span><span class="hljs-meta">$</span><span class="bash"> yay -S icu63</span><span class="hljs-meta">#</span><span class="bash"> 等待缓慢的下载和安装</span><span class="hljs-meta">#</span><span class="bash"> 完成后再看/usr/lib/icu,发现已经有icu63了</span><span class="hljs-meta">#</span><span class="bash"> 再次初始化</span><span class="hljs-meta">$</span><span class="bash"> sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><span class="hljs-meta">#</span><span class="bash"> 记住临时密码登录,或者修改配置文件免密登录,后者修改/etc/mysql/my.cnf,在最后一行加上</span>skip-grant-tables<span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart mysqld</span><span class="hljs-meta">#</span><span class="bash"> 如果又出现初始化失败的问题,重装即可</span><span class="hljs-meta">$</span><span class="bash"> mysql -u root -p</span><span class="hljs-meta">#</span><span class="bash"> 不用密码[回车]即可</span></code></pre></div> <div class="hljs"><pre><code class="hljs mysql">use mysql;flush privileges ;alter user&#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;</code></pre></div><p><code>ctrl</code>+<code>d</code>退出mysql</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 如果是免密登录,删除加入的那行</span><span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart mysqld</span><span class="hljs-meta">#</span><span class="bash"> 输入root进入mysql</span>mysql -u root -p</code></pre></div><hr><p>二更:</p><p>重新装mysql时，没有出现上面的libicu63没找到，而是libevent_core-2.1.so.6没有找到……</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查找mysqld可能缺失的依赖库</span><span class="hljs-meta">$</span><span class="bash"> ldd /usr/bin/mysqld</span><span class="hljs-meta">#</span><span class="bash"> 结果显示，libevent_core-2.1.so.6 NOT FOUND</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/lib</span><span class="hljs-meta">#</span><span class="bash"> 发现只有.7的版本，没有.6,依赖库的版本太新了</span><span class="hljs-meta">$</span><span class="bash"> cp libevent_core-2.1.so.7 libevent_core-2.1.so.6</span><span class="hljs-meta">#</span><span class="bash"> 直接复制.7为.6</span><span class="hljs-meta">#</span><span class="bash"> 接下来就和上面的一样，重新初始化，再进行下面的步骤即可。</span></code></pre></div></li><li><p>解决tim无法使用中文输入法:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /opt/deepinwine/apps/Deepin-TIM</span><span class="hljs-meta">$</span><span class="bash"> sudo vim run.sh</span><span class="hljs-meta">#</span><span class="bash"> 添加三行:</span>export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=”@im=fcitx”<span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div></li><li><p>命令行使用代理</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改 ~/.zshrc</span>vim .zshrc<span class="hljs-meta">#</span><span class="bash"> 最下面加入两行</span>export http_proxy="http://127.0.0.1:12333"export https_proxy="http://127.0.0.1:12333"</code></pre></div></li><li><p>jetbrains全软件代理</p><p>在Settings-&gt;Apperance -&gt;System Settings-&gt;HTTP Proxy</p><p>设置Manual proxy,选择HTTP,Host name:127.0.0.1,Port number:<strong>12333</strong></p><blockquote><p>注意：</p></blockquote><p>如果electron-ssr设置了局域网内代理（默认1080端口），则端口号改为1080</p><p>还有：使用idea的同步功能时，确保File-&gt;Settings-&gt;System settings-&gt;Passwords-&gt;In KeePass勾选上</p><p>否则账户同步功能会报错</p></li><li><p>安装vscode</p><p>在软件包里安装bin文件,然后</p> <div class="hljs"><pre><code class="hljs shell">yaourt -S visual-studio-code-bin</code></pre></div><p>解决安装完成后打开文件夹自动打开vscode问题:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 首先查看默认文件管理器</span><span class="hljs-meta">$</span><span class="bash"> xdg-mime query default inode/directory</span><span class="hljs-meta">#</span><span class="bash"> 不出意外的话,会输出visual-studio-code.desktop</span><span class="hljs-meta">#</span><span class="bash"> 修改默认文件管理器</span><span class="hljs-meta">$</span><span class="bash"> xdg-mime default org.gnome.Nautilus.desktop inode/directory</span><span class="hljs-meta">#</span><span class="bash"> 再执行query命令</span>xdg-mime query default inode/directory<span class="hljs-meta">#</span><span class="bash"> 显示org.gnome.Nautilus.desktop即正确</span></code></pre></div><p>解决vscode格式化失败:libtinfo.so.5:cannot open</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 先检查有没有</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/lib</span><span class="hljs-meta">#</span><span class="bash"> 不完全打出全称,看看有哪些是以libtinfo开头的</span><span class="hljs-meta">$</span><span class="bash"> vim libtinfo. [+`tab`]</span><span class="hljs-meta">#</span><span class="bash"> 此时我看到了libtinfo.so libtinfo.so.6,的确缺少libtinfo.so.5</span><span class="hljs-meta">#</span><span class="bash"> 安装之即可</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S libtinfo5</span></code></pre></div><p><strong>注意：<strong>不要打开设置中的</strong>Auto Guess Encoding</strong>!!!</p></li><li><p>配置ranger</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ranger --copy-config=all</span><span class="hljs-meta">#</span><span class="bash"> 此命令将ranger的配置生成到 ~/.config/ranger文件夹下</span><span class="hljs-meta">#</span><span class="bash"> rc.config:选项设置和快捷键</span><span class="hljs-meta">#</span><span class="bash"> rifle.conf:指定文件的默认打开程序</span><span class="hljs-meta">#</span><span class="bash"> command.py:设置通过<span class="hljs-string">":"</span>执行的命令</span><span class="hljs-meta">$</span><span class="bash"> vim rc.conf</span>set show_hidden trueset colorscheme solarizedset draw_borders bothset line_numbers true</code></pre></div><p>vscode 插件</p> <div class="hljs"><pre><code class="hljs json">daily reminder,coding tracker,leetcode,netease music,power mode</code></pre></div></li><li><p>安装redis</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S redis</span><span class="hljs-meta">#</span><span class="bash"> 安装完成后检查能否运行</span>redis-serverredis-cli<span class="hljs-meta">#</span><span class="bash"> 修改配置使其能在后台运行</span>sudo vim /etc/redis.conf<span class="hljs-meta">#</span><span class="bash"> 把daemonize no改为yes</span>deamonize yes<span class="hljs-meta">#</span><span class="bash"> 以刚刚的配置文件运行</span><span class="hljs-meta">$</span><span class="bash"> redis-server /etc/redis.conf</span><span class="hljs-meta">#</span><span class="bash"> 这次的输出应该和前次的不一样</span><span class="hljs-meta">#</span><span class="bash"> 启动</span><span class="hljs-meta">$</span><span class="bash"> redis-cli</span></code></pre></div></li><li><p>安装mycli</p> <div class="hljs"><pre><code class="hljs shell">pip install mycli</code></pre></div></li><li><p>idea生成javadoc文档</p><p>Tools-&gt;Generate JavaDoc(快捷键可以设置为<code>CTL</code>+<code>ALT</code>+<code>D</code>)</p><p>选择OutPut_directroy</p><p>选择package</p><p>Local制定 zh_CN</p><p>Other command line arguments:</p> <div class="hljs"><pre><code class="hljs shell">-encoding utf-8 -charset utf-8 -version -windowtitle "JShell" -tag Date:a:"Date"</code></pre></div><p>在生成的文件夹中点击index.html即可。</p></li><li><p>WPS 默认英文设置</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装中文语言包</span>sudo pacman -S wps-office-mui-zh-cn</code></pre></div><p>进入 WPS 文字,点击右上方的 <code>A</code> 符号,选择中文,推出软件,重进即可</p></li><li><p>截图工具 flameshot</p> <div class="hljs"><pre><code class="hljs shell">sudo pacman -S flameshot</code></pre></div><p>打开设置-&gt;键盘快捷键,设置名称,快捷键 <code>ctrl+alt+A</code>,命令是 <code>flameshot gui</code></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2019/7/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/7/11/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>算法思想:</p><ol><li>将数组中的数据建立成所有根结点大于其左右子树的<em>完全二叉树</em>，即<strong>大根堆</strong></li></ol> <a id="more"></a><ol start="2"><li>然后将第一个堆顶结点，即root结点，也是当前未排序的最大数据，和最后未排序的数据的位置交换，结果类似冒泡排序排好了一个数据，那么现在那个最后未排序的位置就是当前的最大的数据，也就排好了一个数据</li><li>但是因为交换数据，现在的root结点的数据不一定就是最大的，那么就还需要调整堆，使其满足大根堆条件。</li><li>重复上述过程，就可以得到升序序列;反之，建立小根堆可以得到降序序列。</li></ol> <!-- more --></li><li><p>代码：</p> <div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//k 是要调整的结点在数组中的下标，在createHeap中传入的值是从最后一个非叶子结点的下标依次递减到0,表现为从中点处依次向上调整堆</span><span class="hljs-comment">//但是在HeapSort循环中，根据上述算法，每次调整的都是堆顶的root结点，即第一个结点，k=0。</span><span class="hljs-comment">//n 是还要排序n个数，第n个数也要排序，所以while循环里的条件，注意判断j等于n的情况</span><span class="hljs-comment">//j 是i的左子树结点,为2*k+1的原因是数组下标从0开始，经过试验规律得到i的左子树下标为2*k+1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = k, temp;<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>;<span class="hljs-comment">//如果j的值已经大于要排序的最后一个值的下标，说明i不存在左子树，根据完全二叉树的定义，肯定没有右子树，那么这个i结点一定是满足大根堆的，无需调整。</span><span class="hljs-keyword">while</span> (j &lt;= n)&#123;<span class="hljs-comment">//如果j+1的值小于等于要排序的最后一个值的下标，那么i不仅有左子树，还有右子树，那么就要比较右子树的数据是否大于左子树，如果是的话，j++，使j的值为i的最大子树的下标。</span><span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= n &amp;&amp; <span class="hljs-built_in">array</span>[j] &lt; <span class="hljs-built_in">array</span>[j + <span class="hljs-number">1</span>])j++;<span class="hljs-comment">//如果从i向下检查时，满足这个条件，就说明从这个结点开始往下的子树一定满足大根堆条件，就可以不用再检查，可以直接结束循环了。</span><span class="hljs-comment">//[当然，原因分两种情况。第一：是在创建堆时，i是最后一个非叶子结点，其后一定的都是叶子结点，一定满足大根堆，而i以前的非叶子结点进行判断时，因为后面一定已经调整好了，也一定满足大根堆。第二：在HeapSort循环里调整的话，和上面其实一样，每次交换可能只破坏了一个局部的大根堆，当把这个局部的调整回来时，其后面的结点就和之前一样，不受影响了。]</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &gt;= <span class="hljs-built_in">array</span>[j])<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果当前根结点i的值不是其左右字数中最大的，那么就和那个最大的数交换，使其满足大根堆条件</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &lt; <span class="hljs-built_in">array</span>[j])&#123;temp = <span class="hljs-built_in">array</span>[i];<span class="hljs-built_in">array</span>[i] = <span class="hljs-built_in">array</span>[j];<span class="hljs-built_in">array</span>[j] = temp;<span class="hljs-comment">//因为交换了值，可能破坏大根堆的条件，那么就要循环向下判断大根堆条件是否满足</span><span class="hljs-comment">//这里还有技巧，只需要检查与i交换的j往下的子结点即可，不用检查那个没有发生交换的结点。</span>i = j;j = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//从当前的最后一个非叶子结点开始,从后往前[以数组的形式看]，从下到上[以二叉树的形式看]创建堆</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)adjustHeap(<span class="hljs-built_in">array</span>, i, n);   &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">   </span>&#123;<span class="hljs-keyword">int</span> temp;createHeap(<span class="hljs-built_in">array</span>, n);<span class="hljs-comment">//创建好大根堆后，先把最大的数据(n-1)换到最后面，再将被破坏的大根堆调整，使其满足大根堆条件。</span><span class="hljs-comment">//再重复上述步骤</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123;temp = <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = <span class="hljs-built_in">array</span>[i];<span class="hljs-built_in">array</span>[i] = temp;adjustHeap(<span class="hljs-built_in">array</span>, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);&#125;&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
