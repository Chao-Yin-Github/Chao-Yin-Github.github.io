<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL 知识 -- 并发控制</title>
    <link href="/2020/12/23/MySQL-%E7%9F%A5%E8%AF%86-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/12/23/MySQL-%E7%9F%A5%E8%AF%86-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="并发控制"><a class="header-anchor" href="#并发控制">⚡</a>并发控制</h2><ul><li><p>悲观并发控制</p></li><li><p>乐观并发控制</p></li><li><p>MVCC (Multi-Version Concurrency Control)</p><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><p>MVCC 使得每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回</p><p>MVCC(Multi-version concurrency control) 就是 同一份数据临时保留多版本的一种方式，进而实现并发控制</p><p>在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。</p><p>快照读会出现幻读的情况,而使用 MVCC + next_key_lock 可以解决 RR 下的幻读问题</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识 -- 数据库事务特性</title>
    <link href="/2020/12/23/MySQL-%E7%9F%A5%E8%AF%86-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7/"/>
    <url>/2020/12/23/MySQL-%E7%9F%A5%E8%AF%86-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="事务的特性"><a class="header-anchor" href="#事务的特性">⚡</a>事务的特性</h2><ol><li><p>A(Atomic) 原子性</p><p>事务开始后所有操作,要么全部做完,要么全部不做,不可能停滞在中间环节</p><p>事务执行过程中出错,会回滚到事务开始前的状态,所有的操作就像没有发生一样</p></li><li><p>C(Consistency) 一致性</p><p>指事务将数据库从一种状态转变为另一种一致的的状态</p><p>事务开始前和结束后,数据库的完整性约束没有被破坏</p><blockquote><p>这个特性可能最难理解,其实一致性的C是目标,AID 是手段来保证一致性</p><p>ACID 里的 AID 都是数据库的特征,也就是依赖数据库的具体实现.而唯独这个 C,实际上它依赖于应用层,也就是依赖于开发者.这里的一致性是指系统从一个正确的状态,迁移到另一个正确的状态.什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态.而事务具备ACID里C的特性是说通过事务的AID来保证我们的一致性.</p></blockquote></li><li><p>I(Isolation) 隔离性</p><p>要求每个读写事务的对象对其他事务的操作对象能互相分离,即该事务提交前对其他事务不可见</p><p>也可以理解为多个事务并发访问时,事务之间是隔离的,一个事务不应该影响其它事务运行效果</p><p>这指的是在并发环境中,当不同的事务同时操纵相同的数据时,每个事务都有各自的完整数据空间,由并发事务所做的修改必须与任何其他并发事务所做的修改隔离</p><p>注：MySQL 通过锁机制来保证事务的隔离性。</p></li><li><p>D(Durability) 持久性</p><p>事务一旦提交,则其结果就是永久性的.即使发生宕机的故障,数据库也能将数据恢复</p><p>也就是说事务完成后,事务对数据库的所有更新将被保存到数据库,不能回滚</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识 -- 锁</title>
    <link href="/2020/12/23/MySQL-%E7%9F%A5%E8%AF%86-%E9%94%81/"/>
    <url>/2020/12/23/MySQL-%E7%9F%A5%E8%AF%86-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-锁"><a class="header-anchor" href="#MySQL-锁">⚡</a>MySQL 锁</h2><p>MySQL中有着Lock和Latch的概念，在数据库中，这两者都可以被称为“锁”，但是两者有着截然不同的含义。</p><ol><li><p>Latch一般称为闩锁(轻量级的锁),因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差，在InnoDB引擎中，Latch又可以分为 mutex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p></li><li><p>Lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。</p></li></ol><ul><li><p>锁种类</p><p><img src="/img/MySQL_Lock_And_Latch.jpg" srcset="/img/loading.gif" alt=""></p></li></ul><h2 id="InnoDB-锁"><a class="header-anchor" href="#InnoDB-锁">⚡</a>InnoDB 锁</h2><h3 id="行锁"><a class="header-anchor" href="#行锁">⚡</a>行锁</h3><ol><li><p>共享锁(S): 允许事务读取一行数据</p> <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tableName <span class="hljs-keyword">where</span> … <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">share</span> <span class="hljs-keyword">mode</span>;</code></pre></div></li><li><p>独占锁(X): 允许事务新增或者修改一行数据</p> <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tableName <span class="hljs-keyword">where</span> … <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre></div></li></ol><p>S 锁和 S 锁之间是可以兼容的,X 锁不能和任何锁兼容</p><h3 id="表锁"><a class="header-anchor" href="#表锁">⚡</a>表锁</h3><p>为了实现多粒度的锁机制，InnoDB 还有两种内部使用的意向锁，由 InnoDB 自动添加，且都是<strong>表</strong>级别的锁。</p><ol><li><p>意向共享锁(IS): 事务<strong>即将</strong>给表中的各个行设置共享锁,事务给数据行加 S 锁<strong>前</strong>必须获得该表的 IS 锁</p><p>IS 锁只是不能和 X 锁共存</p></li><li><p>意向排他锁(IX): 事务即将给表中的各个行设置排他锁,事务给数据行加 X 锁<strong>前</strong>必须获得该表 IX 锁</p><p>IX 锁不能和 X 和 S 锁共存</p></li></ol><p>意向锁的主要目的是为了<strong>使得行锁和表锁共存</strong></p><h3 id="InnoDB-存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求"><a class="header-anchor" href="#InnoDB-存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求">⚡</a>InnoDB 存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求</h3><p>InnoDB 存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求</p><ol><li><p>Record Locks (就是行锁)</p><p>把<strong>索引记录上锁</strong></p><p>如果表中没有定义索引，InnoDB 会默认为该表创建一个隐藏的聚簇索引，并使用该索引锁定记录</p></li><li><p>Gap Locks</p><p>该锁会<strong>锁定一个范围</strong>，但是<strong>不包括记录本身</strong></p><p>GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</p></li><li><p>Next-key Locks</p><p>该锁就是 Record Locks 和 Gap Locks 的组合:即<strong>锁定一个范围并且锁定该记录本身</strong></p><p>也就是说,除了锁标识的范围,还会锁住后面的一个 Gap 范围</p><p>InnoDB 使用 Next-key Locks 解决 在 Repeatable read 下的幻读问题</p><p>例如:</p> <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`test`</span> ( <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) primary <span class="hljs-keyword">key</span> auto_increment, <span class="hljs-string">`xid`</span> <span class="hljs-built_in">int</span>, <span class="hljs-keyword">KEY</span> <span class="hljs-string">`xid`</span> (<span class="hljs-string">`xid`</span>) ) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8; <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">test</span>(xid) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>), (<span class="hljs-number">3</span>), (<span class="hljs-number">5</span>), (<span class="hljs-number">8</span>), (<span class="hljs-number">11</span>);</code></pre></div><p>注意在 xid 上加了索引</p><p><img src="/img/MySQL_Next_Key.jpg" srcset="/img/loading.gif" alt=""></p><p>Session A 执行后会锁住的范围:</p><p>(5, 8], (8, 11]</p><p>除了锁住8所在的范围，还会锁住下一个范围，所谓Next-Key</p><p>这样，Session B 执行到第六步会阻塞,第七步也会阻塞,但是并不阻塞第八步,第九步也不阻塞</p><p>上面的结果似乎并不符合预期,因为11这个值看起来就是在 (8, 11] 区间里，而5这个值并不在(5, 8]这个区间里</p><p><img src="/img/MySQL_Next_Key_1.jpg" srcset="/img/loading.gif" alt=""></p><p>辅助索引 (xid 上面的索引) 中黄色部分是被 record lock锁住的行,除此之外还有两个 Gap Lock,锁住了上面说的范围</p><p>先说为什么锁住了5的插入,观察主键索引,主键索引是自增的,因此在 id=4 这条记录之前,是不允许插入一条 xid=5 的记录的。</p><p>反之，也就是说，间隙锁虽然是说是左开右闭实际上全是<strong>开区间</strong>!</p><p><strong>只不过，插入记录的主键大于行锁锁住的行主键就会等待锁，而小于行锁锁住的行主键就不会上锁!</strong></p><p>所以，本质上是两个条件：一个是间隙锁范围+行锁记录，还有一个是行锁记录的主键 id 和另一个要插入或者更新的主键 id 值有关</p><p>不锁定xid=11的写入还是可以用 id 是自增的解释,B+ 树是有序的,并不会阻塞后续的插入</p><p>…</p><p><a href="https://zhuanlan.zhihu.com/p/35477890" target="_blank" rel="noopener">参考</a></p><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">next_key</a></p><p>需要注意的是，如果索引有唯一属性，则 InnoDB 会自动将 Next-key Locks 降级为 Record Locks</p></li></ol><ul><li><p>死锁</p><p>InnoDB 引擎采取的是 wait-for graph 等待图的方法来自动检测死锁,如果发现死锁会自动回滚一个事务</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识 -- 事物隔离级别以及会导致的问题</title>
    <link href="/2020/12/23/MySQL-%E7%9F%A5%E8%AF%86-%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/23/MySQL-%E7%9F%A5%E8%AF%86-%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="事物的隔离级别"><a class="header-anchor" href="#事物的隔离级别">⚡</a>事物的隔离级别</h2><ol><li><p>读未提交 (Read Uncommitted)</p><p>读到未提交的事务的数据，造成脏读的问题</p></li><li><p>读已提交 (Read committed)</p><p>读到已提交事务的数据，但是如果这个事务内多次读的话，会造成读到的数据不一致的情况，造成不可重复读的问题</p></li><li><p>重复读 (Repeatable read)</p><p>读不到已提交事务的数据，但是会出现数据不一致的情况</p></li><li><p>串行化 (Serializable)</p><p>直接锁表，此时只能一个事务进行操作</p></li></ol><h2 id="事务可能出现的问题"><a class="header-anchor" href="#事务可能出现的问题">⚡</a>事务可能出现的问题</h2><ol><li><p>脏读</p><p>脏读就是指当一个事务正在访问数据,并且对数据进行了修改,而这种修改还没有提交到数据库中,这时,另外一个事务也访问这个数据,然后读到了这个修改后的数据</p></li><li><p>不可重复读</p><p>是指在一个事务内,多次读同一数据.在这个事务还没有结束时,另外一个事务也访问该同一数据并完成修改</p><p>那么,在第一个事务中的两次读数据之间,由于第二个事务的修改,那么第一个事务两次读到的的数据可能是不一样的.这样就发生了在一个事务内两次读到的数据是不一样的,因此称为是不可重复读(即不能读到相同的数据内容)</p></li><li><p>幻读</p><p>是指当事务不是独立执行时发生的一种现象</p><p>例如第一个事务对一个表中的数据进行了修改,这种修改涉及到表中的全部数据行.同时,第二个事务也修改这个表中的数据,这种修改是向表中插入一行新数据.那么就会发生操作第一个事务的用户发现表中还有没有修改的数据行,就好象发生了幻觉一样</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识 -- synchronize 关键字原理</title>
    <link href="/2020/12/20/Java-%E7%9F%A5%E8%AF%86-synchronize/"/>
    <url>/2020/12/20/Java-%E7%9F%A5%E8%AF%86-synchronize/</url>
    
    <content type="html"><![CDATA[<h2 id="预备知识1：对象头的标记字-MarkWord"><a class="header-anchor" href="#预备知识1：对象头的标记字-MarkWord">⚡</a>预备知识1：对象头的标记字 MarkWord</h2><p><img src="http://cdn.yinchao.tech/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" srcset="/img/loading.gif" alt="对象头"></p><h2 id="预备知识2：轻量级锁的实现机制：锁记录-Lock-Record"><a class="header-anchor" href="#预备知识2：轻量级锁的实现机制：锁记录-Lock-Record">⚡</a>预备知识2：轻量级锁的实现机制：锁记录 Lock Record</h2><p>锁记录的位置：栈的栈帧中的一部分</p><p><img src="http://cdn.yinchao.tech/synchronized-lock-record-position.png" srcset="/img/loading.gif" alt="synchronized-lock-record-position"></p><p>将锁对象的 Mark Word 复制到锁记录中，这个复制过来的记录叫做 Displaced Mark Word。具体来讲，是将 Mark Word 放到锁记录的 displaced_header 属性中。</p><p><img src="http://cdn.yinchao.tech/synchronize-lock-record.png" srcset="/img/loading.gif" alt="synchronize-lock-record"></p><p>当虚拟机使用 CAS 操作尝试将锁对象的 Mark Word 更新为指向锁记录的指针。如果更新成功，这个线程就真正获得了该对象的锁：</p><p><img src="http://cdn.yinchao.tech/synchronize-light-weight-lock-acquire.png" srcset="/img/loading.gif" alt="synchronize-light-weight-lock-acquire"></p><p>重入的情况：</p><p><img src="http://cdn.yinchao.tech/synchronize-light-weight-lock-reentrant.png" srcset="/img/loading.gif" alt="synchronize-light-weight-lock-reentrant"></p><p>为什么JVM选择在线程栈中添加 Displaced Mark word 为 null 的 Lock Record 来表示重入计数呢？</p><p>首先，锁重入次数是一定要记录下来的，因为每次解锁都需要对应一次加锁，解锁次数等于加锁次数时，该锁才真正的被释放，也就是在解锁时需要用到说锁重入次数的。</p><p>一个简单的方案是将锁重入次数记录在对象头的 Mark Word 中，但 JDK 很明显没有这么做，原因是对象头的空间有限，轻量级锁已经占了62位了，没法存储重入次数。</p><p>另一个方案是只创建一个 Lock Record 并在其中记录重入次数，Hotspot没有这样做的原因可能是考虑到效率的因素：每次重入获得锁都需要遍历该线程的栈找到对应的Lock Record，然后修改它的值，效率太低。所以 JDK 就使用每次增加 Lock Record 的方式了</p><h2 id="锁的几种状态"><a class="header-anchor" href="#锁的几种状态">⚡</a>锁的几种状态</h2><ol><li><p>无锁可偏向</p></li><li><p>无锁不可偏向</p></li><li><p>偏向锁</p></li><li><p>轻量级锁</p></li><li><p>重量锁</p></li></ol><h3 id="偏向锁"><a class="header-anchor" href="#偏向锁">⚡</a>偏向锁</h3><ul><li><p>作用：如果一个线程连续不停的获取锁，那么获取的过程中如果没有发生竞态，那么可以跳过繁重的同步过程，直接就获得锁执行，这样可以大大提高<strong>一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能</strong></p><p>因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。</p></li><li><p>锁特性：不用实际加锁，偏向某一个线程</p></li></ul><h3 id="轻量级锁"><a class="header-anchor" href="#轻量级锁">⚡</a>轻量级锁</h3><ul><li><p>作用：在并发不高的情况下，存在多个线程交替执行，只有少量竞争，通过自旋和 CAS 处理加锁部分，防止出现系统调用而影响效率</p><p>偏向锁是在只有一个线程执行同步块时提高性能，而轻量级锁是为了在线程交替执行同步块时提高性能</p></li><li><p>特性：获取锁的线程执行，等待的线程通过 CAS + 自旋的方式等待</p></li></ul><h3 id="重量级锁"><a class="header-anchor" href="#重量级锁">⚡</a>重量级锁</h3><ul><li><p>作用：通过系统调用阻塞等待线程</p></li><li><p>特性：通过 mutex 函数进行系统调用</p></li></ul><p>传统的方式就是重量级锁，说是重量级的原因是同步的方式是一种悲观锁，会导致线程的状态切换，而线程状态的切换是一个很影响效率的操作。</p><h2 id="具体流程"><a class="header-anchor" href="#具体流程">⚡</a>具体流程</h2><p><img src="http://cdn.yinchao.tech/synchronize-over-all.png" srcset="/img/loading.gif" alt="synchronize-over-all"></p><h3 id="无锁可偏向到有锁已偏向"><a class="header-anchor" href="#无锁可偏向到有锁已偏向">⚡</a>无锁可偏向到有锁已偏向</h3><p>首先一个新的对象处于无锁可偏向状态(101)，这个时候如果有个线程 A 来获取这个对象锁，那么就通过 CAS 设置这个线程的线程 id，如果成功则锁对象进入有锁已偏向状态(001),下次当这个线程 A 在此获取这个锁的时候，只要状态没有发生变化，所需要的开销就是一次指针的比较运算，而这个运算是非常轻量的。而如果 CAS 获取锁失败，说明存在多线程竞争，那么会进一步进行锁升级为轻量级锁。</p><p>而这个线程 A 会再次进入同步块，在经过一些额外的检查之后，会往当前线程栈中<strong>添加一条 Displaced Mark Word 为 null 的 Lock Record</strong>，然后程序继续向下执行。</p><p>如果这个线程执行结束，并<strong>不会主动进行偏向锁的释放</strong>。</p><h3 id="偏向锁到轻量级锁"><a class="header-anchor" href="#偏向锁到轻量级锁">⚡</a>偏向锁到轻量级锁</h3><p>如果存在另外一个线程 B 也来加锁，那么锁的偏向状态会结束，触发偏向锁的撤销并升级的逻辑，这个时候可以根据线程 A 的执行情况分为如下两种（持有锁的线程是线程 A，竞争的是线程 B）：</p><ol><li><p>线程 B 到达的时候，线程 A 已经结束</p></li><li><p>线程 B 到达的时候，线程 A 还没有终止</p></li></ol><p>无论是哪种情况，由于<strong>偏向锁不会主动释放</strong>，此时锁对象都处于有锁已偏向(101)的状态</p><p>由于对象的状态是有锁已偏向，但是又不是偏向的 B 线程，所以都会经历一个锁升级过程，但是还有不同的的地方：JVM 会在安全点 safe point 检查偏向的线程是否存活。</p><ol><li><p>如果线程 A 还存活，那么线程 A 会进行偏向锁的撤销以及升级为轻量级锁的流程。</p><p>偏向锁撤销时会将线程栈中最近一条 Lock Record 的 obj 字段设置为 null，但是不会修改锁对象头的线程 id 为 0</p><p>此时 JVM 会在线程的栈空间新建一个 Lock Record (Displaced Mark Word) 的空间，用于存储对象之前的 mark word，然后将使用 CAS 操作尝试将对象的 Mark Word 更新指向原线程 A 栈中的 Lock Record 空间（注意，此时 JVM 还是会偏向线程 A），此时这个线程 A 就继续拥有了该对象的轻量级锁，并且将锁对象的 Mark Word 的锁标志位改为轻量级锁状态(?00)。</p></li><li><p>如果线程 A 不存活，那么线程 B 同样也会进入轻量级锁的升级过程，而不会通过 CAS 获取偏向锁。</p><p>之所以线程 B 会进入轻量级锁而不重新获取偏向锁，其直接原因是：上面说过的偏向锁并不会主动撤销，此时锁状态是有锁已偏向状态(101)</p><p>本质原因则是：</p><p>最开始使用偏向锁是因为在很多场景下，加了synchronized的方法或代码块在运行过程中其实还是<strong>单线程</strong>使用（比如一些工具类为了保证其提供方法的线程安全会加synchronized，但在我们的应用中可能就是单线程使用），所以JVM为了提高性能加入了偏向锁机制。</p><p>而线程 B 需要加锁时，Mark Word 已经置为有锁已偏向状态(001)，就代表该锁对象已经被多个线程使用，已经不满足偏向锁的适用场景了。</p><p>如果下次获得锁的时候还设置为无锁可偏向状态(101)，那可能会有频繁的锁状态在不同的有锁已偏向偏向状态切换，导致性可能比重量级锁还低。</p></li></ol><p>综上：偏向锁升级的时机为：当锁已经偏向某个线程 A 后，只要有另一个线程 B 尝试获取锁，则该偏向锁就会升级成轻量级锁。当然这个说法并不绝对，因为还有批量重偏向这一机制。</p><h3 id="轻量级锁的升级或者降级"><a class="header-anchor" href="#轻量级锁的升级或者降级">⚡</a>轻量级锁的升级或者降级</h3><p><img src="http://cdn.yinchao.tech/synchronize-light-weight-lock.png" srcset="/img/loading.gif" alt="synchronize-light-weight-lock"></p><h4 id="加锁流程"><a class="header-anchor" href="#加锁流程">⚡</a>加锁流程</h4><ol><li><p>在线程栈中创建一个 Lock Record，将其 obj（即上图的Object reference）字段指向锁对象。</p></li><li><p>JVM 将锁对象的对象头的 Mark Word 复制到 Lock Record 的 Displaced Mark Word 中，其中由于是线程私有的栈帧，所以<strong>没有用到 CAS</strong></p></li><li><p>JVM 使用 CAS 操作尝试将锁对象的 Mark Word 更新为指向锁记录的指针。如果更新成功，这个线程就获得了该对象的锁；如果失败，会进入下方 4 判断是否重入。<strong>其中进行 CAS 的旧值是 Mark Word 的值，预期值是 Lock Record 的地址</strong></p></li><li><p>如果是当前线程已经持有该锁了，代表这是一次锁重入。JVM 会新增一个 Lock Record 并设置 Displaced Mark Word 为 null，obj 指向锁对象，这样做起到了一个重入计数器的作用。</p></li><li><p>如果当前线程没有持有该锁，那么加锁失败，而加锁失败会膨胀，然后会升级成重量级锁，<strong>然后再尝试 CAS +自旋加锁，失败超过一定次数后，再进入阻塞队列等待</strong>(所以其实这个 CAS + 自旋的过程是重量级锁而不是轻量级锁的情况下的策略)</p></li></ol><h4 id="解锁流程"><a class="header-anchor" href="#解锁流程">⚡</a>解锁流程</h4><p>当有其他线程尝试获得轻量级锁时，是根据遍历偏向线程的 Lock Record 来确定该线程是否还在执行同步块中的代码。</p><ol><li><p>遍历线程栈,找到所有 obj 字段等于当前锁对象的 Lock Record。</p></li><li><p>如果 Lock Record 的 Displaced Mark Word 为 null，代表这是一次重入，通过 CAS 将 obj 设置为 null 即完成解锁。</p></li><li><p>如果 Lock Record 的 Displaced Mark Word 不为 null，则通过 CAS 将 Displaced Mark Word 复制到锁对象的对象头的 Mark Word。如果成功，则继续执行下一条命令，否则膨胀为重量级锁。</p></li></ol><h4 id="问题1——为什么解锁的时候会替换失败呢？"><a class="header-anchor" href="#问题1——为什么解锁的时候会替换失败呢？">⚡</a>问题1——为什么解锁的时候会替换失败呢？</h4><p>因为解锁的时候可能有另一个线程来到，此时另一个线程会获取不到锁，膨胀成为重量级锁，改变了对象头？</p><h4 id="问题2——为什么将重入的-Lock-Record-保留呢？"><a class="header-anchor" href="#问题2——为什么将重入的-Lock-Record-保留呢？">⚡</a>问题2——为什么将重入的 Lock Record 保留呢？</h4><h4 id="使用"><a class="header-anchor" href="#使用">⚡</a>使用</h4><p>锁升级完成后，此时根据线程 B 的执行情况的后续处理会不同：</p><ol><li><p>线程 A 退出同步区释放锁，此时 B 能够获取到锁，也就说明 B 处于轻量级锁自旋的时间没有太长，这说明并发程度不大，此后 JVM 会将锁状态置为无锁不可偏向状态(001)，如果还有线程出现，也会立马升级成为轻量级锁</p></li><li><p>如果 B 经过一定时间的自旋没有获取到锁，此时会进行锁膨胀的过程，升级为重量级锁</p></li></ol><h2 id="其他"><a class="header-anchor" href="#其他">⚡</a>其他</h2><ul><li><p>重偏向：轻量级锁加锁时，如果 epoch 不等于 class 中的 epoch，会尝试重偏向，如果重偏向失败也会升级</p></li><li><p>批量重偏向：如果一个类的大量对象被一个线程T1执行了同步操作，也就是大量对象先偏向了T1，T1同步结束后，另一个线程也将这些对象作为锁对象进行操作，会导偏向锁重偏向的操作。</p></li><li><p>批量撤销：当一个偏向锁如果撤销次数到达40的时候就认为这个对象设计的有问题；那么JVM会把这个对象所对应的类所有的对象都撤销偏向锁；并且新实例化的对象也是不可偏向的。</p></li></ul><p><a href="https://createchance.github.io/post/java-%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%9F%BA%E7%9F%B3%E7%AF%87/#synchronized-%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">博客</a></p><p><a href="https://my.oschina.net/u/4358874/blog/4561467" target="_blank" rel="noopener">博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 知识 -- Redis 为什么这么快</title>
    <link href="/2020/12/20/Redis-%E7%9F%A5%E8%AF%86-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
    <url>/2020/12/20/Redis-%E7%9F%A5%E8%AF%86-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-什么快？"><a class="header-anchor" href="#Redis-什么快？">⚡</a>Redis 什么快？</h2><p>我们平时说Redis单线程快是指它的<strong>请求处理过程</strong>非常地快</p><p>至于为什么 Redis 是单线程的移步另一篇<a href="">博客</a></p><p>那么说 Redis 快则不仅仅是说它的单线程处理请求快，它去计算并返回结果操作也很快</p><p>它如此优秀的性能主要取决于以下几个方面：</p><ol><li><p>纯内存操作</p></li><li><p>数据结构简单</p></li><li><p>使用IO多路复用技术</p></li><li><p>非CPU密集型任务</p></li><li><p>单线程的优势</p></li></ol><h2 id="纯内存操作"><a class="header-anchor" href="#纯内存操作">⚡</a>纯内存操作</h2><p>Redis是一个内存数据库，它的数据都存储在内存中，这意味着我们读写数据都是在内存中完成，这个速度是非常快的。</p><p>Redis是一个KV内存数据库，它内部构建了一个哈希表，根据指定的KEY访问时，只需要O(1)的时间复杂度就可以找到对应的数据。同时，Redis提供了丰富的数据类型，并使用高效的操作方式进行操作，这些操作都在内存中进行，并不会大量消耗CPU资源，所以速度极快。</p><h2 id="数据结构简单"><a class="header-anchor" href="#数据结构简单">⚡</a>数据结构简单</h2><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><h2 id="使用IO多路复用技术"><a class="header-anchor" href="#使用IO多路复用技术">⚡</a>使用IO多路复用技术</h2><p>Redis采用单线程，那么它是如何处理多个客户端连接请求呢？</p><p>Redis采用了IO多路复用技术和非阻塞IO，这个技术由操作系统实现提供，Redis可以方便地操作系统的API即可。Redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读/可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。</p><p>整个过程非常高效，Redis利用了IO多路复用技术的事件驱动模型，保证在监听多个Socket连接的情况下，只针对有活动的Socket采取反应。</p><h2 id="非CPU密集型任务"><a class="header-anchor" href="#非CPU密集型任务">⚡</a>非CPU密集型任务</h2><p>采用单线程的缺点很明显，无法使用多核CPU。Redis作者提到，由于 Redis 的大部分操作<strong>并不是 CPU 密集型任务</strong>，而Redis的瓶颈在于<strong>内存</strong>和<strong>网络带宽</strong>。</p><p>在高并发请求下，Redis需要更多的内存和更高的网络带宽，否则瓶颈很容易出现在内存不够用和网络延迟等待的情况。</p><p>当然，如果觉得单个Redis实例的性能不足以支撑业务，Redis作者推荐部署多个Redis节点，组成集群的方式来利用多核CPU的能力，而不是在单个实例上使用多线程来处理。</p><h2 id="单线程的优势"><a class="header-anchor" href="#单线程的优势">⚡</a>单线程的优势</h2><p>基于以上特性，Redis采用单线程已足够达到非常高的性能，所以Redis没有采用多线程模型。</p><p>另外，单线程模型还带了以下好处：</p><ol><li><p>没有了多线程上下文切换的性能损耗</p></li><li><p>没有了访问共享资源加锁的性能损耗</p></li><li><p>开发和调试非常友好，可维护性高</p></li></ol><p>所以Redis正是基于以上这些方面，所以采用了单线程模型来完成请求处理的工作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 知识 -- Redis 线程相关知识</title>
    <link href="/2020/12/20/Redis-%E7%9F%A5%E8%AF%86-Redis-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/12/20/Redis-%E7%9F%A5%E8%AF%86-Redis-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="单线程"><a class="header-anchor" href="#单线程">⚡</a>单线程</h2><p>Redis Server 是多线程的，<strong>只是它的请求处理的整个流程是单线程的</strong></p><p>由于 Redis 是内存级 IO 操作,与磁盘级IO相比快几个量级，如果 Redis 采用多线程模型，那么A线程IO操作时切换到B线程进行CPU计算，可能还没切换完成A线程就已经完成IO操作了。也就是说频繁的线程切换可能会导致CPU浪费更多，不比单线程等待IO浪费的少。所以单线程可能效率会更高。</p><p>单线程模型还带了以下好处：</p><ol><li><p>没有了多线程上下文切换的性能损耗，不存在多进程或者多线程导致的切换而消耗 CPU</p></li><li><p>没有了访问共享资源加锁的性能损耗，没有因为可能出现死锁而导致的性能消耗</p></li><li><p>开发和调试非常友好，可维护性高</p></li></ol><p>单线程处理最大的缺点就是，如果前一个请求发生耗时比较久的操作，那么整个Redis就会阻塞住，其他请求也无法进来，直到这个耗时久的操作处理完成并返回，其他请求才能被处理到。</p><p>所以，我们在使用Redis时，一定要避免非常耗时的操作，例如使用时间复杂度过高的方式获取数据、一次性获取过多的数据、大量key集中过期导致Redis淘汰key压力变大等等，这些场景都会阻塞住整个处理线程，直到它们处理完成，势必会影响业务的访问。</p><h2 id="多线程"><a class="header-anchor" href="#多线程">⚡</a>多线程</h2><p>Redis Server 本身是多线程的，除了请求处理流程是单线程之外，Redis 内部还有其他工作线程在后台执行，它负责异步执行某些比较耗时的任务，例如 AOF 每秒刷盘、AOF 文件重写都是在另一个线程中完成的。</p><p>而在 Redis <strong>4.0</strong> 之后，Redis引入了 lazyfree 的机制，提供了 unlink、flushall aysc、flushdb async 等命令和 lazyfree-lazy-eviction、lazyfree-lazy-expire 等机制来异步释放内存，它主要是为了解决在释放大内存数据导致整个 redis 阻塞的性能问题。</p><p>在删除大key时，释放内存往往都比较耗时，所以Redis提供异步释放内存的方式，让这些耗时的操作放到另一个线程中异步去处理，从而不影响主线程的执行，提高性能。</p><p>到了 Redis <strong>6.0</strong>，Redis又引入了多线程来完成请求数据的协议解析，进一步提升性能。它主要是解决高并发场景下，单线程解析请求数据协议带来的压力。请求数据的协议解析由多线程完成之后，后面的请求处理阶段，包括执行命令的核心模块，依旧还是<strong>单线程</strong>排队处理。</p><h2 id="总结"><a class="header-anchor" href="#总结">⚡</a>总结</h2><p>Redis使用单线程，配合IO多路复用技术，可以完成多个连接的请求处理。而且正是由于它的使用定位是内存数据库，这样几乎所有的操作都在内存中完成，它的性能可以达到非常之高。</p><p>同时，单线程没有了线程上下文切换和访问共享资源加锁的性能损耗，而且单线程模型对程序的开发和调试非常友好，因此Redis使用单线程模型也就在情理之中了。</p><p>Redis在最近的版本也对多线程进行了优化，用于解决释放大内存数据和请求数据协议解析对Redis产生的性能影响，进一步提升了Redis的性能。</p><p>单线程结合上述场景可以达到非常高的性能，同时也存在耗时操作阻塞整个线程的问题，我们在使用Redis时要避免耗时过长的操作，才能更好地发挥Redis的性能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识 -- 慢查询</title>
    <link href="/2020/12/19/MySQL-%E7%9F%A5%E8%AF%86-%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    <url>/2020/12/19/MySQL-%E7%9F%A5%E8%AF%86-%E6%85%A2%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是慢查询"><a class="header-anchor" href="#什么是慢查询">⚡</a>什么是慢查询</h2><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阀值 long_query_time 的语句，超时则会被记录到慢查询日志中。</p><p>long_query_time 的默认值为10，意思是运行10S以上的语句。默认情况下，MySQL 数据库并不启动慢查询日志。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的<strong>性能影响</strong>。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><h2 id="参数设置"><a class="header-anchor" href="#参数设置">⚡</a>参数设置</h2><ul><li><p>slow_query_log：是否开启慢查询日志，1表示开启，0表示关闭。</p></li><li><p>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</p></li><li><p>long_query_time：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</p></li><li><p>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。</p></li><li><p>log_output：日志存储方式。log_output=‘FILE’表示将日志存入文件，默认值是’FILE’。log_output='TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=‘FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识 -- 内存模型</title>
    <link href="/2020/12/18/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/12/18/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="内存模型是什么"><a class="header-anchor" href="#内存模型是什么">⚡</a>内存模型是什么</h2><p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。</p><p>内存模型与处理器、缓存、并发、编译器都有关。它解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><h2 id="顺序一致性内存模型"><a class="header-anchor" href="#顺序一致性内存模型">⚡</a>顺序一致性内存模型</h2><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p><ol><li><p>一个线程中的所有操作必须按照程序的顺序来执行。</p></li><li><p>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</p></li></ol><p>在概念上，顺序一致性内存模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序的顺序来执行内存读/写操作。</p><h2 id="其他几种内存模型"><a class="header-anchor" href="#其他几种内存模型">⚡</a>其他几种内存模型</h2><h3 id="Weak-Memory-Models"><a class="header-anchor" href="#Weak-Memory-Models">⚡</a>Weak Memory Models</h3><p>最弱的内存模型，四种内存重排都可能出现。</p><h3 id="Weak-With-Data-Dependency-Ordering"><a class="header-anchor" href="#Weak-With-Data-Dependency-Ordering">⚡</a>Weak With Data Dependency Ordering</h3><p>支持Data dependency ordering。也就是禁止对有数据依赖的进行优化</p><h3 id="Strong-Memory-Models"><a class="header-anchor" href="#Strong-Memory-Models">⚡</a>Strong Memory Models</h3><p>不会出现LoadLoad、StoreStore、LoadStore乱序，但是StoreLoad乱序仍然存在。x86/64系列处理器通常是强序的，这是比较常见的一种内存模型。</p><h3 id="Sequential-Consistency"><a class="header-anchor" href="#Sequential-Consistency">⚡</a>Sequential Consistency</h3><p>上面特别提到过，在这种模型中，四种乱序都不会出现，就好像整个程序的执行被简化为每个线程按照顺序交互地执行有序指令。</p><h2 id="Java-内存模型-JMM"><a class="header-anchor" href="#Java-内存模型-JMM">⚡</a>Java 内存模型 JMM</h2><p>JMM 对正确同步的多线程程序的内存一致性做了如下保证：如果程序是<strong>正确同步</strong>的，程序的执行将具有顺序一致性（Sequentially Consistent）——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p><p>具体内容移步<a href="http://blog.yinchao.tech/2020/4/14/JVM-%E7%9F%A5%E8%AF%86-JVM-%E5%92%8C-JMM/" target="_blank" rel="noopener">另一篇博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识 -- happens-before 原则</title>
    <link href="/2020/12/18/Java-%E7%9F%A5%E8%AF%86-happens-before-%E5%8E%9F%E5%88%99/"/>
    <url>/2020/12/18/Java-%E7%9F%A5%E8%AF%86-happens-before-%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>JSR-133使用 happens-before 的概念来阐述操作之间的内存可见性。</p><p>在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p><p>注意：</p><blockquote><p>两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！ happens-before 仅仅要求前一个操作（<strong>执行的结果</strong>）对后一个操作<strong>可见</strong>，且前一个<strong>操作</strong>按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p></blockquote><h2 id="happens-before-部分规则"><a class="header-anchor" href="#happens-before-部分规则">⚡</a>happens-before 部分规则</h2><ul><li><p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p><p>主要含义是：在一个线程内不管指令怎么重排序，程序运行的结果都不会发生改变。和as-if-serial 比较像。</p></li><li><p>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</p><p>主要含义是：同一个锁的解锁一定发生在加锁之后</p></li><li><p>管程锁定规则：一个线程获取到锁后，它能看到前一个获取到锁的线程所有的操作结果。</p><p>主要含义是：无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</p></li><li><p>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</p><p>主要含义是：如果一个线程先去写一个volatile变量，然后另一个线程又去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</p></li><li><p>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p></li><li><p>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</p><p>主要含义是：线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p></li><li><p>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p><p>主要含义是：如果在线程A执行过程中调用了线程B的join方法，那么当B执行完成后，在线程B中所有操作结果对线程A可见。</p></li><li><p>线程中断规则：对线程interrupt方法的调用happens-before于被中断线程的代码检测到中断事件的发生。</p><p>主要含义是：响应中断一定发生在发起中断之后。</p></li><li><p>对象终结规则：就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</p></li></ul><p><strong>一个happens-before规则对应于一个或多个编译器和处理器重排序规则。</strong></p><h2 id="as-if-serial-和-happens-before-原则"><a class="header-anchor" href="#as-if-serial-和-happens-before-原则">⚡</a>as-if-serial 和 happens-before 原则</h2><p>as-if-serial 和 happens-before 的主要作用都是：在保证不改变程序运行结果的前提下，允许部分指令的重排序，最大限度的提升程序执行的效率。</p><p>他们的区别是：前者只保证单线程下的有序性，而后者则是保证多线程下的程序执行有序性和可见性（多线程才有可见性一说，而且保证的前提是遵循了这些原则）</p><h2 id="Java-中的有序性"><a class="header-anchor" href="#Java-中的有序性">⚡</a>Java 中的有序性</h2><ol><li><p>如果在本地线程内观察，所有操作都是有序的（“线程内表现为串行”(Within-Thread As-If-Serial Semantics)）；</p></li><li><p>如果在一个线程中观察另一个线程，所有操作都是无序的（“指令重排序”现象和“线程工作内存与主内存同步延迟”现象）。</p></li></ol><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性：</p><ol><li><p>volatile关键字本身就包含了禁止指令重排序的语义</p></li><li><p>synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识 -- CPU 缓存一致性</title>
    <link href="/2020/12/17/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CPU-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2020/12/17/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CPU-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>CPU 的多级高速缓存引入了一个新的问题：缓存一致性（Cache Coherence）。在多核 CPU 系统中，每个 CPU 都有自己的高速缓存，而它们又公用一块主内存（Main Memory）。当多个 CPU 的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存不一致。如果真发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？</p><h2 id="总线加锁"><a class="header-anchor" href="#总线加锁">⚡</a>总线加锁</h2><p>通过在总线上加 <code>LOCK#</code> 锁的形式可以解决缓存不一致的问题。</p><p>因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。</p><p>但是这种方式会有一个问题，由于在锁住总线期间，其他 CPU 无法访问内存，导致效率低下。</p><p>由于总线加 Lock 锁的方式效率低下，后来便出现了缓存一致性协议。最出名的就是 Intel 的 MESI 协议。</p><h2 id="缓存一致协议（MESI-协议为例）"><a class="header-anchor" href="#缓存一致协议（MESI-协议为例）">⚡</a>缓存一致协议（MESI 协议为例）</h2><p>其主要思想是：</p><p>当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><p>定义了 Cache Life 的四种状态：</p><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">M(Modified)</td><td style="text-align:center">这行数据有效，数据被修改了，和内存中的数据不一致，当前数据只存在于本Cache中。</td></tr><tr><td style="text-align:center">E(Exclusive)</td><td style="text-align:center">这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。</td></tr><tr><td style="text-align:center">S(Shared)</td><td style="text-align:center">这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。</td></tr><tr><td style="text-align:center">I(Invalid)</td><td style="text-align:center">这行数据无效。</td></tr></tbody></table><ul><li><p>一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU，将自己的状态变成s。</p></li><li><p>一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。</p></li><li><p>一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到读操作，则必须把其缓存行状态设置为S。</p></li></ul><p>除了状态之外，CPU还需要一些消息机制:</p><ul><li><p>Read: CPU发起读取数据请求，请求中包含需要读取的数据地址。</p></li><li><p>Read Response: 作为Read消息的响应，该消息可能是内存响应的，也可能是某CPU响应的(比如该地址在某CPU Cache Line中为Modified状态，该CPU必须返回该地址的最新数据)。</p></li><li><p>Invalidate: 该消息包含需要失效的地址，所有的其它CPU需要将对应Cache置为Invalid状态</p></li><li><p>Invalidate Ack: 收到Invalidate消息的CPU在将对应Cache置为Invalid后，返回Invalid Ack</p></li><li><p>Read Invalidate: 相当于Read消息+Invalidate消息，即取得数据并且独占它，将收到一个Read Response和所有其它CPU的Invalid Ack</p></li><li><p>Writeback: 写回消息，即将状态为Modified的行写回到内存，通常在该行将被替换时使用。现代CPU Cache基本都采用”写回(Write Back)”而非”直写(Write Through)”的方式。</p></li></ul><p>MESI 还有进一步优化的空间 ⬇</p><h3 id="优化"><a class="header-anchor" href="#优化">⚡</a>优化</h3><h4 id="Store-Buffer"><a class="header-anchor" href="#Store-Buffer">⚡</a>Store Buffer</h4><p>写入 Cache 时，如果不是 M 或者 E 状态，需要发送一个 Invalidate 消息给其他 CPU，然后等待其他 CPU 的 Invalidate Ack 回应之后，才会进行写入，但是这样就有了等待的时间，影响了性能。</p><p>有一种解决办法就是引入 Store Buffer：</p><p><img src="http://cdn.yinchao.tech/cache-with-store-buffer.png" srcset="/img/loading.gif" alt="cache-with-store-buffer"></p><p>CPU 不再需要等待其他 CPU 的响应，只需要把修改内容装入 store buffer，然后继续执行，当状态改变之后，再把数据从 store buffer 写入 Cache Line 中</p><p>但是这也产生了新的问题</p><p>初始状态下，假设a,b值都为0，并且a存在CPU1的Cache Line中(Shared状态)，可能出现如下操作序列:</p><ol><li><p>CPU0 要写入A，发出Read Invalidate消息，并将a=1写入Store Buffer</p></li><li><p>CPU1 收到Read Invalidate，返回Read Response(包含a=0的Cache Line)和Invalidate Ack</p></li><li><p>CPU0 收到Read Response，更新Cache Line(a=0)</p></li><li><p>CPU0 开始执行 b = a + 1，从Cache Line中加载a，得到a=0</p></li><li><p>CPU0 将Store Buffer中的a=1应用到Cache Line</p></li><li><p>CPU0 得到 b=0+1，断言失败</p></li></ol><p>导致这个问题的根本原因是我们有两个a值，一个在cacheline中，一个在store buffer中。</p><p>这个出错的例子之所以发生是因为它违背了一个基本的原则，即每个CPU按照其视角来观察自己的行为的时候必须是符合 program order 的。一旦违背这个原则，会导致一些非常不直观的软件行为，对软件工程师而言就是灾难。</p><h4 id="Store-Forwarding"><a class="header-anchor" href="#Store-Forwarding">⚡</a>Store Forwarding</h4><p>由于单纯的 store buffer 的问题，硬件工程师在 Store Buffer 的基础上，又实现了&quot;Store Forwarding&quot;技术: CPU 可以直接从 Store Buffer 中加载数据，即支持将CPU 存入 Store Buffer 的数据传递(forwarding)给后续的加载操作，而不经由Cache。</p><p>所以，对于上面的问题，使用 Store Forwarding 可以从 store buffer 中获取到 a 为 1 而不是 0，程序正确</p><p>看看下面的对比：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="http://cdn.yinchao.tech/cache-with-store-buffer.png" srcset="/img/loading.gif" alt="cache-with-store-buffer"></div><div class="group-image-wrap"><img src="http://cdn.yinchao.tech/cache-with-store-forwarding.png" srcset="/img/loading.gif" alt="cache-with-store-forwarding"></div></div></div><p>虽然 store forwarding 解决了同一个CPU读写数据的问题，再来看看并发程序:</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">// CPU0 执行，没有缓存 a</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;    a = <span class="hljs-number">1</span>;    b = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// CPU1 执行，没有缓存 b</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;    assert(a == <span class="hljs-number">1</span>)&#125;</code></pre></div><p>假设初始状态下，a=0，b=0，a存在于CPU1的Cache中，b存在于CPU0的Cache中，均为Exclusive状态，CPU0执行foo函数，CPU1执行bar函数，上面代码的预期显然为断言为真。那么来看下执行序列:</p><ol><li><p>CPU1执行while(b == 0)，由于CPU1的Cache中没有b，发出Read b消息</p></li><li><p>CPU0执行a = 1，由于CPU0的Cache中没有a，因此它将a(当前值1)写入到Store Buffer并发出Read Invalidate a消息</p></li><li><p>CPU0执行b = 1，由于b已经存在在Cache中(Exclusive)，因此可直接执行写入</p></li><li><p>CPU0收到Read b消息，将Cache中的b(当前值1)返回给CPU1，将b写回到内存，并将Cache Line状态改为Shared</p></li><li><p>CPU1收到包含b的Cache Line，结束while (b == 0)循环</p></li><li><p>CPU1执行assert(a == 1)，由于此时CPU1 Cache Line中的a仍然为0并且有效(Exclusive)，断言失败</p></li><li><p>CPU1收到Read Invalidate a消息，返回包含a的Cache Line，并将本地包含a的Cache Line置为Invalid(已经晚了)</p></li><li><p>CPU0收到CPU1传过来的Cache Line，然后将Store Buffer中的a(当前值1)刷新到Cache Line</p></li></ol><p>上面的问题简单来说就是，当 CPU0 执行 foo 时，由于没有缓存 a，但是缓存了 b，所以对于 a 来说只能先写到 store buffer 里面，但是 b 来说可以直接写入，并且此时 CPU 1 来说，b 的值已经可以看到被修改，然后跳出循环，执行后面的断言 a==1，但是此时 a 在这个 CPU1 的缓存还没有来得及失效，所以就直接使用了它自己的缓存中的 a = 0 的值，导致断言失败。</p><p>而问题发生的原因是：对于 CPU 来说，它不知道 a 和 b 之间的数据依赖，CPU0 对 a 是写入 store buffer，而对于 b 则是写入 cache</p><h4 id="内存屏障"><a class="header-anchor" href="#内存屏障">⚡</a>内存屏障</h4><p>为了解决这个问题，我们可以在 foo 中 a = 1 和 b = 1 之间加上内存屏障。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;    a = <span class="hljs-number">1</span>;    smp_mb()    b = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;    assert(a == <span class="hljs-number">1</span>)&#125;</code></pre></div><p>当遇到 smp_mb() 时，会先刷新屏障前的 store buffer， 然后执行屏障后 cache 的写入。</p><p>这里刷新 store buffer 有两种方式，第一种是等待相关的 Read Response 返回，再写入 cache，但是这样和没有使用 store buffer 一样，有等待时间的浪费；第二种方式则是将屏障前的所有 store buffer 都打上标记，然后 CPU 后续所有的修改都写入到 store buffer里面（不管 cache 中是否存在），直到屏障前的数据（所有被打上标记的数据）都写入到 Cache Line 中之后，才会按照以前的，如果缓存中存在且状态为 E 则直接写入缓存</p><ol><li><p>CPU1执行while(b == 0)，由于CPU1的Cache中没有b，发出Read b消息</p></li><li><p>CPU0执行a = 1，由于CPU0的Cache中没有a，因此它将a(当前值1)写入到Store Buffer并发出Read Invalidate a消息</p></li><li><p>CPU0看到smp_mb()内存屏障，它会标记当前Store Buffer中的所有条目(即a = 1被标记)</p></li><li><p>CPU0执行b = 1，尽管b已经存在在Cache中(Exclusive)，但是由于Store Buffer中还存在被标记的条目，因此b不能直接写入，只能先写入Store Buffer中</p></li><li><p>CPU0收到Read b消息，将Cache中的b(当前值0)返回给CPU1，将b写回到内存，并将Cache Line状态改为Shared</p></li><li><p>CPU1收到包含b的Cache Line，继续while (b == 0)循环</p></li><li><p>CPU1收到Read Invalidate a消息，返回包含a的Cache Line，并将本地的Cache Line置为Invalid</p></li><li><p>CPU0收到CPU1传过来的包含a的Cache Line，然后将Store Buffer中的a(当前值1)刷新到Cache Line，并且将Cache Line状态置为Modified</p></li><li><p>由于CPU0的Store Buffer中被标记的条目已经全部刷新到Cache，此时CPU0可以尝试将Store Buffer中的b=1刷新到Cache，但是由于包含B的Cache Line已经不是Exclusive而是Shared，因此需要先发Invalid b消息</p></li><li><p>CPU1收到Invalid b消息，将包含b的Cache Line置为Invalid，返回Invalid Ack</p></li><li><p>CPU1继续执行while(b == 0)，此时b已经不在Cache中，因此发出Read消息</p></li><li><p>CPU0收到Invalid Ack，将Store Buffer中的b=1写入Cache</p></li><li><p>CPU0收到Read消息，返回包含b新值的Cache Line</p></li><li><p>CPU1收到包含b的Cache Line，可以继续执行while(b == 0)，终止循环</p></li><li><p>CPU1执行assert(a == 1)，此时a不在其Cache中，因此发出Read消息</p></li><li><p>CPU0收到Read消息，返回包含a新值的Cache Line</p></li><li><p>CPU1收到包含a的Cache Line，断言为真</p></li></ol><p>可能看到这里的流程会有疑惑，如果 Read Invalid 一直没有返回，也就是 store buffer 里面的 a 和 b 的值一直都没来得及刷新到 Cache Line，那么 bar 函数也一直无法向后运行，这和没有 store buffer 不是一样了吗？</p><p>其实不然，因为这里另一个 CPU 执行的 bar 函数只是正好受限于共享变量 b，如果其他函数或者程序没有因为这个 b 的值而不能运行，而是一直向下执行，那么这个实际上是有时间上面的节省的。</p><h4 id="Invalid-Queue"><a class="header-anchor" href="#Invalid-Queue">⚡</a>Invalid Queue</h4><p>现在还有一个问题没有考虑到：Store Buffer 的大小是有限的，所有写入操作的 Cache Missing 都会使用 Store Buffer，特别是出现内存屏障时，后续的所有写入操作(不管是否Cache Miss)都会存储在在 Store Buffer 中，直到 Store Buffer 中屏障前的条目处理完。</p><p>因此 Store Buffer 很容易会满，当 Store Buffer 满了之后，CPU 还是会卡在等对应的 Invalid Ack 以处理 Store Buffer 中的条目。</p><p>问题的原因在于 Invalid Ack，Invalid Ack 耗时的主要原因是 CPU 要先将对应的Cache Line 置为 Invalid 后再返回 Invalid Ack，一个很忙的 CPU 可能会导致其它CPU 都在等它回 Invalid Ack。</p><p>其解决思路就是异步： CPU不必要处理了Cache Line之后才回Invalid Ack，而是可以先将Invalid消息放到某个请求队列Invalid Queue，然后就返回Invalid Ack。CPU可以后续再处理Invalid Queue中的消息，大幅度降低Invalid Ack响应时间。</p><p><img src="http://cdn.yinchao.tech/cache-with-invalid-queue.png" srcset="/img/loading.gif" alt="cache-with-invalid-queue"></p><p>Invalid Queue有两个问题要考虑</p><ol><li><p>CPU在处理任何Cache Line 的 MSEI 状态前，都必须先看 Invalid Queue 中是否有该 Cache Line 的 Invalid 消息没有处理。这一点在CPU数据竞争不是很激烈时是可以接受的。</p><p>此前的内存屏障实际上是一个写屏障，其实还有读屏障</p></li></ol><p>1.另一个要考虑的问题是它也增加了破坏内存一致性的可能，即可能破坏我们之前提到的内存屏障:</p><p>上面加入了内存屏障的代码，CPU 也有可能按照如下的情况执行：</p><ol><li><p>CPU0执行a = 1，由于其有包含a的Cache Line，将a写入Store Buffer，并发出Invalidate a消息</p></li><li><p>CPU1执行while(b == 0)，它没有b的Cache，发出Read b消息</p></li><li><p>CPU1 收到 CPU0 的 Invalidate a消息，将其放入 Invalidate Queue，返回Invalidate Ack</p></li><li><p>CPU0 收到 Invalidate Ack，将 Store Buffer 中的 a=1 刷新到 Cache Line，标记为 Modified</p></li><li><p>CPU0 看到 smp_mb() 内存屏障，但是由于其 Store Buffer 为空，因此它可以直接跳过该语句</p></li><li><p>CPU0 执行 b = 1，由于其 Cache 独占 b，因此直接执行写入，Cache Line 标记为 Modified，</p></li><li><p>CPU0 收到 CPU1发 的 Read b 消息，将包含 b 的 Cache Line 写回内存并返回该 Cache Line，本地的 Cache Line 标记为 Shared</p></li><li><p>CPU1 收到包含b(当前值1)的Cache Line，结束while循环</p></li><li><p>CPU1执行 assert(a == 1)，由于其本地有包含a旧值的Cache Line，读到a初始值0，断言失败</p></li><li><p>CPU1这时才处理Invalid Queue中的消息，将包含a旧值的Cache Line置为Invalid</p></li></ol><p>出现问题的地方就是在于 CPU1 读取 a 的 Cache Line 时，没有先去处理 Invalid Queue 中的 Invalid 操作。其本质问题是由于增加了 Invalid Queue 使得打破了内存屏障（写屏障）的语义</p><p>解决办法还是内存屏障（读屏障）：<br>我们可以通过内存屏障让 CPU 标记当前 Invalid Queue 中所有的条目，所有的后续加载操作必须先等 Invalid Queue 中标记的条目处理完成再执行。</p><p>具体步骤是其实不是 CPU 遇到读屏障就立即去处理 Invalid Queue，而是标记 Invalidate Queue 上的 Cache Line，之后继续执行别的指令，直到看到下一个 Load 操作要从 Cache Line 里读数据了，CPU 才会等待 Invalidate Queue 内所有刚才被标记的 Cache Line 都处理完才继续执行下一个 Load。</p><p>因此我们可以在 while 和 assert 之间插入 smp_mb()。这样 CPU1 在看到 smp_mb() 后，会先标记 Invalidate Queue 所有的数据，然后继续读取 a 的值，但是读取的时候发现 Invalid Queue 还有标记的数据，于是等待标记的数据处理完，然后发现 a 的状态为 I，重新从 CPU0 获取，得到 a 的值为1，断言成立。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;    a = <span class="hljs-number">1</span>;    smp_mb()    b = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;    smp_mb()    assert(a == <span class="hljs-number">1</span>)&#125;</code></pre></div><h2 id="CPU-为了保证缓存一致性而产生的-False-Sharing-问题"><a class="header-anchor" href="#CPU-为了保证缓存一致性而产生的-False-Sharing-问题">⚡</a>CPU 为了保证缓存一致性而产生的 False Sharing 问题</h2><p><img src="http://cdn.yinchao.tech/CPU-False_Sharing.jpg" srcset="/img/loading.gif" alt="CPU-False_Sharing"></p><p>A、B 两个对象在内存上被连续的创建在一起，假若这两个对象都很小，小于一个 Cache Line 大小，那他们可能会共用同一个 Cache Line。如果再有两个线程 Thread 1 和 Thread 2 会去操作这两个对象，我们从代码角度保证 Thread 1 只会操作 A，而 Thread2 只会操作 B。那按道理这两个 Thread 访问 A B 不该有相互影响，都能并行操作。但现在因为它俩刚好在同一个 Cache Line 内，就会出现 A B 对象所在 Cache Line 在两个 CPU 上来回搬迁的问题。</p><p>比如 Thread 1 要修改对象 A，那 Thread 1 所在 CPU 1 会先获取 A 所在 Cache Line 的 Exclusive 权限，会发送 Invalidate 给其它 CPU 让其它 CPU 设置该 Cache Line 为无效。之后 Thread 2 要修改对象 B，Thread 2 所在 CPU 2 又会尝试获取 B 所在 Cache Line 的 Exclusive 权限，会发 Invalidate 给其它 CPU，包括 CPU 1。CPU 1 要是已经写完了 A，那就要把数据刷写内存，之后设置 Cache Line 无效并响应 Invalidate。没写完就得等待 CPU 1 写完 A 后再处理 Cache Line 的 Invalidate 问题。之后 CPU 2 再去操作 Cache Line 更新 B 对象。再后来 Thread 1 要去更新 A 对象的话又要去把 A B 所在 Cache Line 在 CPU 2 上设置无效。也就是说这块 Cache Line 失去了 Cache 功能，会在两个 CPU 上来回搬迁，会经常性的执行刷写内存，读取内存操作，导致两个本来看上去没有关系的操作实际上有相互干扰。</p><p>False Sharing 问题其实不会很常见，不过 TLAB 和 PLAB 机制可能会增大它出现的几率。</p><p>一般 TLAB 大于 Cache Line 所以不会引起 False Sharing 问题。JVM 上容易引起 False Sharing 的情况是：一个线程连续分配了两个对象，这两个对象后来被分配给不同的线程，并且被它们频繁更新，这两个对象在两个不同线程上就容易出现 False Sharing 问题，即使经历数轮 GC，它俩可能在内存上还是可能在一起，所以说 TLAB 和 PLAB 会增大 False Sharing 出现的概率。</p><h2 id="内存屏障的种类"><a class="header-anchor" href="#内存屏障的种类">⚡</a>内存屏障的种类</h2><p>看似这个内存屏障就是改变了 Invalid Queue 的处理方式而已，其实第一个写屏障只是关心 Store Buffer 中有没有标记的值，而这里的读屏障其实只关心 Invalid Queue 中有没有标记的值，这其实也是大多数 CPU 划分的内存屏障的类型：读屏障(Read Memory Barrier)和写屏障(Write Memory Barrier):</p><ul><li><p>读屏障: 任何读屏障前的读操作都会先于读屏障后的读操作完成</p><p>对于读屏障，它只是约束执行 CPU 上的 load 操作的顺序，具体的效果就是 CPU 一定是完成读屏障之前的 load 操作之后，才开始执行读屏障之后的 load 操作。读屏障像一道栅栏，严格区分了之前和之后的 load 操作。</p></li><li><p>写屏障: 任何写屏障前的写操作都会先于写屏障后的写操作完成</p><p>和读屏障类似，严格区分写屏障之前和之后的 store 操作</p></li><li><p>全屏障: 同时包含读屏障和写屏障的作用</p></li></ul><p>在前面的例子中，foo 函数只需要写屏障，bar 函数需要读屏障。实际的 CPU 架构中，可能提供多种内存屏障，比如可能分为四种:</p><ul><li><p>LoadLoad: 相当于前面说的读屏障</p></li><li><p>LoadStore: 任何该屏障前的读操作都会先于该屏障后的写操作完成</p></li><li><p>StoreLoad: 任何该屏障前的写操作都会先于该屏障后的读操作完成</p></li><li><p>StoreStore: 相当于前面说的写屏障</p></li></ul><p>其实现原理类似，都是基于 Store Buffer 和 Invalidate Queue</p><hr><h2 id="问题"><a class="header-anchor" href="#问题">⚡</a>问题</h2><ol><li><p>为什么修改值有 Read Invalid，直接赋值不就好了吗</p><p>CPU0 对a 进行写入操作，虽然 CPU0 中没有 a 的缓存，但是也按理说无需知道 a 的初值，直接赋值就好了，为什么还要发送&quot;Read&quot;消息呢？</p><p>因为一个 Cache Line 中不止是包含 a 的数据，例如cache line有256字节而a可能只有4字节，写a不能使同数据块的其它值受影响。</p></li></ol><p><a href="https://wudaijun.com/2019/04/cpu-cache-and-memory-model/" target="_blank" rel="noopener">博客1</a></p><p><a href="https://blog.csdn.net/reliveIT/article/details/105902477#t7" target="_blank" rel="noopener">博客2</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
      <tag>hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统知识 -- 程序局部性原理</title>
    <link href="/2020/12/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86-%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/"/>
    <url>/2020/12/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86-%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="局部性原理概念"><a class="header-anchor" href="#局部性原理概念">⚡</a>局部性原理概念</h2><p>程序局部性原理：是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域，具体来说，局部性通常有两种形式：时间局部性和空间局部性。</p><p>CPU的工作要高速，我们希望 CPU 需要的数据更多的就在 L1 里面，一找就找着。不希望更多的跑到下面内存乃至磁盘里面去找，这样会花更多的时间。所以当CPU用了一个数据，计算机会预见性的存入其他等会儿CPU可能会用到的数据到L123内存，用到的可能性越大，就能存到越接近寄存器的层次。这也才是缓存的真正意义。那么，计算机怎样才能判断一个数据接下来可能被用到？</p><ul><li><p>时间局部性：被引用过一次的存储器位置在未来会被多次引用，如果一个数据项正在被访问，那么在近期它很可能还会被再次访问。</p></li><li><p>空间局部性：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</p></li></ul><p>而且，对于变量之间的距离太远，它的空间局部性会越差，因为 CPU 没有办法在其附近找到变量</p><p>其应用就是二维数组分别按行和列遍历输出，前者的时间会短于后者</p><h2 id="分支预测"><a class="header-anchor" href="#分支预测">⚡</a>分支预测</h2><p>对于统计一个数组中大于0的个数，如果这个数组无序随机，那么它所花费的时间要比有序或者有规律(正序、逆序、按照一定间隔出现等等只要是有某种规律)的数组要长，其中的原因就是分支预测，其实质上就是局部性原理的应用</p><p>分支预测就是预先预测会用到某些数据，虽然程序还没有执行这后面的相关指令，但是我们此时有并行计算的能力，完全可以预先计算或者读取一部分数据，然后当程序真正执行到后面的时候，再去看是否确实用到了我们计算好或者提前准备好的数据，如果用到了，那么直接使用，加大 CPU 运行效率；如果没有用到，那么再去加载准备需要的数据</p><p>例如程序中的分支，我们不知道程序会进入哪一个分支，此时我们有两种方案：第一，CPU 暂停等待前面的指令执行完成，然后再去沿着正确的分支执行。第二，由于现代 CPU 很复杂，有很长的 pipeline，所以更好的解决办法是首先猜测会进入哪一个分支，如果猜错了，那么会刷新管道，回滚到分支，沿着正确的分支开始；如果猜对了，就继续执行</p><p>如果每次猜对了，执行会一直进行；如果经常猜错，就会花时间回滚到分支，重新开始。</p><p>而猜测的方式是根据历史数据来的，如果常常选择第一个分支，那么下次就会猜测第一个分支，如果常常是交替选择的，那就交替猜测……</p><p>回到最开始的问题，其实就是有规律的数组中的数据可以更好的被提前预测，并且可以先被读取到缓存中，等需要的时候直接调用就好了，速度要比那一时刻再去内存中读取的要快</p><p>原出处: <a href="https://stackoverflow.com/a/11227902/8013228" target="_blank" rel="noopener">stack overflow 上面的一个答案</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hardware</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识 -- 指令重排</title>
    <link href="/2020/12/14/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/"/>
    <url>/2020/12/14/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<p>为了更好地利用CPU，CPU和编译器都可能会对指令进行重排(reordering):</p><ul><li><p>编译期间重排: 编译器在编译期间，可能对指令进行重排，以使其对 CPU 更友好</p></li><li><p>指令并行重排（运行期间重排）：CPU 在执行指令的过程中，可能乱序执行以更好地利用流水线</p></li><li><p>内存系统重排：由于 CPU 使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ul><p>不管是 CPU 架构，还是编译器，在对指令进行重排时都要遵守一个约束: 不管指令如何重排，对单线程来说，结果必然是一致的。即不会改变单线程程序的行为。(as-if-serial 原则)</p><p>那么，为了保证 as-if-serial 原则，但是又要最大限度的进行重排序的优化，所以引入了<strong>内存屏障</strong>和<strong>临界区</strong></p><p>也就是说，如果没有 happens-before 原则，那么对于代码 JVM 可以去做重排序，对于存在 happens-before 原则中出现的代码 JVM 不能做重排序</p><h2 id="禁止指令重排的一个例子"><a class="header-anchor" href="#禁止指令重排的一个例子">⚡</a>禁止指令重排的一个例子</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeThing</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SomeThing</span><span class="hljs-params">()</span> </span>&#123;            status = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> status;        &#125;    &#125;    <span class="hljs-keyword">private</span> SomeThing object;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;        object = <span class="hljs-keyword">new</span> SomeThing();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SomeThing <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (object == <span class="hljs-keyword">null</span>) &#123;            Thread.yield(); <span class="hljs-comment">//不加这句话可能会在此出现无限循环</span>        &#125;        <span class="hljs-keyword">return</span> object;    &#125;&#125;</code></pre></div><p>这个容器并不要求一个线程写入了object，object的新值立即对下一个读取的线程可见，但是这段代码在运行的时候可能还是会出现并发问题，和 DCL 单例类似，可能在加入引用的时候得到不完整的对象，那么我们同样也可以通过加入 volatile 关键字保证可见性</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeThing</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SomeThing</span><span class="hljs-params">()</span> </span>&#123;            status = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> status;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span>  SomeThing object;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;        object = <span class="hljs-keyword">new</span> SomeThing();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SomeThing <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (object == <span class="hljs-keyword">null</span>) &#123;            Thread.yield(); <span class="hljs-comment">//不加这句话可能会在此出现无限循环</span>        &#125;        <span class="hljs-keyword">return</span> object;    &#125;&#125;</code></pre></div><p>volatile 修饰 object 字段。这种方法避免了重排序，保证了内存可见性，摒弃比使用同步块导致的性能损失更小。</p><p>但是由于我们不要求一个线程写入了object，object的新值立即对下一个读取的线程可见，而且在 Intel 64/IA-32 环境下，有更好的解决方案。</p><p>Intel 64/IA-32 下写操作之间不会发生重排序，即在处理器中，构建SomeThing对象与赋值到object这两个操作之间的顺序性是可以保证的。这样看起来，仅仅使用volatile来避免重排序是多此一举的。但是，<strong>Java编译器却可能生成重排序后的指令</strong>。但令人高兴的是，Oracle的JDK中提供了Unsafe.putOrderedObject，Unsafe.putOrderedInt，Unsafe.putOrderedLong这三个方法，JDK会在执行这三个方法时插入StoreStore内存屏障，避免发生写操作重排序。而在 Intel 64/IA-32 架构下，StoreStore 屏障并不需要，Java编译器会将StoreStore屏障去除。比起写入volatile变量之后执行StoreLoad屏障的巨大开销，采用这种方法除了避免重排序而带来的性能损失以外，不会带来其它的性能开销。</p><p><a href="https://tech.meituan.com/2014/09/23/java-memory-reordering.html" target="_blank" rel="noopener">例子出处</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识 -- 内存屏障</title>
    <link href="/2020/12/14/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <url>/2020/12/14/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="CPU-提供多种内存屏障"><a class="header-anchor" href="#CPU-提供多种内存屏障">⚡</a>CPU 提供多种内存屏障</h2><ul><li><p>LoadLoad: 相当于<code>读屏障</code>: 任何读屏障前的读操作都会先于该屏障后的读操作完成</p></li><li><p>LoadStore: 任何该屏障前的读操作都会先于该屏障后的写操作完成</p></li><li><p>StoreLoad: 任何该屏障前的写操作都会先于该屏障后的读操作完成</p><p>对于 StoreLoad 实际上是一个性能开销最大的屏障，因为 StoreLoad 必须同时兼顾读和写，并且对于这两个操作必须全部完成</p><p>StoreLoad 相当于一个全屏障，其他内存屏障能够做到的它都能够做到</p><p>可能会觉得 LoadStore 也是要兼顾读写，但是它只是保证读在写之前完成，但是并不关心写在什么时候完成</p></li><li><p>StoreStore: 相当于<code>写屏障</code>: 任何写屏障前的写操作都会先于该屏障后的写操作完成</p></li></ul><h3 id="为什么内存屏障能保证可见性和有序性呢？"><a class="header-anchor" href="#为什么内存屏障能保证可见性和有序性呢？">⚡</a>为什么内存屏障能保证可见性和有序性呢？</h3><p>原因其实就在问题里，为了保证可见性，我们使用内存屏障保证数据的可见，为了保证有序性，我们使用内存屏障限制指令重排</p><p>对于保证数据可见性，在<a href="http://blog.yinchao.tech/2020/12/17/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CPU-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">上一篇博客</a>里面其实一直使用的都是内存屏障的可见性的功能，使得数据一定可见，但是没有提到内存屏障还有一个限制指令重排序的重要功能，例如：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;    a = <span class="hljs-number">1</span>;    smp_wmb()    b = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;    smp_rmb()    assert(a == <span class="hljs-number">1</span>)&#125;</code></pre></div><p>这是之前加入了两个内存屏障，使得 CPU0 先刷新 store buffer 中的数据， CPU1 也类似，先处理 Invalid Queue 的指令，但是，其实如果不加这两个内存屏障，CPU 也有可能对其指令进行指令重排序，也可能使我们得到不一致的结果，例如：</p><p>假设上面的代码中内存屏障没有限制指令重排序的功能，那么代码 foo 可能会被优化成先去执行 b =1 后去执行 a = 1，那么即使在 b = 1 之前加入了写屏障，也失去了效果，因为这个写屏障之前没有任何操作，写屏障相当于作废了，从而当另一个 CPU 执行 while 循环并退出的时候，读到 a 的值就是 0 （第一个 CPU 还没有执行到 a = 1 这条指令，或者就算执行到了，也在 Store Buffer 里面，并没有刷新到 Cache Line），造成数据不一致的情况</p><p>而如果 foo 函数的 b =1 前面加入了 StoreStore 屏障，这样 a = 1 就不可能就会在 b =1 后面执行，因为 a = 1 是一个写操作，如果把 a = 1 放到 b = 1 之后执行，按么就违背了 StoreStore 屏障。类似的，在 b = 1 后面要加入 StoreLoad 屏障，保证前面的读操作在 volatile 写之前完成，由此可以看出，内存屏障也限制了指令重排。</p><p>当然，可能会有疑问，如果没有在 b = 1 前面加入 StoreStore 屏障，而仅仅是在 b = 1 后面加入 StoreLoad 屏障，那么 a = 1 还是有可能会被重排序到后面去，导致结果不正确。所以，为了保证程序的有序性和可见性，Java 中 volatile 关键字要在写之前和写之后加入这些内存屏障。</p><p>当然，可能还有疑问，如果在 b = 1 之前加入 StoreStore 屏障就可以实现禁止指令重排，那么为什么还要在 b = 1 之后加入 StoreLoad 内存屏障呢？答案是，对于编译器来说，发现一个最优布置来最小化插入屏障的总数是几乎不可能的，所以JVM 采用 <strong>保守策略</strong>，每次 volatile 变量读写之前和之后都会加入内存屏障以保证 volatile 的内存语义。</p><h2 id="内存屏障具体实现方式"><a class="header-anchor" href="#内存屏障具体实现方式">⚡</a>内存屏障具体实现方式</h2><ol><li><p>可见性是通过对 CPU 的 Store Buffer 和 Invalid Queue 中标记的数据进行处理实现的，具体的方式移步<a href="http://blog.yinchao.tech/2020/12/17/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CPU-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" target="_blank" rel="noopener"></a></p></li><li><p>禁止重排序我认为是在 CPU 执行的规定，看到内存屏障就不再取后面的指令。</p></li></ol><h2 id="内存屏障在-JVM-的应用"><a class="header-anchor" href="#内存屏障在-JVM-的应用">⚡</a>内存屏障在 JVM 的应用</h2><p>volatile 关键字的应用上面已经提到</p><h3 id="Atomic-的-LazySet"><a class="header-anchor" href="#Atomic-的-LazySet">⚡</a>Atomic 的 LazySet</h3><p>Atomic 下的 LazySet 操作。拿最常见的 AtomicInteger 为例，里面的状态 value 是个 volatile 的 int，普通的 set 就是将这个状态修改为目标值，修改后因为有 Barrier 的关系会让其它 CPU 可见。而 lazySet 与 set 对比是这样：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> </span>&#123;    value = newValue;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazySet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> </span>&#123;    unsafe.putOrderedInt(<span class="hljs-keyword">this</span>, valueOffset, newValue);&#125;</code></pre></div><p>对于 unsafe.putOrderedInt() 的内容 Java 完全没给出解释，但从添加 lazySet()这个功能的地方：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6275329" target="_blank" rel="noopener">Bug ID: JDK-6275329 Add lazySet methods to atomic classes</a>，能看出来其作用是在写入 volatile 状态前增加 StoreStore Barrier。它只保证本次写入不会重排到前面写入之前，但本次写入什么时候能刷写到内存是不做要求的，从而是一次轻量级的写入操作，在特定场景能优化性能。</p><h3 id="ConcurrentLinkedQueue-下的黑科技"><a class="header-anchor" href="#ConcurrentLinkedQueue-下的黑科技">⚡</a>ConcurrentLinkedQueue 下的黑科技</h3><p>比如现在有 a b c d 四个 volatile 变量，如果无脑执行:</p><div class="hljs"><pre><code class="hljs java">a = <span class="hljs-number">1</span>;b = <span class="hljs-number">2</span>;c = <span class="hljs-number">3</span>;d = <span class="hljs-number">4</span>;</code></pre></div><p>会在每个语句中间加上 Barrier。直接上面这样写可能还好，都是 StoreStore 的 Barrier，但如果写 volatile 之后又有一些读 volatile 操作，可能 Barrier 就会提升至最重的 StoreLoad Barrier，开销就会很大。而如果对开始的 a b c 写入都是用写普通变量的方式写入，只对最后的 d 用 volatile 方式更新，即只在 d = 4前带上写 Barrier，保证 d = 4 被其它 CPU 看见时，a、b、c 的值也能被别的 CPU 看见。这么一来就能减少 Barrier 的数量，提高性能。</p><p>上面介绍的 unsafe.putObject 的方法，用来将一个 volatile 变量以普通变量方式更新，即不使用 Barrier。用这个 putObject 就能做到上面提到的优化。</p><p>ConcurrentLinkedQueue 是 Java 标准库提供的<strong>无锁队列</strong>，它里面也用到了这个黑科技。因为是链表，所以里面有个叫 Node 的类用来存放数据，Node 连起来就构成链表。Node 内有个被 volatile 修饰的变量指向 Node 存放的数据。Node 的部分代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-keyword">volatile</span> E item;    <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;    Node(E item) &#123;        UNSAFE.putObject(<span class="hljs-keyword">this</span>, itemOffset, item);    &#125;    ....&#125;</code></pre></div><p>因为 Node 被构造出来后它得通过 cas 操作队尾 Node 的 next 引用接入链表，接入成功之后才需要被其它 CPU 看到，在 Node 刚构造出来的时候，Node 内的 item 实际不会被任何别的线程访问，所以看到 Node 的构造函数可以直接用 putObject 更新 item，等后续 cas 操作队列队尾 Node 的 next 时候再以 volatile 方式更新 next，从而带上 Barrier，更新完成后 next 的更新包括 Node 内 item 的更新就都被别的 CPU 看到了。从而减少操作 volatile 变量的开销。</p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识 -- Java 与多线程</title>
    <link href="/2020/12/13/Java-%E7%9F%A5%E8%AF%86-Java-%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2020/12/13/Java-%E7%9F%A5%E8%AF%86-Java-%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="实现线程的集中方式"><a class="header-anchor" href="#实现线程的集中方式">⚡</a>实现线程的集中方式</h2><p>实现线程主要有三种方式：使用内核线程实现（1：1实现），使用用户线程实现（1：N实现），使用用户线程加轻量级进程混合实现（N：M实现）</p><h3 id="内核级线程（1：1）"><a class="header-anchor" href="#内核级线程（1：1）">⚡</a>内核级线程（1：1）</h3><p>内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核（Multi-Threads Kernel）</p><h3 id="轻量级线程（1：1）（Java-使用的方式）"><a class="header-anchor" href="#轻量级线程（1：1）（Java-使用的方式）">⚡</a>轻量级线程（1：1）（Java 使用的方式）</h3><p>程序一般不会直接使用内核线程，而是使用内核线程的一种<strong>高级接口</strong>——轻量级进程（LightWeight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型, 对应了下图轻量级线程和内核线程的关系</p><p><img src="http://cdn.yinchao.tech/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" srcset="/img/loading.gif" alt="轻量级线程"></p><p>即一个轻量级线程对应一个内核线程，线程调度器通过调度内核线程从而来调度轻量级线程。</p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。</p><p>轻量级进程也具有它的局限性：</p><ol><li><p>首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。</p></li><li><p>其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的</p></li></ol><h3 id="用户线程（1：N）"><a class="header-anchor" href="#用户线程（1：N）">⚡</a>用户线程（1：N）</h3><p>广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程（User Thread，UT）的一种，因此从这个定义上看，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，因此效率会受到限制，并不具备通常意义上的用户线程的优点</p><p>狭义上的用户线程指的是完全建立在用户空间的<strong>线程库</strong>上，<strong>系统内核不能感知到用户线程的存在及如何实现的</strong>。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型，下图是进程和用户线程 1:N 的关系</p><p><img src="http://cdn.yinchao.tech/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B.png" srcset="/img/loading.gif" alt="用户线程"></p><p>用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。</p><p>线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如&quot;阻塞如何处理&quot;、“多处理器系统中如何将线程映射到其他处理器上”，这类问题解决起来将会异常困难，甚至有些是不可能实现的。</p><p>因为使用用户线程实现的程序通常都比较复杂，除了有明确的需求外（譬如以前在不支持多线程的操作系统中的多线程程序、需要支持大规模线程数量的应用），一般的应用程序都不倾向使用用户线程。Java、Ruby等语言都曾经使用过用户线程，最终又都放弃了使用它。但是近年来许多新的、以高并发为卖点的编程语言又普遍支持了用户线程，譬如Golang、Erlang等，使得用户线程的使用率有所回升</p><h3 id="混合实现（M-N）"><a class="header-anchor" href="#混合实现（M-N）">⚡</a>混合实现（M:N）</h3><p>线程还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，是 M：N 的关系, 下图就是用户线程与轻量级进程之间M：N的关系</p><p><img src="http://cdn.yinchao.tech/%E6%B7%B7%E5%90%88%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B.png" srcset="/img/loading.gif" alt="混合方式实现线程"></p><h2 id="Java-中的线程"><a class="header-anchor" href="#Java-中的线程">⚡</a>Java 中的线程</h2><p>以 hotspot 为例，它的每个线程都是直接映射到系统原生线程的，中间没有额外的间接结构，这样做的好处就是 JVM 不需要去管理线程的调度，全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</p><h3 id="Java-线程调度"><a class="header-anchor" href="#Java-线程调度">⚡</a>Java 线程调度</h3><p>分为两种，一种是<strong>协同式调度</strong>(线程运行多久由线程自己决定，当线程运行完毕，会告诉系统让它切换到另一个线程)另一种是<strong>抢占式调度</strong>(线程调度由系统决定)</p><p>协同式调度会出现 CPU 一直卡在线程这里一直运行的情况, 可能导致系统崩溃</p><p>抢占式调度线程只能让出自己的执行权限，想要抢占 CPU 时间片确是不可能了，但是可以另辟蹊径，使用线程优先级来做，但是说到线程优先级却无法完全保证线程优先运行，比如: windows 就存在&quot;优先级推进器(Priority Boosting)&quot;的功能，即使线程优先级最高也没用，这个功能的大致作用是一个线程被执行的特别频繁时，window可能会放弃正在运行的高优先级线程，转而去运行这个频繁被执行的线程。</p><p>并且 Java 的线程优先级也存在一个问题，那就是如果系统的优先级等级数量比较多，那么 Java 的优先级不会出现很多问题，但是如果系统的优先级只有1个(极端一点)，那么 Java 的所有优先级就一点用都没有了</p><h3 id="Java-线程的状态"><a class="header-anchor" href="#Java-线程的状态">⚡</a>Java 线程的状态</h3><p>new,runnable,waiting,time waiting,blocked,terminated</p><p>操作系统的线程状态：</p><p>新建、可运行、运行、阻塞、终止</p><p><a href="https://gitee.com/bangiao_admin/Concurrentcy/blob/master/%E7%AC%94%E8%AE%B0/01.Java%E5%92%8C%E7%BA%BF%E7%A8%8B.md" target="_blank" rel="noopener"></a></p><h2 id="Java-与协程"><a class="header-anchor" href="#Java-与协程">⚡</a>Java 与协程</h2><h3 id="协程的优势"><a class="header-anchor" href="#协程的优势">⚡</a>协程的优势</h3><ol><li><p><strong>切换、调度</strong>成本高昂</p><p>以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在每个请求本身的执行时间变得很短、数量变得很多的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。</p></li><li><p>系统能<strong>容纳的线程数量</strong>也很有限。</p><p>协程的优势主要在于它比LWP(Java 的线程——轻量级线程)要轻的多, 在64位Linux上HotSpot的线程栈容量默认是1MB，此外内核数据结构（Kernel Data Structures）还会额外消耗16KB内存, 而一个协程的栈通常在几百个字节到几KB之间，所以Java虚拟机里线程池容量达到两百就已经不算小了，而很多支持协程的应用中，同时并存的协程数量可数以十万计</p></li></ol><h2 id="协程的劣势"><a class="header-anchor" href="#协程的劣势">⚡</a>协程的劣势</h2><p>协程当然也有它的局限，需要在应用层面实现的内容（调用栈、调度器这些）特别多, 除此之外，协程在最初，甚至在今天很多语言和框架中会被设计成协同式调度，这样在语言运行平台或者框架上的调度器就可以做得非常简单, 但是这种方法存在很严重的问题。</p><p>具体到Java语言，还会有一些别的限制，譬如 HotSpot 这样的虚拟机，Java调用栈跟本地调用栈是做在一起的。如果在协程中调用了本地方法，还能否正常切换协程而不影响整个线程？另外，如果协程中遇传统的线程同步措施会怎样？譬如虽然 Kotlin 提供的协程实现，一旦遭遇 synchronize 关键字，那挂起来的仍将是整个线程</p><h2 id="协程的实现"><a class="header-anchor" href="#协程的实现">⚡</a>协程的实现</h2><p>不依赖虚拟机来实现协程是完全可能的，Kotlin 语言的协程就已经证明了这一点。</p><p>Quasar 协程库的实现原理是<strong>字节码注入</strong>，在字节码层面对当前被调用函数中的所有局部变量进行保存和恢复。这种不依赖Java虚拟机的现场保护虽然能够工作，但很影响性能，对即时编译器的干扰也非常大，而且必须要求用户手动标注每一个函数是否会在协程上下文被调用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识 -- CPU 硬件架构</title>
    <link href="/2020/12/13/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CPU-%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/12/13/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CPU-%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="CPU-硬件架构是什么样的"><a class="header-anchor" href="#CPU-硬件架构是什么样的">⚡</a>CPU 硬件架构是什么样的</h2><p><img src="http://cdn.yinchao.tech/CPU%20%E7%BB%93%E6%9E%84" srcset="/img/loading.gif" alt="CPU 结构"></p><p>CPU、Cache 以及内存间的简要交互过程：</p><p>CPU 读取数据时，首先从寄存器中查找，如果没有找到，则会到 L1 Cache 中查找，如果 L1 Cache 中没有，那么会到 L2 Cache 中查找，L3 Cache 同理，如果 CPU 中没有找到，那么才会到主存中查找。</p><p>而写入的时候，大部分 CPU 在写入数据时也会先写 Cache。其原因在于：</p><ol><li><p>一方面是因为新存数据很可能会被再次使用，新写数据先写 Cache 能提高缓存命中率；</p></li><li><p>另一方面 CPU 写 Cache 速度更快，从而写完之后 CPU 可以去干别的事情，能提高性能。</p></li></ol><p>CPU 写数据如果 Cache 命中了，则为了保持 Cache 和主存一致有两种策略。</p><ol><li><p>如果 CPU 写 Cache 每次都要更新主存，则称为 <code>Write-Through</code>，因为每次写 Cache 都伴随主存更新所以性能差，实际使用的也少；</p></li><li><p>写 Cache 之后并不立即写主存而是等待一段时间能积累一些改动后再更新主存的策略称为 <code>Write-Back</code>，性能更好但为了保证写入的数据不丢使机制更加复杂。采用 Write Back 方式被修改的内存再从 Cache 移出(比如 Cache 不够需要腾点空间)时，如果被修改的 Cache Line 还未写入主存需要在被移出 Cache 时更新主存，为了能分辨出哪些 Cache 是被修改过哪些没有，又需要增加一个新的标志位在 Cache Line 中去标识。</p></li></ol><p>CPU 写数据如果 Cache 未命中，则只能<strong>直接去更新主存</strong>。但更新完主存后又有两个选择，将刚修改的数据存入 Cache 还是不存。每次直接修改完主存都将主存被修改数据所在 Cache Line 存入 Cache 叫做 <code>Write-Allocate</code>。需要注意的是 Cache 存取的最小单位是 Cache Line。即使 CPU 只写一个字节，也需要将被修改字节所在附近 Cache Line 大小的一块内存完整的读入 Cache。如果 CPU 写主存的数据超过一个 Cache Line 大小，则不用再读主存原来内容，直接将新修改数据写入 Cache。相当于完全覆盖主存之前的数据。</p><p>L1 Cache 中：</p><ul><li><p>d-cache 缓存程序数据</p></li><li><p>i-cache 缓存指令数据(只读)</p></li></ul><p>L2、L3 Cache 不区分指令和程序数据，称为统一缓存</p><h2 id="CPU-具体是如何查找的"><a class="header-anchor" href="#CPU-具体是如何查找的">⚡</a>CPU 具体是如何查找的</h2><p>一个 Cache 由多个块(Cache Line)构成，查找的目标地址必须经过某种映射函数把主内存的地址定位到 Cache Line 中，这里有几种方案：</p><h3 id="直接映射"><a class="header-anchor" href="#直接映射">⚡</a>直接映射</h3><p>一个内存地址每次映射到固定的 Cache Line</p><p>读 Cache 时对内存地址进行哈希(通常是按照 Cache Line 数量取模，即在二进制地址中取中间位)来定位 Cache Line，写 Cache 时如果有冲突则丢掉老的数据。</p><p>缺点是内存地址大于 Cache Line 的范围，所以会有多个不同的内存地址映射到相同的 Cache 导致 Cache  淘汰换出频繁，可能不同的进程需要频繁的从主存中读取数据 Cache Line。</p><h3 id="全相联映射"><a class="header-anchor" href="#全相联映射">⚡</a>全相联映射</h3><p>内存地址可被的映射到任意的 Cache Line，读 Cache 时遍历整个 Cache Line 的地址，写 Cache 时，可以按照 LFU 或者 LRU 来淘汰旧的 Cache</p><p>优点是灵活，Cache 利用率高，冲突概率低，</p><p>缺点是设计和实现比较复杂，只适合小容量的 Cache 使用</p><h3 id="组相联映射"><a class="header-anchor" href="#组相联映射">⚡</a>组相联映射</h3><p>是上面两种办法的折中，将若干 Cache Line 分为 5个组，将目标地址分为t(标记位)，s(组索引)，b(块偏移)三个部分。组间直接映射，组内全相联。</p><p><img src="http://cdn.yinchao.tech/CPU%20cache%20mapping%20method.png" srcset="/img/loading.gif" alt="CPU cache mapping method"></p><p>B = 2^b</p><p>S = 2^s</p><p>现在来解释一下各个参数的意义：</p><p>一个 cache 被分为 S 个组，每个组有 E 个 Cache Line，而一个 Cache Line 中，有 B 个存储单元，现代处理器中，这个存储单元一般是以字节(通常8个位)为单位的，也是最小的寻址单元。因此，在一个内存地址中，中间的 s 位决定了该单元被映射到哪一组，而最低的 b 位决定了该单元在 Cache Line 中的偏移量。valid 通常是一位，代表该 Cache Line 是否是有效的(当该 Cache Line 不存在内存映射时，当然是无效的)。tag就是内存地址的高t位，因为可能会有多个内存地址映射到同一个 Cache Line 中，所以该位是用来校验该 Cache Line 是否是CPU要访问的内存单元。</p><p>当 tag 和 valid 校验成功时，我们称为 cache命中，这时只要将 cache 中的单元取出，放入CPU寄存器中即可。</p><p>当 tag 或 valid 校验失败的时候，就说明要访问的内存单元(也可能是连续的一些单元，如 int 占4个字节，double 占8个字节)并不在cache中，这时就需要去内存中取了，这就是 cache 不命中的情况(cache miss)。当不命中的情况发生时，系统就会从内存中取得该单元，将其装入 cache 中，与此同时也放入 CPU 寄存器中，等待下一步处理。</p><p>当 E=1 时， 每组只有一个 Cache Line。那么相隔 2^(s+b) 个单元的2个内存单元，会被映射到同一个 Cache Line 中。</p><p>当 1&lt;E&lt;C/B 时，每组有 E 个 Cache Line，不同的地址，只要中间 s 位相同，那么就会被映射到同一组中，同一组中被映射到哪个 Cache Line 中是依赖于替换算法的。</p><p>当 E=C/B，S=1 时，每个内存单元都能映射到任意的 Cache Line。带有这样cache的处理器几乎没有，因为这种映射机制需要昂贵复杂的硬件来支持。</p><h2 id="CPU-为什么这么设计"><a class="header-anchor" href="#CPU-为什么这么设计">⚡</a>CPU 为什么这么设计</h2><p>在 CPU 工作时直接使用寄存器中的数据，因为寄存器存在 CPU 的内部而且访问速度在内存设备中最快。</p><p>但是由于寄存器小，不能存放大量数据，且造价昂贵。所以数据一般存放在内存中，但是内存的访问速度太慢，导致CPU在处理指令时往往花费很多时间在等待内存做准备工作，所以在寄存器和内存之间又加入了缓存，缓存比较小，但访问速度比主内存快得多。</p><p>如果 CPU 总是访问内存中的同一址地的数据，此时缓存就可以把从内存提取的数据暂时保存起来，如果寄存器要取内存中同一位置的数据，直接从缓存中提取，无需直接从内存取。</p><p>需要注意的是，寄存器并不每次数据都可以从缓存中取得数据，万一不是同一个内存地址中的数据，那寄存器还必须直接绕过缓存从内存中取数据。所以并不每次都得到缓存中取数据，这种现象有个专业的名称叫做<strong>缓存的命中率</strong>，从缓存中取就命中，不从缓存中取从内存中取，就没命中，可见缓存命中率的高低也会影响CPU执行性能。</p><p>总而言之当一个 CPU 需要访问主存时，会先根据<strong>时间/空间局部性原理</strong>多读取一部分数据到CPU缓存(当然如果CPU缓存中存在需要的数据就会直接从缓存获取)，进而在读取CPU缓存到寄存器，当CPU需要写数据到主存时，同样会先刷新寄存器中的数据到CPU缓存，然后再把数据刷新到主内存中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
      <tag>hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识 -- drop、delete 和 truncate 的区别</title>
    <link href="/2020/12/13/MySQL-%E7%9F%A5%E8%AF%86-drop%E3%80%81delete-%E5%92%8C-truncate-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/12/13/MySQL-%E7%9F%A5%E8%AF%86-drop%E3%80%81delete-%E5%92%8C-truncate-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="drop"><a class="header-anchor" href="#drop">⚡</a>drop</h2><p>直接删除表</p><h2 id="truncate"><a class="header-anchor" href="#truncate">⚡</a>truncate</h2><p>直接删除表的数据</p><h2 id="delete"><a class="header-anchor" href="#delete">⚡</a>delete</h2><p>删除表的数据，可以添加 where 字句</p><h2 id="区别"><a class="header-anchor" href="#区别">⚡</a>区别</h2><ol><li><p>删除效果不同。</p><ol><li><p>delete 是一行行删除表的数据</p></li><li><p>truncate 是一次性从表中删除所有的数据，删除时不会激活与表有关的触发器</p></li><li><p>drop 不仅删除数据也会删除表结构，删除时，相关的约束、触发器、索引、存储过程会被保留，但是状态会变为 invalid</p></li></ol></li><li><p>应用范围不同。</p><ol><li><p>truncate 只能使用于 table ，而 delete 和 drop 可以用于 table 和 view</p></li><li><p>对于由 FOREIGN KEY 约束引用的表，不能使用  truncate，而应使用不带 where 子句的 delete 语句。</p></li></ol></li><li><p>所属级别不同。</p><ol><li><p>delete 语句为 DML(Data Manipulation Language，数据操作语言，是对如和操作某些数据而言的)，操作会被放到 rollback segment 中，事务提交才生效，如果有触发器 trigger 也会被触发。</p><p>删除时，同时将该行的删除操作作为事务，记录在日志中保存，可以回滚</p></li><li><p>truncate 和 drop 都是 DLL(Data Define Language，数据定义语言，是对数据库和数据表的定义而言的)，</p><p>删除时，不会把删除操作记录记入日志保存，删除不可通过回滚恢复</p></li></ol></li><li><p>删除速度不同</p><p>一般来说 drop &gt; truncate &gt; delete</p></li><li><p>自增标识。</p><p>truncate 新行标识所用的计数值重置为该列的种子。delete 则会保留原有的标识计数值。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识 -- 对象的 hashcode</title>
    <link href="/2020/12/12/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1%E7%9A%84%20hashcode/"/>
    <url>/2020/12/12/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1%E7%9A%84%20hashcode/</url>
    
    <content type="html"><![CDATA[<h2 id="方法流程"><a class="header-anchor" href="#方法流程">⚡</a>方法流程</h2><p>hashCode 有时会被误认为返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。</p><!-- more --><p>java.lang.Object#hashCode()方法是 native 方法，最终会调用 ObjectSynchronizer::FastHashCode 方法获取hashcode，Hot Spot 虚拟机执行流程如下:</p><p><img src="http://cdn.yinchao.tech/java_object_hashCode.jpg" srcset="/img/loading.gif" alt="java_object_hashCode"></p><p>具体到计算hashcode时，会涉及到 <code>get_next_hash</code> 方法（在 synchronizer.cpp 中，用于计算新的 hashcode）和 <code>hash</code> 方法（在 markOop.hpp 中，用于获取已有的 hashcode）</p><p>其中，<code>hash</code> 方法的实现是先获取该对象的标记字对象，然后对该标记字对象的的地址做位移和逻辑与操作，以结果作为hashcode</p><p>而 <code>get_next_hash</code> 方法会根据传给 JVM 的参数 <code>-XX:hashCode=n</code> 来选择使用哪种方法生成对象的hashcode：</p><ul><li>hashCode=0，使用系统生成的随机数作为hashcode</li><li>hashCode=1，对对象地址做移位和逻辑操作，生成 hashcode</li><li>hashCode=2，所有的hashcode都等于1</li><li>hashCode=3，用一个自增序列给hashcode赋值</li><li>hashCode=4，以对象地址作为hashcode</li><li>hashCode=其他，复杂的位操作</li></ul><blockquote><p>所以，其实 hashCode() 方法和 JVM 具体实现甚至与用户的参数设置有关，除了和地址相关之外，还有使用随机数，自增序列的选择</p></blockquote><p>hashcode 默认存储在对象的对象头</p><p><img src="http://cdn.yinchao.tech/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" srcset="/img/loading.gif" alt="对象头"></p><p>hashcode 默认存储在对象的对象头，但是 ⬇</p><h2 id="注意"><a class="header-anchor" href="#注意">⚡</a>注意</h2><ol><li><p>hashcode 采用延迟加载的方式生成。只有调用 hashCode() 方法时，才会写入对象头。若一个类的 hashCode() 方法被<strong>重写</strong>，对象头中将<strong>不存储</strong> hashcode 信息。</p></li><li><p>当该对象的锁状态不是默认状态时，对象的 hashcode 不存储在对象头</p><p>当是轻量级锁/重量级锁时，JVM 会将对象的 Mark Word 复制一份到栈帧的 Lock Record 中。等线程释放该对象时，再重新复制给对象。</p></li><li><p>如果一个对象头中存在 hashcode,则无法使用偏向锁。</p><p>综合上面两条，即：如果在锁对象加锁前计算了 hashCode ，且 hashCode 方法没有被重写，那么会把 hashCode 存储到 Mark Word 中，加锁时因为无法存放线程 id (偏向锁)或锁记录地址(轻量级锁)，不会使用偏向锁</p><p>但是会使用轻量级锁。(如上面所说，把 Mark Word 复制到栈帧的 Lock Record 中)</p></li></ol><h2 id="问题"><a class="header-anchor" href="#问题">⚡</a>问题</h2><ol><li><p>hashCode 既然可以生成为什么要放在对象头里？</p><p>因为当一个对象的 hashCode() 方法<strong>未被重写</strong>时，调用这个方法可能会返回一个由随机数算法生成的值。因为一个对象的 hashCode 不可变，所以需要存到对象头中。当再次调用该方法时，会直接返回对象头中的 hashCode，而如果不存储这个 hashCode，同一对象每次调用 hashCode 方法得到的值就都会不相同。</p></li></ol><h2 id="String-实现-hashCode-方法"><a class="header-anchor" href="#String-实现-hashCode-方法">⚡</a>String 实现 hashCode 方法</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> h = hash;    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">char</span> val[] = value;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;            h = <span class="hljs-number">31</span> * h + val[i];        &#125;        hash = h;    &#125;    <span class="hljs-keyword">return</span> h;&#125;</code></pre></div><p>可以看出，相同的字符串调用hashCode()方法，得到的值是一样的，与内存地址、进程、机器无关。代码似乎很简单，但是一定要归纳出来他的实现过程。<br>hash = val[0]*31<sup>{n-1}+val[1]*31</sup>{n-2}+…+val[n-1]<br>注：n为字符串长度。</p><p>如果字符串相等，hashcode 必然一样；如果 hashcode 一样，字符串不一定相等，因为计算时可能发生溢出。</p><ul><li><p>为什么计算时选择31？</p><ul><li><p>31是个奇质数，不大不小，一般质数非常适合hash计算，偶数相当于移位运算，容易溢出，数据信息丢失。如果太小，则产生的哈希值区间小；太大则容易溢出，数据信息丢失。</p></li><li><p>31 * i == (i &lt;&lt; 5) - i 。非常易于维护，将移位代替乘除，会有性能的提升，并且JVM执行时能够自动优化成这个样子。</p></li><li><p>通过实验计算，选用31后出现hash冲的概率相比于其他数字要小</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识 -- 对象初始化过程</title>
    <link href="/2020/12/11/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <url>/2020/12/11/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ol><li><p>加载字节码中的文件到内存中的方法区</p><p>虚拟机遇到 new 指令,首先去检查 new 指令的参数是否能在常量池中定位到一个类的符号引用,并且这个符号引用代表的类是否已被加载,解析和初始化过</p><p>如果没有,那么先执行相应的类加载过程</p></li><li><p>初始化 static 相关的成员变量和静态方法,称为<strong>类初始化</strong>(全部都在方法区)</p><ol><li><p>先把所有的 static 部分(成员与方法)申请空间,然后再给每一个 static 成员由上至下分配初始值</p></li><li><p>分配完空间之后,会有默认值,而不是指定的值</p></li><li><p>这时才执行显式赋值,静态代码块对变量进行赋值,执行顺序与代码一致</p></li></ol></li><li><p>通过 new 在堆内存中申请对象的内存空间,取得首地址</p><p>在类加载检查通过后,要创建的对象所需的内存大小已经确定了,虚拟机将一块确定大小的内存从堆中划分出来分配给对象</p><p>假设堆中所有用过的内存放在一边,空闲的内存放在另外一边,中间放一个指针作为分界点的指示器,那分配内存就是移动这个指针的过程,这种内存分配方式叫&quot;指针碰撞&quot;</p><p>但如果堆中的内存,空闲的和使用过的是交互相错的,不是规整的,那么虚拟机必须维护一个队列,记录哪些内存块是可用的,分配的时候,查找表找到一块足够大的空间划分给对象,并更新表信息,这种方式叫&quot;空闲列表&quot;</p><p>选择哪种分配方式是由堆是否规整决定的,而Java堆是否规则是由所采用的垃圾收集器是否带有压缩整理功能决定的</p><ul><li><p>还需要考虑的一个问题是,在虚拟机中创建对象是否是一个非常频繁的行为</p><p>即便是采用&quot;指针碰撞&quot;的方式,在并发的情况下,修改指针也不是线程安全的</p><p>对于这个问题,有两种解决方法:</p><ol><li><p>第一,对分配内存空间的操作进行同步处理 – 实际上虚拟机采用 CAS 加自旋的方式保证了更新操作的原子性</p></li><li><p>第二,每个线程在堆中预先分配一小块内存,叫本地线程分配缓冲(TLAB)</p><p>哪个线程要分配内存,就在哪个线程的 TLAB 上分配,只有 TLAB 用完并分配新的 TLAB 时,才需要同步锁定</p><p>内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头),如果使用 TLAB,这一过程也可以提前至 TLAB 分配时进行</p><p>这一操作保证了对象的实例字段在 Java 代码中可以不赋初始值就可以直接使用,程序能访问到这些字段的数据类型所对应的零值</p></li></ol></li></ul></li><li><p>接下来,虚拟机要对对象进行必要的设置,例如这个对象属于哪个类,如何才能找到类的元数据信息,对象的哈希码,对象的 GC 分代年龄等信息</p></li></ol><p>到现在为止,从 JVM 的角度来看,一个新的对象已经产生了</p><p>但从 Java 程序来看,还需要对其执行 init 方法,所有字段都还是零值</p><p>一般来说,执行 new 指令之后会接着执行 init 方法,把对象安照程序员的意愿进行初始化</p><ol><li><p>构造方法压栈,依次执行以下的操作</p><ol><li><p>把类的非静态成员变量加载到堆内存中并分配空间同时默认初始化,非静态成员方法加载到方法区中并分配空间,然后由上到下进行非静态成员变量的初始化</p></li><li><p>用构造代码块和显示赋值对成员变量进行赋值,执行顺序与代码顺序一致</p></li><li><p>执行构造函数</p></li></ol></li><li><p>整个对象初始化完成，返回首地址值</p></li></ol><p>如果有父类,则:</p><p>先进行父类静态初始化,然后进行子类静态初始化(加载类文件的先后)</p><p>在堆内存空间分配完毕后,然后父类对象初始化,在进行子类对象初始化</p><p>(堆内存的创建,在父类对象的基础上加东西变成子类对象)</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识 -- 锁</title>
    <link href="/2020/12/11/Java%20%E7%9F%A5%E8%AF%86-%E9%94%81/"/>
    <url>/2020/12/11/Java%20%E7%9F%A5%E8%AF%86-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.yinchao.tech/Java%20%E4%B8%AD%E7%9A%84%E9%94%81.png" srcset="/img/loading.gif" alt="Java 中的锁"></p><ol><li><p>ReentrantLock</p><p>大部分 JDK 级别加锁+CAS(CPU指令,非常快)</p><p>只有在资源竞争,加锁失败的情况下,release CPU,才会阻塞线程</p><p>非公平</p></li><li><p>synchronize</p><ul><li><p>JDK 1.6 以前直接更改操作系统 -&gt; JDK 1.6 以后,首先通过对象头里面存储锁状态标识,升级为重量锁之后才调用操作系统代码</p></li><li><p>加锁过程:</p><ol><li><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态 ( <code>101</code>)（锁标志位为“01”状态，能否偏向为“1”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如图2.1所示。</p></li><li><p>拷贝对象头中的Mark Word复制到锁记录中。</p></li><li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。</p></li><li><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图2.2所示。</p></li><li><p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</p></li></ol></li></ul><p>偏向锁会记录当前线程 id</p><p>但是轻量锁不会记录</p><ul><li><p>偏向锁膨胀为轻量锁的条件:</p><ol><li><p>001 不可能偏向 -&gt; 000 升级为轻量锁</p></li><li><p>线程交替运行</p></li></ol></li><li><p>锁的膨胀一般是不可逆的</p><p>可逆和epoch有关</p></li></ul><p>对象锁和类锁是不一样的</p><p>对象在堆上,类信息则在方法区</p><p>所以 new 多个类,多个实例同时访问各自的对象锁就无效</p><p>例如:</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span></code></pre></div><p>但是如果是类锁就不是这样的,</p></li></ol><hr><p>对象头</p><div class="hljs"><pre><code class="hljs gherkin">|<span class="hljs-string">       锁        </span>|<span class="hljs-string">                       62位                      </span>|<span class="hljs-string">锁状态</span>|<span class="hljs-string">                                     </span>|<span class="hljs-string">                           过程                        </span>|<span class="hljs-string">锁状态</span>||<span class="hljs-string">    无锁可偏向    </span>|<span class="hljs-string">          unused:57         </span>|<span class="hljs-string"> u1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string">   1   </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> klass word (64,如果开启了指针压缩就是32) </span>|<span class="hljs-string">                        默认初始状态                     </span>|<span class="hljs-string"> 101 </span>||<span class="hljs-string">   无锁不可偏向   </span>|<span class="hljs-string">  unused: 25 </span>|<span class="hljs-string"> hashcode:31  </span>|<span class="hljs-string"> u1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string">   0   </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string">               klass word             </span>|<span class="hljs-string">  计算了hashcode,保存了hashcode,但是没有地方存偏向锁的线程id了 </span>|<span class="hljs-string"> 001 </span>||<span class="hljs-string"> 有偏向锁,已经偏向 </span>|<span class="hljs-string"> thread(线程id): 54</span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> u1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string">   1   </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string">               klass word             </span>|<span class="hljs-string">            默认状态到偏向锁状态,没有计算hashcode           </span>|<span class="hljs-string"> 101 </span>||<span class="hljs-string">      轻量锁     </span>|<span class="hljs-string">     ptr_to_lock_record(指向栈中锁记录的指针):62     </span>|<span class="hljs-string"> 00 </span>|<span class="hljs-string">               klass word             </span>|<span class="hljs-string">          线程交替执行,或者由无锁不可偏向状态升级而来          </span>|<span class="hljs-string"> 000 </span>||<span class="hljs-string">      重量锁     </span>|<span class="hljs-string"> ptr_to_heavyweight_monitor(指向重量锁记录的指针):62 </span>|<span class="hljs-string"> 10 </span>|<span class="hljs-string">               klass word             </span>|<span class="hljs-string"> 轻量锁抢锁失败,自旋锁自旋一段时间,如果还是抢锁失败则会变成重量锁 </span>|<span class="hljs-string"> ?10 </span>|</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--对象头</title>
    <link href="/2020/12/11/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1%E5%A4%B4/"/>
    <url>/2020/12/11/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1%E5%A4%B4/</url>
    
    <content type="html"><![CDATA[<p><code>对象布局</code> =  对象头(16个byte=128bit) + 实例数据 + 对齐填充 (变成8的倍数)</p><p><code>对象头</code> = mark word(64bit) + klass pointer(64bit)</p><p><code>klass pointer</code>:指针指向元空间中保存类的模板信息的地址</p><blockquote><p>object header</p><p>Common structure at the beginning of every GC-managed heap object. (Every oop points to an object header.) Includes fundamental information about the heap object’s layout, type(类型), GC state (垃圾回收状态), synchronization state (同步状态), and identity hash code (hash code). Consists of two words(字长)(字长和机器有关,64位机字长就是64位). In arrays it is immediately followed by a length field. Note that both Java objects and VM-internal objects have a common object header format.</p><p>在每个gc管理的堆对象开始处的公共结构。(每个oop都指向一个对象头)。包括基本信息堆对象的布局、类型,GC状态,同步状态,和哈希值。对象头由两个 word (字长)(字长和机器有关,64位机字长就是64位)。在数组对象中，紧随其后的是长度字段。注意，Java 对象和 JVM 内部对象都有一个通用的对象头格式。</p></blockquote><p><img src="http://cdn.yinchao.tech/Java%20%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpeg" srcset="/img/loading.gif" alt="Java 对象头"></p><p><code>oop</code>: Ordinary Object Pointer，就是普通对象指针。</p><p>启用CompressOops后，会压缩的对象：</p><ul><li><p>每个Class的属性指针（静态成员变量）；</p></li><li><p>每个对象的属性指针；</p></li><li><p>普通对象数组的每个元素指针。</p></li></ul><div class="hljs"><pre><code class="hljs gherkin">|<span class="hljs-string">--------------------------------------------------------------------------------------------------------------</span>||<span class="hljs-string">                                              Object Header (128 bits)                                        </span>||<span class="hljs-string">--------------------------------------------------------------------------------------------------------------</span>||<span class="hljs-string">                        Mark Word (64 bits)                                    </span>|<span class="hljs-string">      Klass Word (64 bits)    </span>|<span class="hljs-string">       </span>|<span class="hljs-string">--------------------------------------------------------------------------------------------------------------</span>||<span class="hljs-string">  unused:25 </span>|<span class="hljs-string"> identity_hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1 </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">   无锁 01</span>|<span class="hljs-string">----------------------------------------------------------------------</span>|<span class="hljs-string">--------</span>|<span class="hljs-string">------------------------------</span>||<span class="hljs-string">  thread:54 </span>|<span class="hljs-string">         epoch:2      </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1 </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">  偏向锁 01</span>|<span class="hljs-string">----------------------------------------------------------------------</span>|<span class="hljs-string">--------</span>|<span class="hljs-string">------------------------------</span>||<span class="hljs-string">                     ptr_to_lock_record:62                            </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">  轻量锁 00</span>|<span class="hljs-string">----------------------------------------------------------------------</span>|<span class="hljs-string">--------</span>|<span class="hljs-string">------------------------------</span>||<span class="hljs-string">                     ptr_to_heavyweight_monitor:62                    </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">  重量锁 10</span>|<span class="hljs-string">----------------------------------------------------------------------</span>|<span class="hljs-string">--------</span>|<span class="hljs-string">------------------------------</span>||<span class="hljs-string">                                                                      </span>|<span class="hljs-string"> lock:2 </span>|<span class="hljs-string">     OOP to metadata object   </span>|<span class="hljs-string">    GC 11</span>|<span class="hljs-string">--------------------------------------------------------------------------------------------------------------</span>|</code></pre></div><p><img src="http://cdn.yinchao.tech/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" srcset="/img/loading.gif" alt="对象头"></p><p>注意:</p><ol><li><p>为什么要这么实现？</p><p>因为对象头信息是跟对象自身定义的数据结构无关的。这些信息所记录的状态是用于JVM对对象的管理的。更重要的是，不同状态的存储内容基本上是互斥的。所以基于节省空间的角度考虑，Mark Word 被设计成动态的。</p></li><li><p>JVM 默认大端存储</p><p>可以使用 jol 打印对象信息,不过注意,JVM默认是<code>大端存储</code>,所以注意顺序是锁标志位在输出的第一个八位数据的最后两位</p><p>例如:00000101 是打印的第一个字节,其中最后的<code>101</code>表示偏向锁</p></li><li><p>当对象的状态不是默认状态时，对象的hashcode不存储在对象头</p><p>当是轻量级锁/重量级锁时，JVM 会将对象的 mark word 复制一份到栈帧的 Lock Record 中。等线程释放该对象时，再重新复制给对象。</p></li><li><p>如果一个对象头中存在 hashcode，则无法使用偏向锁。</p><p>即：如果在锁对象加锁前计算了 hashCode ，且 hashCode 方法没有被重写，那么会把 hashCode 存储到 Mark Word 中，加锁不会使用偏向锁，而是轻量级锁。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识 -- volatile</title>
    <link href="/2020/12/10/Java-%E7%9F%A5%E8%AF%86-volatile/"/>
    <url>/2020/12/10/Java-%E7%9F%A5%E8%AF%86-volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="特性"><a class="header-anchor" href="#特性">⚡</a>特性</h2><p>volatile 关键字可以实现并发编程中的<code>有序性</code>和<code>可见性</code>，但是无法保证<code>原子性</code></p><p>volatile 关键字首先具有&quot;易变性&quot;，声明为 volatile 变量编译器会强制要求读内存，相关语句不会直接使用上一条语句对应的的寄存器内容，而是重新从内存中读取。</p><p>其次具有&quot;不可优化性&quot;，volatile 告诉编译器，不要对这个变量进行各种激进的优化，甚至将变量直接消除，保证代码中的指令一定会被执行。</p><p>最后具有&quot;顺序性&quot;，能够保证 volatile 变量间的顺序性，编译器不会进行乱序优化。不过要注意与非 volatile 变量之间的操作，还是可能被编译器重排序的。</p><p>需要注意的是其含义跟原子操作无关，比如：volatile int a; a++; 其中 a++ 操作实际对应三条汇编指令实现”读-改-写“操作（RMW），并非原子的。</p><p>volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，是因为它需要在写入之后加入的 StoreLoad 这个内存屏障的性能开销特别大。</p><h2 id="使用场景"><a class="header-anchor" href="#使用场景">⚡</a>使用场景</h2><ul><li><p>DCL单例</p></li><li><p>标志位</p></li><li><p>并发集合 ConcurrentHashMap 中 table 数组和 Node 节点中的 val 和 next 数据成员</p></li></ul><h2 id="实现原理"><a class="header-anchor" href="#实现原理">⚡</a>实现原理</h2><p>Java 语言中 volatile 变量可以被看作是一种轻量级的同步，因为其还附带了 acquire 和 release 语义。实际上也是从 JDK5 以后才通过这个措施进行完善，其 volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。</p><p>在 Java 程序运行的时候，即 JVM 执行 volatile 变量的时候动态的处理：</p><ul><li><p>在每个volatile写操作的前面插入一个StoreStore屏障。</p></li><li><p>在每个volatile写操作的后面插入一个StoreLoad屏障。</p></li><li><p>在每个volatile读操作的<strong>后</strong>面插入一个LoadLoad屏障。</p></li><li><p>在每个volatile读操作的后面插入一个LoadStore屏障。</p></li></ul><p><img src="http://cdn.yinchao.tech/JVM%20%20volatile%20%E5%8A%A0%E5%85%A5%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="JVM  volatile 加入内存屏障图"></p><h3 id="内存屏障又是在哪里加入进来的呢？"><a class="header-anchor" href="#内存屏障又是在哪里加入进来的呢？">⚡</a>内存屏障又是在哪里加入进来的呢？</h3><p>JVM 级别或者说是编译器级别的内存屏障</p><p><img src="http://cdn.yinchao.tech/JVM-memory-barrier1" srcset="/img/loading.gif" alt="JVM-memory-barrier1"></p><p><img src="http://cdn.yinchao.tech/JVM-memory-barrier2" srcset="/img/loading.gif" alt="JVM-memory-barrier"></p><p><img src="http://cdn.yinchao.tech/JVM-memory-barrier3" srcset="/img/loading.gif" alt="JVM-memory-barrier"></p><p><img src="http://cdn.yinchao.tech/JVM-memory-barrier4" srcset="/img/loading.gif" alt="JVM-memory-barrier"></p><p><img src="http://cdn.yinchao.tech/JVM-memory-barrier5" srcset="/img/loading.gif" alt="JVM-memory-barrier"></p><p>CPU 提供了三种内存屏障系统原语:</p><ul><li><p>sfence</p></li><li><p>mfence</p></li><li><p>lfence</p></li></ul><p>实际上 volatile 底层没有使用 CPU 的原语，原因是：不是大多数 CPU 都支持的上面的系统指令</p><p>volatile 关键字<strong>写入的时候</strong>才使用 Lock 指令的原因是：大多数 CPU 都支持</p><p>同理，volatile 关键字在读取的时候没有直接使用 CPU 的原语的原因也是可能会跨平台而不支持的问题，所以在 C++ 层面处理</p><ol><li><p>首先这是在写入 volatile 变量之后才会加入 lock指令</p><p>Java 语言中由 volatile 修饰的变量，赋值后多执行了一个&quot;load addl $0x0, (%esp)&quot; 操作，这个操作相当于一个 lock 指令</p><p>根据 Intel x64 CPU 官方文档：</p><blockquote><p>Intel® 64 and IA-32 Architectures Software Developer’s Manual</p><p>8.1.2.2 Software Controlled Bus Locking</p><p>For the P6 family processors, locked operations serialize all outstanding load and store operations (that is, wait for them to complete). This rule is also true for the Pentium 4 and Intel Xeon processors, with one exception. Load operations that reference weakly ordered memory types (such as the WC memory type) may not be serialized.</p></blockquote><p>其中</p><blockquote><p>locked operations serialize all outstanding load and store operations</p></blockquote><p>说明其实LOCK指令前缀包含了MFENCE的效果，而MFENCE保证插入StoreLoad</p><p>而具体的内存屏障的种类由执行这段程序的 CPU 硬件决定</p><p><a href="https://www.menina.cn/article/97" target="_blank" rel="noopener">出处</a></p><p>Lock 指令有两种实现方式：</p><ol><li><p>如果是现代 CPU 并且数据已经被CPU缓存了，并且是要写回到主存的，则可以用cache locking处理问题。</p><p>Intel使用&quot;Cache Locking&quot;机制，其实质是 Ringbus + MESI协议。</p><p>其步骤是：若干个CPU核心通过ringbus连到一起。每个核心都维护自己的Cache的状态。如果对于同一份内存数据在多个核里都有 cache，则状态都为S（shared）。一旦有一核心改了这个数据（状态变成了M），其他核心就能瞬间通过ringbus感知到 这个修改，从而把自己的cache状态变成I（Invalid），并且从标记为M的cache中读过来。同时，这个数据会被原子的写回到主存。最终，cache的状态又会变为S。</p><p>这相当于给cache本身单独做了一套总线（要不怎么叫ring bus），避免了真的锁总线。</p></li><li><p>第一种条件不满足，那么还是得锁总线。</p></li></ol><p>因此，lock到底用锁总线，还是用cache locking，完全是看当时的情况。当然能用后者的就肯定用后者。</p></li><li><p>对于 volatile 读来说</p><p><img src="http://cdn.yinchao.tech/JVM-memory-barrier6" srcset="/img/loading.gif" alt="JVM-memory-barrier"></p><p><img src="http://cdn.yinchao.tech/JVM-memory-barrier7" srcset="/img/loading.gif" alt="JVM-memory-barrier"></p><p>而 obj-&gt;obj_field_acquire(field_offset) 放法实际上就是：</p> <div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> jint <span class="hljs-title">OrderAccess::load_acquire</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> jint* p)</span> </span>&#123; <span class="hljs-keyword">return</span> *p; &#125;</code></pre></div><p>读取实际上是基于 C++ 的 volatile 实现</p><p><a href="https://juejin.cn/post/6844903555850059790" target="_blank" rel="noopener">出处</a></p></li></ol><h2 id="volatile-使用条件"><a class="header-anchor" href="#volatile-使用条件">⚡</a>volatile 使用条件</h2><p>Java实践中仅满足下面这些条件才应该使用volatile关键字：</p><ol><li><p>变量写入操作不依赖变量当前值，或确保只有一个线程更新变量的值</p></li><li><p>该变量不会与其他变量一起纳入</p></li><li><p>变量并未被锁保护</p></li></ol><h2 id="注意"><a class="header-anchor" href="#注意">⚡</a>注意</h2><ol><li><p>错误：volatile 读取之前在读取之前加入读屏障刷新到主存，volatile 写之后加入写屏障刷入到主存</p><p>首先，这里加入内存屏障的位置其实恰好相反，写入是在写入之前加入屏障禁止指令重排，读取也是在读取之后加入内存屏障来禁止指令重排</p><p>其次，从缓存刷入到主存并不是由内存屏障去处理的，这是通过 MESI 协议决定的，内存屏障仅仅只是决定 Store Buffer 刷入 Cache Line</p><p>这个其实很好理解，CPU 使用数据是必须是在 Cache Line 或者寄存器里面，那直接刷入内存其实没有意义，因为要读取的时候还是需要从内存当中去读数据到 Cache Line，而真正的刷入主存的意思应该是刷入到 JMM 意义上的主存（即 CPU 的 Cache Line 或者寄存器），这样才能保证变量的可见性</p></li><li><p>对于 volatile 变量的读写，在字节码其实并不能体现出来，只是在字节码标记 volatile 变量，而真正起作用是在字节码转化为汇编指令的时候根据 CPU 的特性来加入内存屏障</p></li><li><p>volatile 读取的免费的吗？</p><p>不是。因为它会禁止指令重排，以及禁止其它的各种的优化</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 知识 -- Redis 持久化方式</title>
    <link href="/2020/11/21/Redis-%E7%9F%A5%E8%AF%86-Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/11/21/Redis-%E7%9F%A5%E8%AF%86-Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="RDB"><a class="header-anchor" href="#RDB">⚡</a>RDB</h2><p>RDB 持久化是指在指定的<code>时间间隔</code>内将内存中的数据集快照写入磁盘</p><p>实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><h2 id="AOF"><a class="header-anchor" href="#AOF">⚡</a>AOF</h2><p>AOF 持久化以<code>日志</code>的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录。</p><p>对于 AOF 方式，Redis 中提供了3种<code>同步策略</code>：每秒同步、每修改同步和不同步。</p><ol><li><p>每秒同步，异步完成，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会<strong>丢失</strong>。</p></li><li><p>每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。这种方式在<strong>效率上是最低</strong>的。</p></li><li><p>不同步，如名</p></li></ol><h2 id="区别"><a class="header-anchor" href="#区别">⚡</a>区别</h2><h3 id="RDB-v2"><a class="header-anchor" href="#RDB-v2">⚡</a>RDB</h3><h4 id="优势"><a class="header-anchor" href="#优势">⚡</a>优势</h4><ol><li><p><code>文件备份</code>，<code>故障恢复</code>。整个 Redis 数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的将这个 RDB 文件载入进行恢复。</p></li><li><p><code>IO 性能最大化</code>。对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p></li><li><p><code>载入效率</code>。相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p></li></ol><h4 id="劣势"><a class="header-anchor" href="#劣势">⚡</a>劣势</h4><ol><li><p><code>宕机数据丢失</code>。如果保证最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p></li><li><p><code>数据太大STW</code>。由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p></li></ol><h3 id="AOF-v2"><a class="header-anchor" href="#AOF-v2">⚡</a>AOF</h3><h4 id="优势-v2"><a class="header-anchor" href="#优势-v2">⚡</a>优势</h4><ol><li><p><code>宕机数据丢失少</code>。由于该机制对日志文件的写入操作采用的是 append 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 redis-check-aof 工具来帮助我们解决数据一致性的问题。</p></li><li><p><code>重写机制</code>。如果日志过大，Redis 可以自动启用 rewrite 机制。即 Redis 以 append 模式不断的将修改数据写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行 rewrite 切换时<strong>可以更好的保证数据安全性</strong>。</p><p>AOF 重写机制可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</p></li><li><p><code>格式可读</code>。AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</p></li></ol><h4 id="劣势-v2"><a class="header-anchor" href="#劣势-v2">⚡</a>劣势</h4><ol><li><p><code>文件大小更大</code>。对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p></li><li><p><code>效率</code>。根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-知识-过期时间设置及过期数据删除、内存淘汰策略</title>
    <link href="/2020/11/21/Redis-%E7%9F%A5%E8%AF%86-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%E5%8F%8A%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E3%80%81%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <url>/2020/11/21/Redis-%E7%9F%A5%E8%AF%86-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%E5%8F%8A%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E3%80%81%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="几种过期时间设置-api"><a class="header-anchor" href="#几种过期时间设置-api">⚡</a>几种过期时间设置 api</h2><ol><li><p>EXPIRE <key> <ttl> ：表示将键 key 的生存时间设置为 ttl 秒。</p></li><li><p>PEXPIRE <key> <ttl> ：表示将键 key 的生存时间设置为 ttl 毫秒。</p></li><li><p>EXPIREAT <key> <timestamp> ：表示将键 key 的生存时间设置为 timestamp 所指定的秒数时间戳。</p></li><li><p>PEXPIREAT <key> <timestamp> ：表示将键 key 的生存时间设置为 timestamp 所指定的毫秒数时间戳。</p></li></ol><p>注: 在 Redis 内部实现中，前面三个设置过期时间的命令最后都会转换成最后一个 PEXPIREAT 命令来完成。</p><p>当我们设置一个键的过期时间时，Redis 就会将该键带上过期时间存放到一个<code>过期字典</code>中。</p><p>当我们查询一个键时，Redis 便首先检查该键是否存在过期字典中，如果存在，那就获取其过期时间。然后将过期时间和当前系统时间进行比对，比系统时间大，那就没有过期；反之判定该键过期。</p><h2 id="过期删除策略"><a class="header-anchor" href="#过期删除策略">⚡</a>过期删除策略</h2><h3 id="定时删除"><a class="header-anchor" href="#定时删除">⚡</a>定时删除</h3><p>在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。</p><p>优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。</p><p>缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。</p><h3 id="惰性删除"><a class="header-anchor" href="#惰性删除">⚡</a>惰性删除</h3><p>设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。</p><p>优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</p><p>缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。</p><h3 id="定期删除"><a class="header-anchor" href="#定期删除">⚡</a>定期删除</h3><p>每隔一段时间，我们就对一些key进行检查，删除里面过期的key。</p><p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p><p>缺点：难以确定删除操作执行的时长和频率。</p><p>如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。</p><p>如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。</p><p>另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。</p><h3 id="Redis-使用的删除策略"><a class="header-anchor" href="#Redis-使用的删除策略">⚡</a>Redis 使用的删除策略</h3><p>Redis 的过期删除策略是：惰性删除和定期删除两种策略配合使用。</p><p>所有键读写命令执行之前都会调用 expireIfNeeded 函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。</p><p>检查函数以一定的频率运行，每次运行时，都从<strong>一定数量</strong>的数据库中取出<strong>一定数量</strong>的<strong>随机键</strong>进行检查，并删除其中的过期键。</p><p>注意：并不是一次运行就检查所有的库，所有的键，而是随机检查一定数量的键。</p><h2 id="不同持久化方式和主从模式删除过期键流程"><a class="header-anchor" href="#不同持久化方式和主从模式删除过期键流程">⚡</a>不同持久化方式和主从模式删除过期键流程</h2><h3 id="RDB-模式"><a class="header-anchor" href="#RDB-模式">⚡</a>RDB 模式</h3><ol><li><p>主服务器模式运行在载入RDB文件时，程序会检查文件中的键，只会加载未过期的，过期的会被忽略，所以RDB模式下过期键不会对主服务器产生影响。</p></li><li><p>从服务器运行载入RDB文件时，会载入所有键，包括过期和未过期。当主服务器进行数据同步的时候，从服务器的数据会被清空，所以RDB文件的过期键一般不会对从服务器产生影响。</p></li></ol><h3 id="AOF-模式"><a class="header-anchor" href="#AOF-模式">⚡</a>AOF 模式</h3><p>AOF文件不会受过期键的影响。如果有过期键未被删除，会执行以下动作：</p><p>客户端请求过期键时：</p><ol><li><p>从数据库中删除被访问的过期键；</p></li><li><p>追加一条DEL 命令到AOF文件；</p></li><li><p>向执行请求的客户端回复nil（空）</p></li></ol><p>注：在执行AOF文件重写时，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><h3 id="主从复制"><a class="header-anchor" href="#主从复制">⚡</a>主从复制</h3><ol><li><p>主服务器删除过期键之后，向从服务器发送一条DEL指令，告知删除该过期键。</p></li><li><p>从服务器接收到 get 指令的时候不会对过期键进行处理，只会当做未过期键一样返回。（为了保持主从服务器数据的一致性）</p></li><li><p>从服务器只有接到主服务器发送的 DEL 指令后才会删除过期键。</p></li></ol><h2 id="内存淘汰策略-6种"><a class="header-anchor" href="#内存淘汰策略-6种">⚡</a>内存淘汰策略 (6种)</h2><ol><li><p>volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</p></li><li><p>volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰</p></li><li><p>volatile-random 从已设置过期时间的数据集中任意选择数据淘汰</p></li><li><p>allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰</p></li><li><p>allkeys-random 从所有数据集中任意选择数据进行淘汰</p></li><li><p>noeviction 禁止淘汰数据</p></li></ol><h2 id="使用场景"><a class="header-anchor" href="#使用场景">⚡</a>使用场景</h2><ul><li><p>如果不确定具体的业务特征, 那么 allkeys-lru 是一个很好的选择。因为设置 expire 会消耗额外的内存, 所以使用 allkeys-lru 策略, 可以更高效地利用内存, 因为这样就可以不再设置过期时间了。</p></li><li><p>如果分为热数据与冷数据(把冷数据清除掉，保证 redis 中是热点数据)，推荐使用 allkeys-lru 策略。</p></li><li><p>如果需要循环读写所有的 key，或者各个 key 的访问频率差不多，可以使用 allkeys-random 策略，即读写所有元素的概率差不多。</p></li><li><p>假如要让 Redis 根据 TTL 来筛选需要删除的 key，请使用 volatile-ttl 策略。</p></li><li><p>volatile-lru 和 volatile-random 策略主要应用场景是: 既有<strong>缓存</strong>,又有<strong>持久化的 key</strong>。一般来说，像这类场景，应该使用两个单独的 Redis 实例。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式知识 -- 分布式数据存储</title>
    <link href="/2020/11/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9F%A5%E8%AF%86-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2020/11/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9F%A5%E8%AF%86-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="系统评估标准"><a class="header-anchor" href="#系统评估标准">⚡</a>系统评估标准</h2><h3 id="CAP-原则"><a class="header-anchor" href="#CAP-原则">⚡</a>CAP 原则</h3><h3 id="BASE-理论"><a class="header-anchor" href="#BASE-理论">⚡</a>BASE 理论</h3><h2 id="数据组织方式"><a class="header-anchor" href="#数据组织方式">⚡</a>数据组织方式</h2><h3 id="数据存储层-（数据如何存储、查询）"><a class="header-anchor" href="#数据存储层-（数据如何存储、查询）">⚡</a>数据存储层 （数据如何存储、查询）</h3><ol><li><p>分库分表</p><p>垂直、水平切分</p><ul><li><p>路由机制</p><ol><li><p>取模算法</p><p>按字段取模（对 hash 结果取余数 ( hash() mod N)，N为数据库实例数或子表数量）是最为常见的一种切分方式。</p><p>缺点：</p><p>当某一台机器宕机，本应该落在该数据库的请求就无法得到正确的处理，这时宕掉的实例会被踢出集群，此时算法变成hash(userId) mod N-1，用户信息可能就不再在同一个库中了。</p></li><li><p>范围限定算法</p><p>按照 时间区间 或 ID区间 来切分</p><p>缺点：</p><p>由于连续分片可能存在数据热点，比如按时间字段分片，可能某一段时间内订单骤增，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询</p></li></ol></li><li><p>难点：</p><ol><li><p>连接查询</p></li><li><p>事务</p></li></ol></li><li><p>分片</p><ol><li><p>分片是将原本一张数据量较大的表 t_order 根据分片键，拆分生成数个表结构完全一致的小数据量表 t_order_0、t_order_1、···、t_order_n，每张表只存储原大表中的一部分数据，当执行一条SQL时会通过<code>分库策略</code>、<code>分片策略</code>将数据分散到不同的数据库、表内。</p></li><li><p>分片算法</p><p>分片算法可以理解成一种路由规则。</p></li><li><p>分片策略只是一个概念，它由具体的分片算法和分片健组合而成，分片算法做具体的数据分片逻辑。</p></li><li><p>分片流程</p><p>SQL 解析 -&gt; 执⾏器优化 -&gt; SQL 路由 -&gt; SQL 改写 -&gt; SQL 执⾏ -&gt; 结果归并</p></li></ol><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247494903&amp;idx=3&amp;sn=87a03269968e25823fd416c8a6449250&amp;chksm=cea1a33cf9d62a2ae4b8976f92ac0b2e00c7272041e113c2cd1d9cfd1f88b1a3f30b288e3fbd&amp;mpshare=1&amp;scene=24&amp;srcid=1103mCzqL3ZwT9fHvUo0esTT&amp;sharer_sharetime=1604389049080&amp;sharer_shareid=4c56eb61e6eb530e0101ff7173f2579b&amp;key=93ec0f8768e11f12c4f6a33fead1c5cc1b8c9b54bb790a948065660990b0a7a29f994ae93ac96e67bf6d9cc888a99c26d1eb71b3f28ec94d756dcf05424dd05f3e2e7f80ac502f5757733fbfa3f1b32e749800d08413135cf0321fc7600f1d5e577ce031cc31a5655bdaf29501185d226582812c6003f4cd386d29e4fafa0b63&amp;ascene=14&amp;uin=MzE0OTQxMDY2Mg%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A7Yjd6p%2BUyHhfH2hyKXGt1k%3D&amp;pass_ticket=ovptXHHNLOzcpgrzsP%2FXOIR1yWePG%2FCNgAdqUNkG6KeZec0D%2FwUhrFycnQKaKAA0&amp;wx_header=0" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247494903&amp;idx=3&amp;sn=87a03269968e25823fd416c8a6449250&amp;chksm=cea1a33cf9d62a2ae4b8976f92ac0b2e00c7272041e113c2cd1d9cfd1f88b1a3f30b288e3fbd&amp;mpshare=1&amp;scene=24&amp;srcid=1103mCzqL3ZwT9fHvUo0esTT&amp;sharer_sharetime=1604389049080&amp;sharer_shareid=4c56eb61e6eb530e0101ff7173f2579b&amp;key=93ec0f8768e11f12c4f6a33fead1c5cc1b8c9b54bb790a948065660990b0a7a29f994ae93ac96e67bf6d9cc888a99c26d1eb71b3f28ec94d756dcf05424dd05f3e2e7f80ac502f5757733fbfa3f1b32e749800d08413135cf0321fc7600f1d5e577ce031cc31a5655bdaf29501185d226582812c6003f4cd386d29e4fafa0b63&amp;ascene=14&amp;uin=MzE0OTQxMDY2Mg%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A7Yjd6p%2BUyHhfH2hyKXGt1k%3D&amp;pass_ticket=ovptXHHNLOzcpgrzsP%2FXOIR1yWePG%2FCNgAdqUNkG6KeZec0D%2FwUhrFycnQKaKAA0&amp;wx_header=0</a></p></li></ul></li></ol><h3 id="数据缓存层"><a class="header-anchor" href="#数据缓存层">⚡</a>数据缓存层</h3><p>redis 三种模式</p><ol><li><p>主从 master-slave</p><ol><li><p>一主一从</p></li><li><p>一主多从</p></li><li><p>树状主从</p></li></ol></li><li><p>哨兵 sentinel</p></li><li><p>集群 cluster</p></li></ol><p>同步方式：</p><p>解决问题：</p><p>缺陷：</p><hr><h4 id="缓存出现的问题"><a class="header-anchor" href="#缓存出现的问题">⚡</a>缓存出现的问题</h4><ol><li><p>大量 null 值使缓存失效</p><p>解决：布隆过滤器</p></li></ol><h3 id="事务"><a class="header-anchor" href="#事务">⚡</a>事务</h3><h4 id="强一致性"><a class="header-anchor" href="#强一致性">⚡</a>强一致性</h4><ol><li><p>二段式提交</p></li><li><p>三段式提交</p></li><li><p>分布式锁</p></li></ol><h4 id="弱一致性（最终一致性）"><a class="header-anchor" href="#弱一致性（最终一致性）">⚡</a>弱一致性（最终一致性）</h4><ol><li><p>Paxos</p></li><li><p>Raft</p></li></ol><p>提一句：分布式锁实际上是为了实线分布式进程同步使用的，和分布式事务本来关系不大，但是我们可以通过分布式锁完成分布式进程之间的通信进而实现分布式事务</p><h3 id="数据分布"><a class="header-anchor" href="#数据分布">⚡</a>数据分布</h3><ol><li><p>hash 值对实例数量进行取模</p><p>虽然方便，但是存在实例数目增加或者减少的情况，不好</p></li><li><p>一致性 Hash 算法</p></li></ol><h3 id="故障恢复"><a class="header-anchor" href="#故障恢复">⚡</a>故障恢复</h3><div class="hljs"><pre><code>自动选举</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>distribute system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式知识 -- 布隆过滤器</title>
    <link href="/2020/11/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9F%A5%E8%AF%86-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2020/11/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9F%A5%E8%AF%86-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/6844904007790673933" target="_blank" rel="noopener">https://juejin.im/post/6844904007790673933</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>distribute system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识 -- 类加载</title>
    <link href="/2020/11/13/JVM-%E7%9F%A5%E8%AF%86-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2020/11/13/JVM-%E7%9F%A5%E8%AF%86-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="类生命周期"><a class="header-anchor" href="#类生命周期">⚡</a>类生命周期</h2><ol><li><p>加载</p><ol><li><p>通过全类名获取二进制字节流 (<strong>可操控性最强的阶段</strong>，例如通过自定义类加载器去网络上获取字节流加载)</p></li><li><p>将字节流表示的静态存储结构变成方法区中运行时动态的存储结构</p></li><li><p>在内存中生成一个 Class 对象，作为方法区内访问数据的入口</p></li></ol></li><li><p>连接</p><p><strong>注意：加载和连接阶段是交叉进行的</strong></p><ol><li><p>验证</p><ol><li><p>验证文件格式</p><p>这是验证字节流是否符合 Class 文件格式的规范</p><p>例如字节码开头的 <code>0xCAFEBABY</code>、主次版本号是否在 JVM 处理范围内</p></li><li><p>验证元数据</p><p>这是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求</p><p>例如这个类是否有父类，这个类是否继承了不允许继承的类</p></li><li><p>验证字节码</p><p>这是最复杂的阶段，通过数据流和控制流确定程序语义是合法的</p><p>例如保证任意时刻操作数栈和指令代码序列都能配合工作</p></li></ol></li><li><p>准备</p><p><strong>正式为类变量分配内存并设置初始值</strong></p><p>注意：</p><ol><li><p>只是类变量而非实例变量</p></li><li><p>初始值指的是零值，具体指定的值在初始化阶段才会赋值</p></li><li><p>上面的条件二在常量（被 final 修饰的变量）时不成立，在准备阶段就会赋予目标值。</p></li></ol></li><li><p>解析</p><p><strong>JVM 将常量池中的符号引用替换为直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量</strong></p><p>主要针对：类、接口、字段、类方法、接口方法、方法类型、方法句柄、调用限定符等</p><p>直接引用是指向目标的指针、相对偏移量、间接定位到目标的句柄</p><p>例如 JVM 要去调用某一个方法，需要知道这个方法在方法表中的偏移量，而每个类都有一个方法表</p></li></ol></li><li><p>初始化</p><p><strong>类加载的最后一个阶段</strong></p><p>只有当下面几种情况才会初始化：</p><ol><li><p>遇到 <code>new</code>，<code>getstatic</code>，<code>putstatic</code>，<code>invokestatic</code> 这几条字节码指令 (new 一个对象、读取静态字段、给静态字段赋值、调用类的静态方法)</p></li><li><p>反射调用</p><p><code>Class.forName()</code>,<code>newInstance()</code> 等</p></li><li><p>初始化子类时先初始化父类</p></li><li><p>包含 <code>main()</code> 方法的那个主类</p></li><li><p>…</p></li></ol></li><li><p>使用</p></li><li><p>卸载</p><p>一个类被卸载的必要条件：</p><ol><li><p>堆上没有这个类的实例对象</p></li><li><p>类没有被引用</p></li><li><p>该类的类加载器已经被回收</p><p>JDK 自带的类加载器加载 JDK 自带的类，不会被回收，只有自定义的类加载器的实例才可以被回收</p></li></ol></li></ol><h2 id="类加载器"><a class="header-anchor" href="#类加载器">⚡</a>类加载器</h2><h3 id="几种类加载器"><a class="header-anchor" href="#几种类加载器">⚡</a>几种类加载器</h3><ol><li><p>BootstrapClassLoader（启动类加载器）</p></li><li><p>ExtensionClassLoader（扩展类加载器）</p></li><li><p>ApplicationClassLoader （应用程序类加载器、系统类加载器）</p></li><li><p>自定义类加载器</p><p>上面除了 BootstrapClassLoader 类加载器，其他的 ClassLoader 都必须继承自 <code>java.lang.ClassLoader</code> 类，而 Bootstrap ClassLoader 不继承自 ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader 也随着启动</p><p>(继承 ClassLoader 默认父类加载器是 ApplicationClassLoader)</p><p>不继承 AppClassLoader 的原因是：它和 ExtensionClassLoader 都是 Launcher 的静态类，都是包访问路径权限。</p></li></ol><h3 id="双亲委派模型"><a class="header-anchor" href="#双亲委派模型">⚡</a>双亲委派模型</h3><ol><li><p>一个类被加载时，首先判断是否被加载过，如果没有则会先去委派父类加载器处理，因此所有的请求最终都会传到 BootstrapClassLoader 加载器，当父类加载器无法加载的时候才会向下交给子类加载器去加载，如果子类也不能加载就再向下委托，如果最后的子类加载器都无法加载则会抛出 <code>ClassNotFoundException</code></p></li><li><p>注意：</p><ol><li><p>双亲委派模型实际上不是有两个上级加载器的意思，父类加载器只有一个</p></li><li><p>类加载器的父子关系并不是<strong>继承</strong>实现的，而是通过优先级实现的</p></li></ol></li><li><p>为什么有双亲委派模型</p><ol><li><p>安全</p><p>当我们写一个自定义的 String 类型时，保证 JVM 加载的还是 JDK 自带的类，因为 BootstrapClassLoader 类加载器就能把这个类加载出来了，ApplicationClassLoader 不会去加载我们自定义的 String 类</p><p>即使是我们自己用自定义类加载器去加载，也不会成功，因为 String 类在 JVM 启动时已经被 BootstrapClassLoader 加载了，不会二次重复加载</p></li></ol></li></ol><h3 id="类加载器加载流程"><a class="header-anchor" href="#类加载器加载流程">⚡</a>类加载器加载流程</h3><p>类加载器加载的时候，就是调用 <code>loadClass()</code> 方法：</p><ol><li><p>首先检查这个类是否被加载过</p></li><li><p>如果有，直接返回，否则开始加载</p></li><li><p>找到父类加载器，如果不为空，说明父类加载器不是 BootstrapClassLoader，那么直接调用父类加载器的 <code>loadClass()</code> 方法；否则父类加载器就是 BootstrapClassLoader，</p></li></ol><p><strong>注意</strong>：</p><p>如果类加载器不同，那么即使是同一份字节码交给两个不同的类加载器去加载，得到的类也是不同的</p><h3 id="为什么需要自定义类加载器（打破双亲委派）"><a class="header-anchor" href="#为什么需要自定义类加载器（打破双亲委派）">⚡</a>为什么需要自定义类加载器（打破双亲委派）</h3><ol><li><p>字节码加密解密</p></li><li><p>动态获取类(热部署)</p></li><li><p>从特定源获取类(例如网络，而非本地文件系统)</p></li></ol><p>例子：</p><ol><li><p>例如 Tomcat 定义多个类加载器：</p><ol><li><p>保证同一个服务器的两个 web 应用程序 Java 类库隔离</p></li><li><p>保证同一个服务器的两个 web 应用程序 Java 类库可以共享</p></li><li><p>保证服务器自身安全不被 web 应用程序影响</p></li></ol></li><li><p>再比如数据库驱动类</p><p><code>Class.forName(&quot;com.mysql.dj.Driver&quot;);</code></p><hr><p>先多说一句这段代码的原理是：mysql 驱动的 Driver 类里面有一个静态代码块，当 Driver 类被加载的时候这段静态代码块被执行，将 mysql 驱动实例注册到全局的 jdbc 驱动管理器里。</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;    &#125;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<span class="hljs-comment">//首先new一个Driver对象，并将它注册到DriverManage中</span>        &#125; <span class="hljs-keyword">catch</span> (SQLException var1) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Can't register driver!"</span>);        &#125;    &#125;&#125;</code></pre></div><p>而我们之后一般又会这样链接数据库</p><p><code>Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;);</code></p><hr><p>上面的<code>Class.forName()</code> 方法是使用调用者 Class 对象的 ClassLoader 来加载目标类，但是这样其实没有打破双亲委派，具体的分析看最后的 SPI 扩展相关部分吧</p></li></ol><h3 id="类加载器主要方法"><a class="header-anchor" href="#类加载器主要方法">⚡</a>类加载器主要方法</h3><ol><li><p>loadClass</p><p>加载类的方法入口，这个方法默认就遵循双亲委派模型加载类，如果想要破坏双亲委派模型，就要重写这里的方法</p></li><li><p>findClass</p><p>如果上面的 loadClass 方法都没有办法加载出来，就会调用这个类加载器自己的 findClass 方法加载。</p><p>对于最下层的类加载器来说，如果此处还是返回为空，说明这个类无法找到</p></li><li><p>defineClass</p><p>如果类加载器加载了类，获取到字节码，就用这个方法将字节码转换为 Class 对象</p></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoader</span> </span>&#123;  <span class="hljs-comment">// 加载入口，定义了双亲委派规则</span>  <span class="hljs-function">Class <span class="hljs-title">loadClass</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-comment">// 是否已经加载了</span>    Class t = <span class="hljs-keyword">this</span>.findFromLoaded(name);    <span class="hljs-keyword">if</span>(t == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 交给双亲</span>      t = <span class="hljs-keyword">this</span>.parent.loadClass(name)    &#125;    <span class="hljs-keyword">if</span>(t == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 双亲都不行，只能靠自己了</span>      t = <span class="hljs-keyword">this</span>.findClass(name);    &#125;    <span class="hljs-keyword">return</span> t;  &#125;    <span class="hljs-comment">// 交给子类自己去实现</span>  <span class="hljs-function">Class <span class="hljs-title">findClass</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-keyword">throw</span> ClassNotFoundException();  &#125;    <span class="hljs-comment">// 组装Class对象</span>  <span class="hljs-function">Class <span class="hljs-title">defineClass</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] code, String name)</span> </span>&#123;    <span class="hljs-keyword">return</span> buildClassFromCode(code, name);  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;  <span class="hljs-function">Class <span class="hljs-title">findClass</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-comment">// 寻找字节码</span>    <span class="hljs-keyword">byte</span>[] code = findCodeFromSomewhere(name);    <span class="hljs-comment">// 组装Class对象</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defineClass(code, name);  &#125;&#125;</code></pre></div><hr><h1>扩展： SPI</h1><p>在高版本的JDK，已经不需要手动调用class.forName方法了，在DriverManager的源码中可以看到一个静态块</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * Load the initial JDBC drivers by checking the System property</span><span class="hljs-comment">     * jdbc.properties and then use the &#123;<span class="hljs-doctag">@code</span> ServiceLoader&#125; mechanism</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> &#123;        loadInitialDrivers();        println(<span class="hljs-string">"JDBC DriverManager initialized"</span>);    &#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span><span class="hljs-params">()</span> </span>&#123;    String drivers;    <span class="hljs-keyword">try</span> &#123;        drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">"jdbc.drivers"</span>);            &#125;        &#125;);    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;        drivers = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">// If the driver is packaged as a Service Provider, load it.</span>    <span class="hljs-comment">// Get all the drivers through the classloader</span>    <span class="hljs-comment">// exposed as a java.sql.Driver.class service.</span>    <span class="hljs-comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();            <span class="hljs-comment">/* Load these drivers, so that they can be instantiated.</span><span class="hljs-comment">             * It may be the case that the driver class may not be there</span><span class="hljs-comment">             * i.e. there may be a packaged driver with the service class</span><span class="hljs-comment">             * as implementation of java.sql.Driver but the actual class</span><span class="hljs-comment">             * may be missing. In that case a java.util.ServiceConfigurationError</span><span class="hljs-comment">             * will be thrown at runtime by the VM trying to locate</span><span class="hljs-comment">             * and load the service.</span><span class="hljs-comment">             *</span><span class="hljs-comment">             * Adding a try catch block to catch those runtime errors</span><span class="hljs-comment">             * if driver not available in classpath but it's</span><span class="hljs-comment">             * packaged as service and that service is there in classpath.</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">try</span>&#123;                <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;                    driversIterator.next();                &#125;            &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;            <span class="hljs-comment">// Do nothing</span>            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;);</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;    <span class="hljs-comment">// 重点！！！</span>    ClassLoader cl = Thread.currentThread().getContextClassLoader();    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service,ClassLoader loader)</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceLoader&lt;&gt;(service, loader);&#125;</code></pre></div><p>在 <code>loadInitialDrivers</code> 方法中，最重要的是 <code>ServiceLoader.load(Driver.class)</code>，这行代码可以把类路径下所有 jar 包中 <code>META-INF/services/java.sql.Driver</code> 文件中定义的类加载上来，此类必须继承自<code>java.sql.Driver</code>。</p><p>其次，<code>driversIterator.next();</code>还会循环调用上面获取到所有的 Driver 的子类，调用 next 方法，最后调用下面的 nextService 方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (!hasNextService())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();    String cn = nextName;    nextName = <span class="hljs-keyword">null</span>;    Class&lt;?&gt; c = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//重点！使用当前示例的成员变量loader加载，就是上面设置的ThreadContextClassLoader</span>        c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException x) &#123;        fail(service,             <span class="hljs-string">"Provider "</span> + cn + <span class="hljs-string">" not found"</span>);    &#125;    <span class="hljs-keyword">if</span> (!service.isAssignableFrom(c)) &#123;       fail(service,             <span class="hljs-string">"Provider "</span> + cn  + <span class="hljs-string">" not a subtype"</span>);    &#125;    <span class="hljs-keyword">try</span> &#123;        S p = service.cast(c.newInstance());        providers.put(cn, p);        <span class="hljs-keyword">return</span> p;    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;        fail(service,             <span class="hljs-string">"Provider "</span> + cn + <span class="hljs-string">" could not be instantiated"</span>,            x);    &#125;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error();          <span class="hljs-comment">// This cannot happen</span>&#125;</code></pre></div><p>上面的 <code>Class.forName()</code> 方法完成了在 BootstrapClassLoader 加载的类(Driver.class)中通过ThreadContextClassLoader 加载了应用程序的实现类。</p><p>这段代码的重点就是 <code>Class.forName()</code></p><p>也就是说，通过SPI的方式把程序员手动做的动作(<code>Class.forName()</code>)变成框架自动执行。</p><p><a href="https://www.cnblogs.com/qingchen521/p/10331768.html" target="_blank" rel="noopener">相关博客</a></p><p>所以，SPI (service provider interface)其实是一种标准，他定义了接口，而不同服务的厂商去实现这个接口，当用户需要使用的时候，就把相关的实现类放到指定的位置，应用程序会自动找到他们并加载</p><p>相比 API，SPI 更接近服务调用方</p><p>在 jdk6 里面引进的一个新的特性 ServiceLoader，从官方的文档来说，它主要是用来装载一系列的 service provider。而且 ServiceLoader 可以通过 service provider 的配置文件来装载指定的 service provider。当服务的提供者，提供了服务接口的一种实现之后，我们只需要在 jar 包的 META-INF/services/ 目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该 jar 包 META-INF/services/ 里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p><p>所以，SPI 的<strong>思想</strong>是：接口的实现还是由服务提供者来实现，但是服务提供者只用在提交的 jar 包里的 META-INF/services 下根据平台定义的接口新建文件，并添加进相应的实现类内容就好，而服务调用者根据标准接口通过本地服务发现加载具体服务提供商。</p><p>这样做的<strong>好处</strong>是：实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p><p>常用场景有：</p><ol><li><p>数据库驱动实现类加载</p><p>JDBC 加载不同的数据库驱动</p></li><li><p>日志门面接口加载</p><p>Slf4j 加载不同日志实现</p></li><li><p>Spring</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识-- ThreadLocal</title>
    <link href="/2020/11/1/Java-%E7%9F%A5%E8%AF%86-ThreadLocal/"/>
    <url>/2020/11/1/Java-%E7%9F%A5%E8%AF%86-ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a class="header-anchor" href="#概念">⚡</a>概念</h2><p>ThreadLocal 是线程本地变量</p><p>ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p><h2 id="应用场景"><a class="header-anchor" href="#应用场景">⚡</a>应用场景</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;         <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection connect = <span class="hljs-keyword">null</span>;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(connect == <span class="hljs-keyword">null</span>)&#123;            connect = DriverManager.getConnection();        &#125;        <span class="hljs-keyword">return</span> connect;    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(connect!=<span class="hljs-keyword">null</span>)            connect.close();    &#125;&#125;</code></pre></div><p>假设有这样一个数据库链接管理类，这段代码在单线程中使用是没有任何问题的，但是如果在多线程中使用呢？很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</p><p>所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。</p><p>这样将会大大影响程序执行效率，因为一个线程在使用connect进行数据库操作的时候，其他线程只有等待。</p><p>那么这地方到底需不需要将connect变量进行共享？事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。</p><p>到这里，可能会有朋友想到，既然不需要在线程之间共享这个变量，可以直接这样处理，在每个需要使用数据库连接的方法中具体使用时才创建数据库链接，然后在方法调用完毕再释放这个连接。比如下面这样：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;    <span class="hljs-keyword">private</span> Connection connect = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(connect == <span class="hljs-keyword">null</span>)&#123;            connect = DriverManager.getConnection();        &#125;        <span class="hljs-keyword">return</span> connect;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(connect!=<span class="hljs-keyword">null</span>)            connect.close();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dao</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;        ConnectionManager connectionManager = <span class="hljs-keyword">new</span> ConnectionManager();        Connection connection = connectionManager.openConnection();        <span class="hljs-comment">//使用connection进行操作</span>        connectionManager.closeConnection();    &#125;&#125;</code></pre></div><p>这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。</p><p>那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。</p><p>但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; con =            ThreadLocal.withInitial(()-&gt;&#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">"jdbc://"</span>, <span class="hljs-string">"root"</span>,<span class="hljs-string">"root"</span>);                &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;                    throwables.printStackTrace();                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                &#125;            &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> connect.get();    &#125;&#125;</code></pre></div><p>综上：ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景。即在不同线程中都希望用到这个变量但不希望出现多线程对这个变量产生任何影响，使用 ThreadLocal 之后，不同线程对于这个变量的操作都只在这个线程内部其作用，其他线程不可见。</p><p>而且，ThreadLocal 只是将代码变得更加整齐简洁，通过方法间显示的传递对象自身，也可以达到相同的结果，只是方法间的耦合度较高，看起来不简洁。</p><h2 id="原理"><a class="header-anchor" href="#原理">⚡</a>原理</h2><p>首先看 ThreadLocal 的主要方法：</p><p>get(),set(),remove()</p><h3 id="get"><a class="header-anchor" href="#get">⚡</a>get</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 注意是 this 不是 t，说明 ThreadLocalMap 的 key 为 ThreadLocal 而非 Thread</span>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        T result = (T)e.value;        <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-keyword">return</span> setInitialValue();&#125;<span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;  <span class="hljs-keyword">return</span> t.threadLocals;&#125;</code></pre></div><p>当使用 ThreadLocal.get() 方法时，首先获取到当前线程的一个引用 t，然后通过 getMap 方法获取到这个线程内部的 ThreadLocalMap 变量 threadLocals，再从这个 threadLocals 变量中拿到这个 ThreadLocal 自己这个 key 所对应的 value</p><h3 id="set"><a class="header-anchor" href="#set">⚡</a>set</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;  Thread t = Thread.currentThread();  ThreadLocalMap map = getMap(t);  <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)    map.set(<span class="hljs-keyword">this</span>, value);  <span class="hljs-keyword">else</span>    createMap(t, value);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span></span>&#123;    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);&#125;</code></pre></div><p>如果当前线程的 threadLocals 不为空，则直接设置，为空则先创建 Map</p><h3 id="remove"><a class="header-anchor" href="#remove">⚡</a>remove</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    ThreadLocalMap m = getMap(Thread.currentThread());    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)        m.remove(<span class="hljs-keyword">this</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;    Entry[] tab = table;    <span class="hljs-keyword">int</span> len = tab.length;    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (Entry e = tab[i];         e != <span class="hljs-keyword">null</span>;         e = tab[i = nextIndex(i, len)]) &#123;        <span class="hljs-keyword">if</span> (e.get() == key) &#123;            e.clear();            expungeStaleEntry(i);            <span class="hljs-keyword">return</span>;        &#125;    &#125;&#125;</code></pre></div><p>注：<br>当 JVM GC 时，只是把 ThreadLocalMap 中的 key （WeakReference 弱引用）给回收掉了，value 值没有处理，所以这可能会造成内存泄漏甚至 OOM 内存溢出的问题，所以需要手动调用 ThreadLocal 的 remove 方法，保证 key 和 value 都被正确删除。</p><h3 id="分析"><a class="header-anchor" href="#分析">⚡</a>分析</h3><p>因为每个线程有且只有一个 ThreadLocalMap 对象，并且只有该线程自己可以访问它，其它线程不会访问该 ThreadLocalMap，自然也无法获取到 ThreadLocalMap 中存储的 ThreadLocal 为 key 所对应的 value，虽然 ThreadLocal 对象是线程都可以访问的，但是 TreadLocalMap 不会在多个线程中共享，即使是ThreadLocal 对象获取到的 value 副本也只和线程自己有关，和其他线程无关，也无法访问到，也就不存在线程安全的问题。</p><p>小问题：</p><p>ThreadLocalMap 是通过什么机制存储 ThreadLocal 呢？</p><p><a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener"></a><br><a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/" target="_blank" rel="noopener"></a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识-- 指针、引用和句柄</title>
    <link href="/2020/11/1/JVM%E7%9F%A5%E8%AF%86-%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%A5%E6%9F%84/"/>
    <url>/2020/11/1/JVM%E7%9F%A5%E8%AF%86-%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%A5%E6%9F%84/</url>
    
    <content type="html"><![CDATA[<h2 id="指针"><a class="header-anchor" href="#指针">⚡</a>指针</h2><p>指针是对象在内存中的地址</p><h2 id="引用-Reference"><a class="header-anchor" href="#引用-Reference">⚡</a>引用 (Reference)</h2><p>对象的引用是创建对象时的返回值，即 new 表达式的返回值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">new</span> A();</code></pre></div><p>这里真正创建了一个对象，但我们没有用句柄去持有（hold，拿着，保存）该引用。Handle 是变量，Reference 是一种变量值。</p><h2 id="句柄-Handle"><a class="header-anchor" href="#句柄-Handle">⚡</a>句柄 (Handle)</h2><p>句柄是指针的指针</p><h3 id="对象句柄"><a class="header-anchor" href="#对象句柄">⚡</a>对象句柄</h3><div class="hljs"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();</code></pre></div><p>a 就是对象句柄</p><p><code>new A();</code> 返回值是对象引用</p><p><code>a = new A()</code> 完成了 <code>句柄=引用</code> 的过程，即句柄的初始化</p><h3 id="JVM-中对象访问句柄-JVM-底层实现"><a class="header-anchor" href="#JVM-中对象访问句柄-JVM-底层实现">⚡</a>JVM 中对象访问句柄 (JVM 底层实现)</h3><p>通过引用有两种访问对象的方式：</p><ol><li><p>通过对象句柄访问</p><p>JVM 会在<code>堆</code>中划分一个<code>句柄池</code>，引用存储的就是在句柄池中一个句柄的地址，而这个句柄包含了对象的<strong>实例数据</strong>和<strong>类型数据</strong>的具体地址。</p><p><img src="http://cdn.yinchao.tech/1696617d82f92dcf" srcset="/img/loading.gif" alt="1696617d82f92dcf"></p><p>使用这种方式最大的好处在于，如果对象在垃圾回收器不断回收后被移动到了其他地方，句柄本身不会改变，只需要改变句柄中实例数据的指针，提高了垃圾回收的效率</p></li><li><p>直接指针访问</p><p><img src="http://cdn.yinchao.tech/169661805c59091f" srcset="/img/loading.gif" alt="169661805c59091"></p><p>引用存储的就是对象的地址，相比上个放法<strong>节省了一次指针定位的时间开销。</strong></p></li></ol><p>HotSpot 是使用直接指针的方式访问的</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识-- Java 中的几种引用</title>
    <link href="/2020/11/1/Java-%E7%9F%A5%E8%AF%86-Java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
    <url>/2020/11/1/Java-%E7%9F%A5%E8%AF%86-Java-%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="强引用"><a class="header-anchor" href="#强引用">⚡</a>强引用</h2><ul><li><p>最常用的引用方式，垃圾收集器宁愿抛出 OOM 也不愿意回收它引用对象</p></li><li><p>与其它三种引用不同，强引用创建的强引用对象就是创建的对象本身，而其他都会创建对应的软/弱/虚对象后，再去引用实际对象。</p></li></ul><h2 id="软引用-SoftReference"><a class="header-anchor" href="#软引用-SoftReference">⚡</a>软引用 (SoftReference)</h2><ul><li><p>如果内存空间不足了，垃圾收集器就会回收相应对象的内存。</p></li><li><p>可以通过 get() 方法获取引用的实际对象</p></li><li><p>使用场景：实现内存敏感的高速缓存。</p></li></ul><p>软引用可以和一个引用队列( ReferenceQueue )联合使用，当软引用对象指向的对象已经被被回收时(<strong>非这个软引用对象自身</strong>)，JVM 就会把这个软引用(这个软引用自身)加入到与之关联的引用队列中。</p><h2 id="弱引用-WeakReference"><a class="header-anchor" href="#弱引用-WeakReference">⚡</a>弱引用 (WeakReference)</h2><ul><li>垃圾收集器一旦发现了弱引用对象就会把他回收</li></ul><p>同软引用一样，弱引用也可以和一个引用队列一起使用</p><h2 id="虚引用-PhantomReference"><a class="header-anchor" href="#虚引用-PhantomReference">⚡</a>虚引用 (PhantomReference)</h2><ul><li><p>与其他几种引用不同，虚引用不会决定对象的生命周期。如果一个对象被虚引用持有，那么它就和没有任何引用一样，随时可能被垃圾收集器回收。</p></li><li><p>虚引用和软/弱引用的区别:</p><p>官方注释</p><blockquote><p>Phantom reference objects, which are enqueued after the collector determines that their referents may otherwise be reclaimed. Phantom references are most often used for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism.</p><p>虚拟引用对象，在收集器确定其引用对象可以通过其他方式回收之后，将其排队。与 Java finalize 机制相比，虚引用最常用于以更灵活的方式用事前清理操作。</p><p>If the garbage collector determines at a certain point in time that the referent of a phantom reference is phantom reachable, then at that time or at some later time it will enqueue the reference.</p><p>如果垃圾收集器在某个时间点确定幻像引用的引用对象是虚引用是可达的，则在那时或以后的某个时间，它将使该引用入队。</p><p>In order to ensure that a reclaimable object remains so, the referent of a phantom reference may not be retrieved: The get method of a phantom reference always returns null.</p><p>为了确保保留可回收对象，可能不会检索幻像引用的引用对象：幻像引用的get方法始终返回null。</p><p>Unlike soft and weak references, phantom references are not automatically cleared by the garbage collector as they are enqueued. An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable.</p><p>与软引用和弱引用不同，幻象引用在排队时不会被垃圾收集器自动清除。通过幻像引用可访问的对象将保持不变，直到清除所有此类引用或它们自身无法访问为止。</p></blockquote><p>总结：</p><ol><li><p>不会主动回收对象</p></li><li><p>get 永远为 null</p></li></ol></li><li><p>JDK 的应用</p><p>JDK 中直接内存的回收就用到虚引用。</p><p>由于 JVM 自动内存管理的范围是堆内存，而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），所以直接内存的分配和回收都是由 Unsafe 类去操作。</p><p>Java 在申请一块直接内存之后，在堆上再生成一个 DirectByteBuffer 对象存储直接内存的地址，其内部有一个静态类 Deallocator 实现了 Runnable 接口，并维护一个对 DirectByteBuffer 这个对象的虚引用。</p><p>当 DirectByteBuffer 对象被 GC 回收时，Deallocator 会通过虚引用得到通知，创建一个线程释放该 DirectByteBuffer 对象 malloc 申请的直接内存空间。</p><ul><li><p>为什么使用 DirectByteBuffer</p><ol><li><p>减少复制操作，加快传输速度</p><p>HotSpot虚拟机中，GC除了CMS算法之外，都需要移动对象。</p><p>在NIO实现中(如: FileChannel.read(ByteBuffer dst), FileChannel.write(ByteByffer src)), <strong>底层要求连续的内存，且使用期间不得变动</strong>， 如果提供的 Buffer 是 HeapByteBuffer，为了保证在数据传输时，被传输的 byte 数组背后的对象不会被 GC 回收或者移动，JVM 会首先将堆中的 byte 数组拷贝至直接内存，再由直接内存进行传输。</p><p>那么，相比于 HeapByteBuffer 在堆上分配空间，直接只用 DirectByteBuffer 在直接内存分配就节省了一次拷贝，加快了数据传输的速度。</p></li><li><p>减少GC压力</p><p>虽然 GC 仍然管理 DirectByteBuffer，但基于 DirectByteBuffer 分配的空间不属于 GC 管理，如果 IO 数量较大，可以明显降低 GC 压力。</p></li></ol></li></ul></li></ul><p><a href="https://www.ktanx.com/blog/p/313" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html" target="_blank" rel="noopener">Java Doc</a></p><p><a href="https://cheng-dp.github.io/2018/12/11/direct-memory-and-direct-byte-buffer/#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8directbytebuffer" target="_blank" rel="noopener">虚引用在 NIO 中的应用</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式知识 -- 分布式概念</title>
    <link href="/2020/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9F%A5%E8%AF%86-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9F%A5%E8%AF%86-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<ul><li><p>分布式</p><ul><li><p>概念：分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。</p></li><li><p>目标：分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，存储和处理更多的数据。（人海战术）</p></li><li><p>分类：即分布式系统分为分布式计算和分布式存储两个大类</p></li></ul></li><li><p>集群(部署)：多台服务器部署相同的应用构成一个集群</p></li><li><p>分布式(部署)：不同或相同的应用模块部署在不同服务器上构成分布式系统</p></li><li><p>分布式和集群</p><ul><li><p>相同点：</p><ol><li><p>集群部署系统一定是分布式部署系统，而反之则不一定</p></li><li><p>分布式和集群都是从项目的物理架构考虑的</p></li></ol></li><li><p>区别：</p><p>集群一般是相同服务部署到多台服务器上，而分布式系统不要求多个服务器上面服务的具体类型和数量</p></li></ul></li><li><p>微服务（Microservices）</p><ul><li><p>和分布式区别</p><ul><li><p>微服务更多的是对项目逻辑进行解偶的解决方案，而分布式系统则主要是解决性能问题</p></li><li><p>微服务仅仅关心项目的逻辑架构，不关心物理架构，如果性能不成为瓶颈，那么只使用一台物理机也是可以的，而分布式对物理架构有明确要求：一定是多台物理机</p></li></ul></li><li><p>一般来说分布式服务和微服务最后都会演变成分布式微服务(多台物理机部署多种服务解决项目耦合问题以及性能瓶颈)</p></li></ul></li><li><p>SOA（Service Oriented Architecture 面向服务架构）</p><p>是微服务的父集，SOA 的升华和延伸叫做微服务，即 SOA 发展的下一步叫做 微服务 Microservices</p><p>SOA 是为了让服务重用所以提供统一的服务接口，而微服务则仅仅专注于解偶和内部自治</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>distribute system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式知识 -- RPC 和消息队列</title>
    <link href="/2020/10/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9F%A5%E8%AF%86-RPC%20%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2020/10/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9F%A5%E8%AF%86-RPC%20%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="RPC-作用"><a class="header-anchor" href="#RPC-作用">⚡</a>RPC 作用</h2><ol><li><p>解决不同主机通信问题</p></li><li><p>解决接口寻址问题</p></li></ol><h2 id="消息队列作用"><a class="header-anchor" href="#消息队列作用">⚡</a>消息队列作用</h2><ol><li><p>应用服务解偶</p></li><li><p>流量限制</p></li><li><p>异步通信</p></li></ol><h2 id="RPC-和消息队列的区别"><a class="header-anchor" href="#RPC-和消息队列的区别">⚡</a>RPC 和消息队列的区别</h2><ol><li><p>RPC是调用模式，MQ是实现模式。</p></li><li><p>二者侧重点不一样，RPC侧重两端，MQ侧重中间（中间件）</p></li><li><p>RPC 底层通常没有队列，而消息队列一定有</p></li><li><p>RPC指的是远程调用，也就是说，调用的函数不在同一内存空间内，强调的是远程，具体怎么实现的远程，并不强求。MQ是网络中的通用队列，它不在乎存储的数据格式，可以是数据，可以是任务，它只是提供了一个存放的场所，规定了存取的方式。可以用它发布消息，分发任务，也可做RPC实现。它是通用，异步，和解耦的。</p></li><li><p>RPC 客户端只是一个桩(stub)，真正服务提供者在服务端(类似 CS 模式)。消息队列客户端就是<em>消息本身</em></p></li><li><p>RPC 和消息队列的选择</p><ol><li><p>RPC 是同步的，在实时性要求比较高的条件下 RPC 是首选</p></li><li><p>消息队列可以存储消息，崩溃后恢复，消息不丢失</p></li><li><p>RPC 同步调用瓶颈，改用异步消息队列调用提高吞吐量</p></li></ol></li></ol><p>例子：</p><blockquote><p>RPC：假设你是一个饭店里的服务员，顾客向你点菜，但是你不会做菜，所以你采集了顾客要点什么之后告诉后厨去做顾客点的菜，这叫RPC(remote procedure call)，因为厨房的厨师相对于服务员而言是另外一个人(在计算机的世界里就是remote的机器上的一个进程)。厨师做好了的菜就是RPC的返回值。</p><p>任务队列和消息队列：本质都是队列，所以就只举一个任务队列的例子。假设这个饭店在高峰期顾客很多，而厨师只有很少的几个，所以服务员们不得不把单子按下单顺序放在厨房的桌子上，供厨师们一个一个做，这一堆单子就是任务队列（当然，取决于问题的语境，可能要把放订单的桌子也算在里面一起构成所谓的任务队列平台），厨师们每做完一个菜，就从桌子上的订单里再取出一个单子继续做菜。任务队列和消息队列的一个典型使用场景就是所谓的Producer-Consumer模式，若干producer生产出任务/消息，放到队列当中，同时consumer从队列中取出任务/消息来进行处理。</p></blockquote><h2 id="RPC-调用流程"><a class="header-anchor" href="#RPC-调用流程">⚡</a>RPC 调用流程</h2><p>消费端：</p><ol><li><p>通过网络向服务端发送序列化后的 RPC 请求</p></li><li><p>等待服务器返回结果</p></li><li><p>如果服务器调用成功，那么就将结果反序列化</p></li></ol><p>服务端：</p><ol><li><p>在本地维护 RPC 接口映射关系</p></li><li><p>等待请求</p></li><li><p>得到一个请求后，将其数据包反序列化并得到具体的 RPC 接口</p></li><li><p>将参数反序列化后，在本地调用接口，得到结果</p></li><li><p>将结果序列化后通过网络返回给消费端</p></li></ol><p>涉及到的主要几个操作：</p><ol><li><p>RPC 接口映射</p></li><li><p>序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p></li><li><p>网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输层需要把映射的接口和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</p></li></ol><h2 id="RPC-协议-和-HTTP-协议"><a class="header-anchor" href="#RPC-协议-和-HTTP-协议">⚡</a>RPC 协议 和 HTTP 协议</h2><p>为什么有了 HTTP 协议还要 RPC 协议</p><ol><li><p>RPC 最大的优势：易用性。</p></li><li><p>有的 RPC 协议基于 UDP 性能更好，能够做到实时性的需要</p></li><li><p>也有 RPC 框架兼容了 HTTP 协议，方便普通 HTTP 接口的调用，它们同时存在</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>distribute system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识-- Java 中的 String 相等？</title>
    <link href="/2020/9/21/Java-%E7%9F%A5%E8%AF%86-Java-%E4%B8%AD%E7%9A%84-String-%E7%9B%B8%E7%AD%89%EF%BC%9F/"/>
    <url>/2020/9/21/Java-%E7%9F%A5%E8%AF%86-Java-%E4%B8%AD%E7%9A%84-String-%E7%9B%B8%E7%AD%89%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>(本文基于 JDK 1.7 及以上)</p><ul><li><p>test1</p>  <div class="hljs"><pre><code class="hljs java">String str1 = “hello word<span class="hljs-string">";</span><span class="hljs-string"></span><span class="hljs-string">String str2 ="</span>hello<span class="hljs-string">" +"</span> word<span class="hljs-string">";</span><span class="hljs-string"></span><span class="hljs-string">System.out.println(str1==str2);</span><span class="hljs-string">// true</span></code></pre></div><p>这种情况下编译器会对 str2 进行优化，直接优化成 “hello word”,str1==st2</p></li><li><p>test2</p>  <div class="hljs"><pre><code class="hljs java">String s1 = <span class="hljs-string">"hello word"</span>;<span class="hljs-comment">// s1 此时在堆上(字符串常量池中)创建了一个 String 对象，并把对象加入到字符串常量池的引用中</span>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"hello word"</span>);<span class="hljs-comment">// s2 会在堆上生成一个 String 对象，因为字符串常量池中已经有了，那么不会创建新的 String 对象，会把字符串常量池中引用的对象直接返回给 s2 所创建的 String 对象</span><span class="hljs-comment">// 但是 s2 和 s1 所引用的对象的地址还是不相同的</span><span class="hljs-comment">// 因为 s2 其实还可以看成一个引用，它指向 s1</span>System.out.println(s1==s2);<span class="hljs-comment">// false</span>System.out.println(s2.intern()==<span class="hljs-string">"Hello World"</span>);<span class="hljs-comment">// intern() 方法会去字符串常量池中找有没有字符串对象 "Hello Word"，这里找到了最开始 s1 存入的字符串常量，所以直接返回字符串常量池中的 String 对象地址</span><span class="hljs-comment">// true</span></code></pre></div></li><li><p>test3</p>  <div class="hljs"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>);<span class="hljs-comment">// 在堆上生成一个 String 对象，并且建立在字符串常量池中的 "1" String 对象引用</span>String s2 = <span class="hljs-string">"1"</span>;<span class="hljs-comment">// 把 s2 引用直接指向字符串常量池中的 "1" 对象</span>System.out.println(s1 == s2);<span class="hljs-comment">// s1 和 s2 引用的地址不相同，结果为 false</span>System.out.println(s1.intern()==<span class="hljs-string">"1"</span>);<span class="hljs-comment">// intern() 方法会去字符串常量池中找有没有字符串对象 "1"，这里找到了最开始 s1 存入的字符串常量</span></code></pre></div><p>test2 和 test3 说明无论直接赋值和 new String 顺序如何改变，只要一个在常量池，一个是每次在堆上的新生成的对象，他们内存地址就一定不会相同</p></li><li><p>test4</p>  <div class="hljs"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>)+<span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>);<span class="hljs-comment">// 这里仅仅会在字符串常量池生成一个字符串对象 "1"，和两个 String 对象，并且 String 对象指向到字符串对象</span><span class="hljs-comment">// 因为这里两个 String 对象相加，而不是 new String("11")，所以这里虽然在堆上生成了第三个 String 对象，但是没有把对象的引用加入到字符串常量池中</span><span class="hljs-comment">// 即此时并没有在字符串常量池中产生 "11" 这个字符串对象</span>s1.intern();<span class="hljs-comment">// 对于这个方法，JDK 1.7 中不会在字符串常量池生成一个 "11" 对象了，只是在字符串常量池中建立一个对于堆上字符串对象的引用</span>String s2 = <span class="hljs-string">"11"</span>;<span class="hljs-comment">// 这里去字符串常量池中查找，找到了一个指向堆上字符串对象的引用，即上面 s1 创建的对象</span>System.out.println(s1 == s2);<span class="hljs-comment">// true</span></code></pre></div></li><li><p>test5</p><p><em>为了验证上面 test4 中 s1 new String 时并没有加入到字符串常量池中:</em></p>  <div class="hljs"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>)+<span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>);<span class="hljs-comment">// 与上面的区别在于这里 s2 和 s1.intern() 方法顺序不同了</span>String s2 = <span class="hljs-string">"11"</span>;<span class="hljs-comment">// 这里直接看到字符串常量池中没有 "11" 这个字符串对象，那么直接创建</span>s1.intern();<span class="hljs-comment">// 此时返回了上面 s2 创建的字符串对象，但是没有意义了</span>System.out.println(s1 == s2);<span class="hljs-comment">// s1 在 堆上面，s2 在字符串常量池，结果为 false</span><span class="hljs-comment">// false</span></code></pre></div></li><li><p>test6</p>  <div class="hljs"><pre><code class="hljs java">String str1 = <span class="hljs-string">"b"</span>;<span class="hljs-comment">// 编译器认为 str1 是变量，只会在运行时确定 str2 的值</span><span class="hljs-comment">// 此时会在堆上产生一个字符串常量</span>String str2 = <span class="hljs-string">"a"</span> + str1;String str12 = <span class="hljs-string">"ab"</span>;System.out.println(str1 = str12);<span class="hljs-comment">// false</span></code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 和上面代码不同的地方在于 str1 加了 final 修饰，编译器会认为这个 str1 是常量进而在编译时直接优化</span><span class="hljs-keyword">final</span> String str1 = <span class="hljs-string">"b"</span>;<span class="hljs-comment">// 在编译时会直接变成 str2 = "ab";</span>String str2 = <span class="hljs-string">"a"</span> + str1;String str12 = <span class="hljs-string">"ab"</span>;System.out.println(str1 = str12);<span class="hljs-comment">// true</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装记录 -- Manjaro 双显卡驱动</title>
    <link href="/2020/9/8/%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95-Manjaro-%E5%8F%8C%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
    <url>/2020/9/8/%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95-Manjaro-%E5%8F%8C%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="主要步骤"><a class="header-anchor" href="#主要步骤">⚡</a>主要步骤</h2><ol><li><p>查看当前所用显卡</p> <div class="hljs"><pre><code class="hljs shell">glxinfo | grep "server glx vendor string"<span class="hljs-meta">#</span><span class="bash"> 如果出现以下信息则说明使用的 nvidia 显卡</span><span class="hljs-meta">#</span><span class="bash"> server glx vendor string: NVIDIA Corporation</span><span class="hljs-meta">#</span><span class="bash"> 如果显示 SGI 则为集显</span></code></pre></div></li><li><p>首先安装闭源驱动，卸载预装驱动</p><ul><li><p>如果可以进入图形界面，那么直接搜索 manjaro settings，找到 <code>硬件设定</code>，删除所有预装 nvidia 驱动</p></li><li><p>如果不能进入，则输入命令 <code>mhwd -li</code> 查看安装的 nvidia 驱动</p><p><img src="/img/nvidia1.png" srcset="/img/loading.gif" alt="nvidia1"></p><p>使用命令手动卸载</p>  <div class="hljs"><pre><code class="hljs shell">sudo mhwd -r pci &lt;$driverName&gt;</code></pre></div></li><li><p>自动安装</p>  <div class="hljs"><pre><code class="hljs shell">sudo mhwd -a pci nonfree 0300</code></pre></div></li></ul><p>安装完成之后的效果：</p><p><img src="/img/nvidia2.png" srcset="/img/loading.gif" alt="nvidia2"></p><p><img src="/img/nvidia_settings.png" srcset="/img/loading.gif" alt=""></p></li><li><p>安装并配置显卡管理软件 optimus<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>, 电源管理软件 bbswitch</p> <div class="hljs"><pre><code class="hljs shell">sudo pacman -S optimus-manager-qt optimus-manager bbswitchsudo systemctl enable optimus-manager.serviceoptimus-manager --set-startup nvidia</code></pre></div> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改 /etc/optimus-manager/optimus-manager.conf 文件如下，没有则新建文件</span>[intel]DRI=3accel=driver=modesettingmodeset=yestearfree=[nvidia]DPI=96PAT=yesallow_external_gpus=noignore_abi=nomodeset=yesoptions=overclocking[optimus]auto_logout=yespci_power_control=nopci_remove=nopci_reset=nostartup_auto_battery_mode=nvidiastartup_auto_extpower_mode=nvidiastartup_mode=nvidiaswitching=bbswitch</code></pre></div> <div class="hljs"><pre><code class="hljs shell">optimus-manager --switch nvidia</code></pre></div><p>如果上面这行命令运行有问题则使用下面的方法</p> <div class="hljs"><pre><code class="hljs shell">prime-offloadoptimus-manager --switch nvidia<span class="hljs-meta">#</span><span class="bash"> 然后会自动推出登录，如果没有退出登录要手动退出一下</span><span class="hljs-meta">#</span><span class="bash"> 再次登录后</span>prime-switchprime-offload</code></pre></div></li></ol><h2 id="一些错误记录"><a class="header-anchor" href="#一些错误记录">⚡</a>一些错误记录</h2><ol><li>如果删除驱动导致进入不了图形界面，可以使用其他 tty 进入命令行操作</li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://github.com/Askannz/optimus-manager#important--gnome-and-gdm-users" target="_blank" rel="noopener">optimus-manager 参考文档</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装记录 -- RocketMQ</title>
    <link href="/2020/9/7/%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95-RocketMQ/"/>
    <url>/2020/9/7/%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95-RocketMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="下载-RocketMQ-二进制包"><a class="header-anchor" href="#下载-RocketMQ-二进制包">⚡</a>下载 RocketMQ 二进制包</h2><p><a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/" target="_blank" rel="noopener">下载地址</a></p><p>找到一个镜像的 bin 文件下载到 opt 路径下</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建软链接</span>ln -s /opt/rocketmq-all-4.7.1-bin-release rocketMQ</code></pre></div><h2 id="测试"><a class="header-anchor" href="#测试">⚡</a>测试</h2><p><a href="https://rocketmq.apache.org/docs/quick-start/" target="_blank" rel="noopener">官方文档：快速开始</a></p><ol><li><p>开启 name server</p> <div class="hljs"><pre><code class="hljs shell">cd /opt/rocketMQ/binsh mqnamesrvtail -f ~/logs/rocketmqlogs/namesrv.log<span class="hljs-meta">#</span><span class="bash"> The Name Server boot success...</span></code></pre></div></li><li><p>开启 broker</p> <div class="hljs"><pre><code class="hljs shell">sh mqbroker -n localhost:9876tail -f ~/logs/rocketmqlogs/broker.log <span class="hljs-meta">#</span><span class="bash"> The broker[%s, 172.30.30.233:10911] boot success...</span></code></pre></div></li><li><p>发送/接收消息</p> <div class="hljs"><pre><code class="hljs shell">export NAMESRV_ADDR=localhost:9876sh tools.sh org.apache.rocketmq.example.quickstart.Producer<span class="hljs-meta">#</span><span class="bash"> SendResult [sendStatus=SEND_OK, msgId= ...</span>sh tools.sh org.apache.rocketmq.example.quickstart.Consumer<span class="hljs-meta">#</span><span class="bash"> ConsumeMessageThread_%d Receive New Messages: [MessageExt...</span></code></pre></div></li><li><p>关闭 server</p> <div class="hljs"><pre><code class="hljs shell">sh mqshutdown broker<span class="hljs-meta">#</span><span class="bash"> The mqbroker(36695) is running...</span><span class="hljs-meta">#</span><span class="bash"> Send shutdown request to mqbroker(36695) OK</span>sh mqshutdown namesrv<span class="hljs-meta">#</span><span class="bash"> The mqnamesrv(36664) is running...</span><span class="hljs-meta">#</span><span class="bash"> Send shutdown request to mqnamesrv(36664) OK</span></code></pre></div></li></ol><h2 id="后续开发设置"><a class="header-anchor" href="#后续开发设置">⚡</a>后续开发设置</h2><p>如果上面测试通过那程序就没问题了，但是每次手动开启很麻烦，我们就需要将 RocketMQ 加入开机启动项</p><ol><li><p>新增 service 文件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 进入 /usr/lib/systemd/system/文件夹</span>cd /usr/lib/systemd/systemsudo vim rocketmq-broker.service</code></pre></div> <div class="hljs"><pre><code class="hljs conf"># 文件内容[Unit]Description&#x3D;RocketMQ-brokerAfter&#x3D;network.target[Service]Type &#x3D; simpleExecStart&#x3D;&#x2F;opt&#x2F;rocketMQ&#x2F;bin&#x2F;mqbroker -n localhost:9876ExecStop&#x3D;&#x2F;opt&#x2F;rocketMQ&#x2F;bin&#x2F;mqshutdown brokerPrivateTmp&#x3D;true[Install]WantedBy&#x3D;multi-user.target</code></pre></div> <div class="hljs"><pre><code class="hljs shell">sudo vim rocketmq-namesrv.service<span class="hljs-meta">#</span><span class="bash"> 文件内容</span>[Unit]Description=RocketMQ-namesrvAfter=network.target[Service]Type = simpleExecStart=/opt/rocketMQ/bin/mqnamesrvExecStop=/opt/rocketMQ/bin/mqshutdown namesrvPrivateTmp=true[Install]WantedBy=multi-user.target</code></pre></div><p>修改 /etc/profiles 文件，在最后增加</p> <div class="hljs"><pre><code class="hljs shell">export NAMESRV_ADDR=localhost:9876export ROCKETMQ_HOME=/opt/rocketMQ</code></pre></div></li><li><p>修改程序中的 sh 脚本文件</p><p>正常情况下，直接使用命令</p> <div class="hljs"><pre><code class="hljs shell"> sudo systemctl start rocketmq-broker.service sudo systemctl start rocketmq-namesrv.service<span class="hljs-meta">#</span><span class="bash"> 查看启动情况</span>sudo systemctl status rocketmq-broker.servicesudo systemctl status rocketmq-namesrv.service</code></pre></div><p>一般这样就可以正常启动了，但是这里有些问题，RocketMQ 使用的 JDK 版本有问题，需要修改程序文件</p> <div class="hljs"><pre><code class="hljs shell">cd /opt/rocketMQ/binvim runserver.sh</code></pre></div><p>找到原文件和这个部分类似的地方，修改为如下配置</p> <div class="hljs"><pre><code class="hljs shell">[ ! -e "$JAVA_HOME/bin/java" ] &amp;&amp; JAVA_HOME=/opt/jdk<span class="hljs-meta">#</span><span class="bash">[ ! -e <span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; JAVA_HOME=/usr/java</span><span class="hljs-meta">#</span><span class="bash">[ ! -e <span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; error_exit <span class="hljs-string">"Please set the JAVA_HOME variable in your environment, We need java(x64)!"</span></span></code></pre></div><p>同理，对于 <a href="http://runbroker.sh" target="_blank" rel="noopener">runbroker.sh</a> 文件也类似</p><p><a href="https://stackoverflow.com/questions/42311180/rocketmq-quickstart-runbroker-sh-setting-too-large-java-heap" target="_blank" rel="noopener">如果发现 broker 被系统kill，结局方案：调小 jvm 堆</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 源码 -- Spring 初始化</title>
    <link href="/2020/8/31/Spring-%E6%BA%90%E7%A0%81-Spring-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2020/8/31/Spring-%E6%BA%90%E7%A0%81-Spring-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="入口代码"><a class="header-anchor" href="#入口代码">⚡</a>入口代码</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ind;<span class="hljs-keyword">import</span> ind.config.SpringConfig;<span class="hljs-keyword">import</span> ind.dao.TestDao;<span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinchao</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>&#123;        AnnotationConfigApplicationContext annotationConfigApplicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">/* refresh 方法用于初始化 Spring 容器 */</span>        annotationConfigApplicationContext.refresh();        TestDao bean = annotationConfigApplicationContext.getBean(TestDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        bean.query();    &#125;&#125;</code></pre></div><h2 id="调用链"><a class="header-anchor" href="#调用链">⚡</a>调用链</h2><ol><li><p>AnnotationConfigApplicationContext</p><p>这个类就完成了 Spring 的初始化</p><p><img src="/img/AnnotationConfigApplicationContext1.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/AnnotationConfigApplicationContext2.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/AnnotationConfigApplicationContext3.png" srcset="/img/loading.gif" alt=""></p><ol><li><p>先执行他的父类 GenericApplicationContext 的构造方法</p><p>这个类是 Spring 上下文的环境</p><ol><li><p>构造函数中一个成员变量 DefaultListableBeanFactory 被初始化</p><p>这个类是 Spring 的 Bean 工厂，里面有很多生成 Bean 所需要的原料</p><p>例如：用于存放 BeanName 和 <span id = "BeanDefinition">BeanDefinition</span> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 的 beanDefinitionMap</p><p><img src="/img/BeanFactory1.png" srcset="/img/loading.gif" alt=""></p><p>按照 Beam 的注册顺序组合的 BeanName 的 list</p><p><img src="/img/BeanFactory2.png" srcset="/img/loading.gif" alt=""></p><p>其他成员不一一列举 …</p></li></ol></li><li><p>继续在 AnnotationConfigApplicationContext 构造函数中有一个成员 AnnotatedBeanDefinitionReader 开始初始化</p><p>这个 reader 的作用就是作为一个注册器来向 Spring 注册一个 bean</p><p><img src="/img/AnnotatedBeanDefinitionReader1.png" srcset="/img/loading.gif" alt="AnnotatedBeanDefinitionReader1"></p><p>可以根据上图的 AnnotationConfigApplicationContext3 中看到，new AnnotatedBeanDefinitionReader(BeanDefinitionRegistry) 传入的参数是 <code>this</code>，即这个 AnnotationConfigApplicationContext 就是一个 BeanDefinitionRegistry，也可以通过图片 AnnotationConfigApplicationContext1 看到这个类本来就实现了 AnnotationConfigRegistry 接口 。</p><ol><li><p>构造继续委托到 AnnotationConfigUtils 的 registerAnnotationConfigProcessors 方法</p><p><img src="/img/AnnotatedBeanDefinitionReader2.png" srcset="/img/loading.gif" alt="AnnotatedBeanDefinitionReader2"></p><p><img src="/img/AnnotationConfigUtils.png" srcset="/img/loading.gif" alt=""></p></li></ol></li><li><p>AnnotationConfigApplicationContext 构造函数中另一个成员 ClassPathBeanDefinitionScanner 开始初始化</p><p>他能够扫描 BeanDefinition,能够扫描一个类或者包，并且转换成BeanDefinition</p></li></ol></li><li><p>AnnotationConfigApplicationContext 构造函数结束，完成类初始化之后，调用 register 方法</p><p><img src="/img/AnnotationConfigApplicationContext_register.png" srcset="/img/loading.gif" alt=""></p><p>进一步调用</p><p><img src="/img/AnnotatedBeanDefinitionReader_register.png" srcset="/img/loading.gif" alt=""></p></li><li><p>AnnotationConfigApplicationContext 调用 refresh() 方法</p><p>这个方法主要是准备好 Bean 工厂，并实例化 Bean 对象</p><p><img src="/img/AnnotationConfigApplicationContext_refresh.png" srcset="/img/loading.gif" alt=""></p><ol><li><p>prepareBeanFactory() 方法</p><p><img src="/img/AnnotationConfigApplicationContext_prepareBeanFactory.png" srcset="/img/loading.gif" alt=""></p><p>最后的 addBeanPostProcessor 方法只是把一个 BeanPostProcessor 实例加入到 BeanFactory 里面维护的一个 BeanPostProcessor 后置处理器 list 列表中</p><p>在 Bean 的实例化过程中会依次循环调用这个 list 中的 BeanPostProcessor 对象的方法</p></li><li><p>invokeBeanFactoryPostProcessors() 方法</p><p><img src="/img/AbstractApplicationContext_invokeBeanFactoryPostProcessors.png" srcset="/img/loading.gif" alt=""></p><ol><li><p>最后循环调用接口的实现类的接口重写方法，例如对于 ConfigurationClassPostProcessor 类：</p><p><img src="/img/ConfigurationClassPostProcessor_postProcessBeanDefinitionRegistry1.png" srcset="/img/loading.gif" alt=""></p><p>主要函数逻辑：</p><p><img src="/img/ConfigurationClassPostProcessor_postProcessBeanDefinitionRegistry2.png" srcset="/img/loading.gif" alt=""></p><ol><li><p>checkConfigurationClassCandidate 方法</p><p><img src="/img/ConfigurationClassUtils_checkConfigurationClassCandidate.png" srcset="/img/loading.gif" alt=""></p></li><li><p>isLiteConfigurationCandidate 方法</p><p><img src="/img/ConfigurationClassUtils_isLiteConfigurationCandidate.png" srcset="/img/loading.gif" alt=""></p></li><li><p>又是一个空壳 parse 函数调用</p><p><img src="/img/ConfigurationClassPostProcessor_parse.png" srcset="/img/loading.gif" alt="ConfigurationClassPostProcessor_parse"></p><p>被调函数:</p><p><img src="/img/ConfigurationClassPostProcessor_processConfigurationClass.png" srcset="/img/loading.gif" alt=""></p><ol><li><p>继续调用 doProcessConfigurationClass 方法实现主要逻辑</p><p><img src="/img/ConfigurationClassParser_doProcessConfigurationClass.png" srcset="/img/loading.gif" alt=""></p><ol><li><p>parse 方法处理 @ComponentScan 注解的属性信息，例如 basePackage 等</p><p><img src="/img/ComponentScanAnnotationParser_parse.png" srcset="/img/loading.gif" alt=""></p><ol><li><p>doScan()</p><p><img src="/img/ClassPathBeanDefinitionScanner_doScan.png" srcset="/img/loading.gif" alt=""></p><ol><li><p>findCandidateComponents 方法又调用 scanCandidateComponents，而这个方法最后实现了扫描 Bean 的主要逻辑，可以自己模拟一遍，此处不特别展示</p><p><img src="/img/ClassPathScanningCandidateComponentProvider_findCandidateComponents.png" srcset="/img/loading.gif" alt=""></p></li><li><p>其中调用的 registerBeanDefinition() 就是 BeanDefinitionReaderUtils 的 registerBeanDefinition 方法 (之前分析过)，将 Bean 加入到工厂里面</p></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><p>附录: Spring 扩展点<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>BeanDefinition: 是用于描述 Bean 的类。例如我们用 User.java (userName,password …) 是现实世界中对 <code>用户</code> 这个对象的抽象描述，而用 Class.java 来描述各种各样的 Java 类 (name,classLoader,useCaches …)，同理， BeanDefinition  (isPrimary,isLazyInit,getFactoryBeanName …) 就是用来描述交给 Spring 管理的 Bean。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Spring 扩展点：</p><ol><li>BeanPostProcessor</li><li>BeanFactoryPostProcessor</li><li>BeanDefinitionRegistryPostProcessor</li><li>FactoryBean</li></ol> <a href="#fnref2" class="footnote-backref">↩︎</a></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- BeanFactory 和 FactoryBean</title>
    <link href="/2020/8/28/Spring-%E7%9F%A5%E8%AF%86-BeanFactory-%E5%92%8C-FactoryBean/"/>
    <url>/2020/8/28/Spring-%E7%9F%A5%E8%AF%86-BeanFactory-%E5%92%8C-FactoryBean/</url>
    
    <content type="html"><![CDATA[<p>先说结论，他们的区别是：</p><p>FactoryBean 是一个接口，可以用于解决使用第三方依赖时，用户需要配置过多依赖的问题。<br>具体来说，它主要是第三方为了向使用方提供 Bean，然后使用方再去生成并配置好这个 FactoryBean 实例交给 Spring 管理，然后通过这个工厂 Bean 就能生成这个第三方需要使用的真正的 Bean 并交给 Spring 去管理了。</p><p>BeanFactory 是 Spring 容器产生 Bean 的顶层工厂接口，Spring IOC 容器中的 Bean 都由这个 BeanFactory 产生。</p><!-- more --><p>对于 FactoryBean，具体来说就是：如果你是第三方提供了某些功能能够让其他人使用你写的 jar 包，但是这些功能可能需要用户配置，例如 MyBatis 的数据库连接配置等。而且，配置好之后还需要去交给 Spring 去管理，那么用户就需要提供一个配置类来去定制他自己的功能或者使这个 jar 包真正产生作用。但是，用户需要去生成这个配置类，而这个配置类可能依赖了很多成员变量，它们可能是字符串，各种数组，甚至你写的配置类，你提供的功能依赖的第三方配置类等等，这样全都交给用户来去配置就会非常麻烦。那么，更好的办法是，你自己维护这个配置类并封装成一个 FactoryBean，用户只需要手动生成这个 FactoryBean，再自己制定一些必须的配置，然后可以用这个配置类注入到那个 FactoryBean 实例里面，就完成了功能的定制，最后用户只需要在这个函数上面加上 @Bean 注解即可把这个 FactoryBean 交给 Spring IOC 容器，而 Spring 就可以根据 FactoryBean 的特性来去真正生产出第三方需要的 Bean。</p><p>例如：</p><p>MyBatis 需要一个 SqlSessionFactory，而这个类有一些数据源的配置，但是，要生成这个配置类不仅仅需要配置数据源，还有一些其他的配置，如果都交给用户来去手动管理就会变得非常麻烦。</p><p>而 MyBatis 提供了一个 SqlSessionFactoryBean 的类，在这个类里面已经做了相关配置的设置，使用者只需要生成这个 SqlSessionFactoryBean 的实例，在注入配置实例就可以完成这个 FactoryBean 的生成，进而交给 Spring 管理从而真正生成 SqlSessionFactory。</p><div class="hljs"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactory</span><span class="hljs-params">()</span> </span>&#123;  SqlSessionFactoryBean factoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();  factoryBean.setDataSource(dataSource());  <span class="hljs-keyword">return</span> factoryBean.getObject();&#125;</code></pre></div><p>注意：</p><ol><li><p>根据 FactoryBean 的名称从 BeanFactory 中获取的实际上是 FactoryBean 的 getObject() 返回的对象，而不是 FactoryBean 本身，如果要获取 FactoryBean 对象，请使用 <code>&amp;BeanName</code> 来获取。</p></li><li><p>FactoryBean 的第三方实现类生成时必须足够简单，因为如果过于复杂那就还不如用户自己手动直接生成第三方所需 Bean 对象了。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- Spring AOP</title>
    <link href="/2020/8/26/Spring-%E7%9F%A5%E8%AF%86-Spring-AOP/"/>
    <url>/2020/8/26/Spring-%E7%9F%A5%E8%AF%86-Spring-AOP/</url>
    
    <content type="html"><![CDATA[<h2 id="相关概念"><a class="header-anchor" href="#相关概念">⚡</a>相关概念</h2><h3 id="Aop是什么"><a class="header-anchor" href="#Aop是什么">⚡</a>Aop是什么</h3><p>与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。</p><h3 id="好处"><a class="header-anchor" href="#好处">⚡</a>好处</h3><p>对比oop,aop 能够将横切性的问题和业务逻辑解偶，减少模板代码，提高可维护性和开发效率</p><h3 id="使用场景"><a class="header-anchor" href="#使用场景">⚡</a>使用场景</h3><ol><li>日志记录</li><li>权限验证</li><li>效率检查</li><li>事务管理</li><li>exception</li></ol><h3 id="AOP-底层技术"><a class="header-anchor" href="#AOP-底层技术">⚡</a>AOP 底层技术</h3><p>Spring 默认使用 JDK 动态代理，也可以使用 CGLib，二者都是动态代理，在运行时初始化时期进行织入。</p><p><a href="https://www.cnblogs.com/echola/p/11004069.html#popular" target="_blank" rel="noopener">博客</a></p><ul><li><p>区别</p><p><img src="/img/aop.jpeg" srcset="/img/loading.gif" alt=""></p></li><li><p>JDK 动态代理是通过接口反射得到 byte 数组，存放代理类的字节码，然后通过 native 方法把字节码转化成 class 对象。</p></li></ul><h3 id="Spring-AOP-和-AspectJ"><a class="header-anchor" href="#Spring-AOP-和-AspectJ">⚡</a>Spring AOP 和 AspectJ</h3><p>AOP 是一种概念，Spring AOP 和 AspectJ，Javassist 等都是具体实现。</p><p>Spring 仅仅是借用 AspectJ 的注解语法而已，Spring 使用 JDK 动态代理或者 CGLib 动态代理，是结合 Spring IOC 容器的动态织入；而 AspectJ 是一个 AOP 框架，是使用静态织入的方式。</p><p><a href="https://juejin.im/post/6844903549172711437" target="_blank" rel="noopener">博客</a></p><h3 id="术语解释"><a class="header-anchor" href="#术语解释">⚡</a>术语解释</h3><ol><li><p>aspect:切面，一定要给spring去管理</p><p>切面抽象为类</p></li><li><p>pointcut:切点表示连接点的集合</p><p>PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量</p></li><li><p>Joinpoint:连接点</p><p>目标对象中的方法<br>JoinPoint是要关注和增强的方法，也就是我们要作用的点</p></li><li><p>Weaving :织入</p><p>把代理逻辑加入到目标对象上的过程叫做织入</p></li><li><p>target 目标对象，原始对象</p></li><li><p>aop Proxy 代理对象，包含了原始对象的代码和增加后的代码的那个对象</p></li><li><p>advice:通知</p><p>增加的逻辑和加入到原方法的位置</p><ol><li><p>advice通知类型:</p></li><li><p>Before：连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</p></li><li><p>After：连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</p></li><li><p>After throwing：执行抛出异常的时候</p></li><li><p>After (finally)：无论连接点是正常退出还是异常退出，都会执行</p></li><li><p>Around advice：围绕连接点执行，例如方法调用。</p><p>这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</p></li><li><p>ProceedingJoinPoint 和JoinPoint的区别:</p><p>ProceedingJoinPoint 继承了JoinPoint,proceed()这个是aop代理链执行的方法。并扩充实现了proceed()方法，用于继续执行连接点。JoinPoint仅能获取相关参数，无法执行连接点。</p></li><li><p>JoinPoint的方法</p><ol><li><p>java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；</p></li><li><p>Signature getSignature() ：获取连接点的方法签名对象；</p></li><li><p>java.lang.Object getTarget() ：获取连接点所在的目标对象；</p></li><li><p>java.lang.Object getThis() ：获取代理对象本身；</p></li><li><p>proceed()有重载,有个带参数的方法,可以在 AOP 的实现逻辑中修改目标方法的的参数，再通过 proceed(Object[] object) 方法传入修改的参数。</p></li></ol></li></ol></li></ol><h2 id="Spring-AOP-使用步骤"><a class="header-anchor" href="#Spring-AOP-使用步骤">⚡</a>Spring AOP 使用步骤</h2><h3 id="基本步骤"><a class="header-anchor" href="#基本步骤">⚡</a>基本步骤</h3><h4 id="开启-AspectJ-注解支持"><a class="header-anchor" href="#开启-AspectJ-注解支持">⚡</a>开启 @AspectJ 注解支持</h4><div class="hljs"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAspectJAutoProxy</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;&#125;</code></pre></div><h4 id="声明切面-aspect"><a class="header-anchor" href="#声明切面-aspect">⚡</a>声明切面 aspect</h4><div class="hljs"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> org.xyz;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotVeryUsefulAspect</span> </span>&#123;&#125;</code></pre></div><h4 id="声明切点-pointcut"><a class="header-anchor" href="#声明切点-pointcut">⚡</a>声明切点 pointcut</h4><div class="hljs"><pre><code class="hljs Java"><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* transfer(..))"</span>) <span class="hljs-comment">// the pointcut expression</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anyOldTransfer</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// the pointcut signature</span></code></pre></div><h4 id="声明通知-advice"><a class="header-anchor" href="#声明通知-advice">⚡</a>声明通知 advice</h4><p>例如：声明一个 before advice</p><div class="hljs"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeforeExample</span> </span>&#123;    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"com.xyz.myapp.CommonPointcuts.dataAccessOperation()"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAccessCheck</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><h3 id="Introductions-引入"><a class="header-anchor" href="#Introductions-引入">⚡</a>Introductions 引入</h3><blockquote><p>Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implementation of that interface on behalf of those objects.</p><p>引入（在AspectJ中称为类型间声明）使切面可以声明通知对象（目标对象）实现给定的接口，并且使切面提供该接口的实现给那些对象。</p></blockquote><div class="hljs"><pre><code class="hljs Java"><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsageTracking</span> </span>&#123;    <span class="hljs-comment">// 使用这个注解使得 service 包下面所有的类都加入了 TestDao 接口的方法声明，并且加入了实现类 TestDaoImpl 中的逻辑</span>    <span class="hljs-comment">// 相当于加入了父类扩展</span>    <span class="hljs-meta">@DeclareParents</span>(value=<span class="hljs-string">"com.xzy.myapp.service.*+"</span>,    defaultImpl=TestDaoImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">TestDao</span> <span class="hljs-title">dao</span></span>;&#125;</code></pre></div><h3 id="Aspect-Instantiation-Models-切面实例化模型"><a class="header-anchor" href="#Aspect-Instantiation-Models-切面实例化模型">⚡</a>Aspect Instantiation Models 切面实例化模型</h3><blockquote><p>By default, there is a single instance of each aspect within the application context. AspectJ calls this the singleton instantiation model. It is possible to define aspects with alternate lifecycles. Spring supports AspectJ’s <code>perthis</code> and pertarget instantiation models; percflow, percflowbelow, and pertypewithin are not currently supported.</p><p>默认情况下，应用程序上下文中每个切面都有一个实例。AspectJ将此称为单例实例化模型。也可以使用备用生命周期来定义方面。Spring支持AspectJ的perthis和pertarget实例化模型；目前不支持percflow，percflowbelow和pertypewithin。</p></blockquote><ul><li><p>要求：</p><ol><li>AspectJ对象的注入类型为prototype</li><li>目标对象也必须是prototype的</li></ol><p>原因为：只有目标对象是原型模式的，每次getBean得到的对象才是不一样的，由此针对每个对象就会产生新的切面对象，才能产生不同的切面结果。</p></li><li><p>场景：</p><p>不常用，当有共享变量的时候，并且目标对象是 prototype 每次需要产生不同切面时使用。</p>  <div class="hljs"><pre><code class="hljs Java"> <span class="hljs-comment">// 使用方式如下：</span><span class="hljs-meta">@Aspect</span>(<span class="hljs-string">"perthis(this(com.chenss.dao.IndexDaoImpl))"</span>)</code></pre></div></li></ul><h3 id="支持的-Pointcut-类型"><a class="header-anchor" href="#支持的-Pointcut-类型">⚡</a>支持的 Pointcut 类型</h3><ol><li><p>execution: For matching method execution join points. This is the primary pointcut designator to use when working with Spring AOP.</p><p>用于匹配方法执行 join points连接点，最小粒度方法，在aop中主要使用。</p><p>格式： execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</p><p>这里问号表示当前项可以有也可以没有，其中各项的语义如下</p><p>modifiers-pattern：方法的可见性，如public，protected；<br>ret-type-pattern：方法的返回值类型，如int，void等；<br>declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；<br>name-pattern：方法名类型，如buisinessService()；<br>param-pattern：方法的参数类型，如java.lang.String；<br>throws-pattern：方法抛出的异常类型，如java.lang.Exception；</p><ul><li><p>example:</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.*.*(..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的任意方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public * com.chenss.dao.*.*(..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的public方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public * com.chenss.dao.*.*())"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.*.*(java.lang.String, ..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.*.*(java.lang.String))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.*.*(java.lang.String))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public * *(..))"</span>)<span class="hljs-comment">//匹配任意的public方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* te*(..))"</span>)<span class="hljs-comment">//匹配任意的以te开头的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao.IndexDao.*(..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao.IndexDao接口中任意的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.chenss.dao..*.*(..))"</span>)<span class="hljs-comment">//匹配com.chenss.dao包及其子包中任意的方法</span></code></pre></div><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples</a></p></li></ul></li><li><p>within: Limits matching to join points within certain types (the execution of a method declared within a matching type when using Spring AOP).</p><p>表达式的最小粒度为类</p> <div class="hljs"><pre><code class="hljs Java"><span class="hljs-comment">// within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"within(com.chenss.dao.*)"</span>)<span class="hljs-comment">//匹配com.chenss.dao包中的任意方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"within(com.chenss.dao..*)"</span>)<span class="hljs-comment">//匹配com.chenss.dao包及其子包中的任意方法</span></code></pre></div></li><li><p>this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.</p><p>表示代理对象</p><p>使用 JDK 动态代理时，指向接口和继承的父类proxy<br>使用 CGLib 动态代理时，指向接口和子类(没有继承proxy)</p></li><li><p>target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.</p><p>指向接口和子类<br>表示目标对象</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/* 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理</span><span class="hljs-comment">* JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。</span><span class="hljs-comment">* 而CGLIB继承被代理的类来实现。</span><span class="hljs-comment">* 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。</span><span class="hljs-comment">* 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"target(com.chenss.dao.IndexDaoImpl)"</span>)<span class="hljs-comment">//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"this(com.chenss.dao.IndexDaoImpl)"</span>)<span class="hljs-comment">//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"@target(com.chenss.anno.Chenss)"</span>)<span class="hljs-comment">//具有@Chenss的目标对象中的任意方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"@within(com.chenss.anno.Chenss)"</span>)<span class="hljs-comment">//等同于@target</span></code></pre></div></li><li><p>args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.</p><p>args表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关</p> <div class="hljs"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><span class="hljs-comment">* args同execution不同的地方在于：</span><span class="hljs-comment">* args匹配的是运行时传递给方法的参数类型</span><span class="hljs-comment">* execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"args(java.io.Serializable)"</span>)<span class="hljs-comment">//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"@args(com.chenss.anno.Chenss)"</span>)<span class="hljs-comment">//接受一个参数，并且传递的参数的运行时类型具有@Classified</span></code></pre></div></li><li><p>@target: Limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type.</p><p>@target(里面是一个注解类xx,表示所有加了xx注解的类,和包名无关)</p></li><li><p>@args: Limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given types.</p></li><li><p>@within: Limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP).</p></li><li><p>@annotation: Limits matching to join points where the subject of the join point (the method being run in Spring AOP) has the given annotation.</p></li></ol><h2 id="其他注意要点"><a class="header-anchor" href="#其他注意要点">⚡</a>其他注意要点</h2><h3 id="通知注解执行顺序"><a class="header-anchor" href="#通知注解执行顺序">⚡</a>通知注解执行顺序</h3><ul><li><p>正常情况执行执行顺序：</p><p><img src="/img/aop2.png" srcset="/img/loading.gif" alt=""></p></li><li><p>异常情况：</p><p><img src="/img/aop3.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="声明式事务-Transactional-注解"><a class="header-anchor" href="#声明式事务-Transactional-注解">⚡</a>声明式事务 @Transactional 注解</h3><p>声明式事务和普通 AOP 有些区别，后者对于代理逻辑的增强可以是在目标方法调用之前(@Before)，或者目标方法调用之后(@After)，或者目标方法的前后(@Around)，而对于声明式事务，则是在目标方法的里面某一段或者某些部分加入代理逻辑。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bug记录 -- MyBaits 报错 -- Cannot get Configuration as configuration factory was not set</title>
    <link href="/2020/8/14/Bug%E8%AE%B0%E5%BD%95-MyBaits-%E6%8A%A5%E9%94%99-Cannot-get-Configuration-as-configuration-factory-was-not-set/"/>
    <url>/2020/8/14/Bug%E8%AE%B0%E5%BD%95-MyBaits-%E6%8A%A5%E9%94%99-Cannot-get-Configuration-as-configuration-factory-was-not-set/</url>
    
    <content type="html"><![CDATA[<h2 id="错误复现"><a class="header-anchor" href="#错误复现">⚡</a>错误复现</h2><!-- more --><ul><li><p>第一次查询数据库，没问题</p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_5.png" srcset="/img/loading.gif" alt=""></p><p>日志：</p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_6.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_7.png" srcset="/img/loading.gif" alt=""></p></li><li><p>第二次则503</p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_8.png" srcset="/img/loading.gif" alt=""></p><p>日志：</p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_3.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_4.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_2.png" srcset="/img/loading.gif" alt=""></p></li></ul><h2 id="出错原因："><a class="header-anchor" href="#出错原因：">⚡</a>出错原因：</h2><p><img src="/img/MyBatis_Cannot_get_Configuration_as_configuration_factory_was_not_set_1.png" srcset="/img/loading.gif" alt=""></p><p>加入 <code>&lt;cache/&gt;</code> 标签并在 MyBatis 配置文件中开启了二级缓存时，如果这个 mapper 有用到 lazyLoading 相关的技术，比如 resultMap 里面的 <code>fetchType = lazy</code> 就会出现这样的错误</p><h2 id="解决办法"><a class="header-anchor" href="#解决办法">⚡</a>解决办法</h2><blockquote><p>Apparently, the issue is on the lazyLoading functionality code where some race condition trigger the issue. There appears to be a multi-thread related bug in the lazyFunctionality of MyBatis, so deactivating it works as a workaround.<br>显然，问题出在延迟加载功能代码上，其中某些竞争条件触发了该问题。MyBatis 的懒加载功能中似乎存在与多线程相关的错误，因此将其停用可以作为一种解决方法。</p></blockquote><ol><li><p>不使用 <code>cache</code> 标签</p></li><li><p>不使用 lazyLoading 相关配置</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ORM 解决业务需求带来的 N+1 问题</title>
    <link href="/2020/8/13/ORM%E8%A7%A3%E5%86%B3%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82%E5%B8%A6%E6%9D%A5%E7%9A%84-N-1-%E9%97%AE%E9%A2%98/"/>
    <url>/2020/8/13/ORM%E8%A7%A3%E5%86%B3%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82%E5%B8%A6%E6%9D%A5%E7%9A%84-N-1-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-1-N-问题"><a class="header-anchor" href="#什么是-1-N-问题">⚡</a>什么是 1+N 问题</h2><p><img src="/img/ORM_N+!_Problem1.png" srcset="/img/loading.gif" alt=""></p><p>如图，user 表为用户的基本信息表，role 则是系统内所有角色信息，而用户可能会有多种角色，根据数据库范式，user 和 role 通过 user_role 表相关联，代表一个用户可以有多个角色，一个角色也可以有多个用户。</p><p>这样建表，虽然遵循了范式，提供了系统的扩展性，但是有一个问题，当我们想要去查找一个用户所有的角色信息时，需要先从 user_role 表里面找到这个用户的所有角色id（role_id），然后再根据 role_id 去 role 表里面找到相关的角色信息。</p><p><img src="/img/ORM_N+!_Problem2.png" srcset="/img/loading.gif" alt=""></p><p>如图，最后两个字段的信息需要连接查询才能得到</p><p>这样，就产生了 1+N 问题：查找一个用户的角色要先根据 user_id 查找到 N 个 role_id，再对每个 role_id 查找，总共查找了 1+N 次</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment"># 1 次查询</span><span class="hljs-keyword">select</span> user.*,role_id<span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> user_role <span class="hljs-keyword">on</span> <span class="hljs-keyword">id</span> = user_id<span class="hljs-keyword">where</span> user_id = <span class="hljs-number">1</span>;<span class="hljs-comment"># N 层循环(Java 代码级别而非数据库级别)</span>for(1:N)&#123;    <span class="hljs-keyword">select</span> role.* <span class="hljs-keyword">from</span> <span class="hljs-keyword">role</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">role</span> = <span class="hljs-keyword">var</span>&#125;</code></pre></div><h2 id="如何解决"><a class="header-anchor" href="#如何解决">⚡</a>如何解决</h2><h3 id="SQL（连接查询）不推荐"><a class="header-anchor" href="#SQL（连接查询）不推荐">⚡</a>SQL（连接查询）<strong>不推荐</strong></h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> u.id <span class="hljs-keyword">as</span> <span class="hljs-keyword">id</span>,    user_name,    user_real_name,    user_location,    user_telephone,    role_id,    role_rank,    role_name,    role_description    <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">as</span> u <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> user_role <span class="hljs-keyword">as</span> ur    <span class="hljs-keyword">on</span> u.id = ur.user_id    <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">role</span> <span class="hljs-keyword">as</span> r    <span class="hljs-keyword">on</span> r.id = ur.role_id    <span class="hljs-keyword">where</span> u.id = ?</code></pre></div><p>但是，这样还是会有一些瑕疵。</p><p><img src="/img/ORM_N+!_Problem6.png" srcset="/img/loading.gif" alt=""></p><p>即：前面 user 表的基本信息全部都重复了，而只有后面 role_id 和 role_rank 等信息是不同的，这样只能返回多个部分属性相同的实体集合(collection),对于上面要求的 POJO 还要再进行处理，这个 SQL 和 POJO 并不能对应上，本质上不能代表我们的需求，而且，我们在代码层用 Java 再对返回的 List 或者 Set 进行处理时，又明显会比数据库层慢一些，而且处理也会有些麻烦。</p><p>期望的解决方案是可以对 user 表进行分组，得到一行 user 基本信息，然后把 user_id 这个字段变成一个集合，其他的字段例如 user_rank 也同理变成集合，但是，mysql 没有这样的聚集函数或者分组函数。而且，就算有这样的函数，user_id 和 user_rank 处理之后能否对应也是一个问题。</p><h3 id="ORM"><a class="header-anchor" href="#ORM">⚡</a>ORM</h3><h4 id="MyBatis-集合的嵌套-select-查询-懒加载"><a class="header-anchor" href="#MyBatis-集合的嵌套-select-查询-懒加载">⚡</a>MyBatis 集合的嵌套 select 查询+懒加载</h4><p>UserMapper.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"UserPublicResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.cloud.farming.entity.model.UserPublic"</span>&gt;</span><span class="hljs-comment">&lt;!-- id 和 result 两者之间的唯一不同是，id 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userName"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_real_name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userRealName"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_location"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userLocation"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_telephone"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userTelephone"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleIdSet"</span></span><span class="hljs-tag">            <span class="hljs-attr">javaType</span>=<span class="hljs-string">"java.util.Set"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"com.cloud.farming.repository.UserRoleMapper.findRoleIdSetByUserId"</span></span><span class="hljs-tag">            <span class="hljs-attr">ofType</span>=<span class="hljs-string">"java.lang.Integer"</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">"lazy"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleSet"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.cloud.farming.entity.model.Role"</span></span><span class="hljs-tag">            <span class="hljs-attr">select</span>=<span class="hljs-string">"com.cloud.farming.repository.UserRoleMapper.findRoleSetByUserId"</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">"lazy"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findUserPublicByUserId"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"UserPublicResultMap"</span>&gt;</span>    select id, user_location, user_telephone, user_name, user_real_name    from user    where id = #&#123;userId,jdbcType=BIGINT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>UserRoleMapper.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- UserRoleMapper.findRoleIdSetByUserId --&gt;</span><span class="hljs-comment">&lt;!-- 返回值是 Set&lt;Integer&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findRoleIdSetByUserId"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"java.lang.Integer"</span>&gt;</span>    select role_id    from user_role    where user_id = #&#123;userId,jdbcType=BIGINT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-comment">&lt;!-- UserRoleMapper.findRoleSetByUserId --&gt;</span><span class="hljs-comment">&lt;!-- 返回值是 Set&lt;Role&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findRoleSetByUserId"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"com.cloud.farming.repository.RoleMapper.BaseResultMap"</span>&gt;</span>    select role.id, role_rank, role_name, role_description    from user_role    left join role    on user_role.role_id = role.id    where user_id = #&#123;userId,jdbcType=BIGINT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>上面的 SQL 语句新增的实际上只有一条即，UerMapper 的findUserPublicByUserId，其他 UserRoleMapper 都是之前已有的。</p><p>结果：</p><p><img src="/img/ORM_N+!_Problem3.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/ORM_N+!_Problem4.png" srcset="/img/loading.gif" alt=""></p><p>这样，直接调用 UserMapper.xml 的查询语句findUserPublicByUserId时，对于 association 的字段可以由 MyBatis 帮我们执行，不需要我们手动写连接查询，从另一个角度说，如果像上面第一种方法，一条 SQL 语句中连接查询根本无法得到我们想要的格式的数据，使用这个方式也可以很好的解决问题。</p><p>但是这样看起来只是将 SQL 复用以及避免了单个语句中的连接查询，应该还是存在 1+N 问题，而且这样感觉将问题反而表现的更加明显了。</p><p>一个在某些情况下可用的方案是懒加载。association 标签中的 fetchType = lazy 则是处于性能的考虑，如果我们有时不需要这些信息，没有调用相关字段的 get 方法，那么此时由于懒加载直接不进行 association 的查询，字段返回空，这样可以大幅减少数据库的 IO 操作也就从源头上解决了 1+N 的问题。</p><p>当然，这样做的前提是懒加载字段确实不需要才可用。</p><p>然而，退一步说，即使没有懒加载，如果二次查询字段使用了 MyBatis 的二级缓存，那么直接命中缓存性能会更高；或者，如果二次查询的字段使用了外键或者索引，这样效率说不定也会比多表连接好一些，可读性，复用性也会更好。</p><h4 id="集合的嵌套结果映射"><a class="header-anchor" href="#集合的嵌套结果映射">⚡</a>集合的嵌套结果映射</h4><p>UserMapper.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"UserPublicResultMapWithoutN+1"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.cloud.farming.entity.model.UserPublic"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userName"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_real_name"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userRealName"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_location"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userLocation"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_telephone"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userTelephone"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleSet"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.cloud.farming.entity.model.Role"</span></span><span class="hljs-tag">            <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"com.cloud.farming.repository.RoleMapper.RoleResultMap"</span>/&gt;</span><span class="hljs-comment">&lt;!--                    resultSet="roles" column="role_id" foreignColumn="user_id"/&gt;--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleIdSet"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"java.lang.Integer"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"java.util.Set"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"role_id"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"role_id"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"java.lang.Integer"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"value"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findUserRolesByUserIdWithoutN"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"UserPublicResultMapWithoutN+1"</span>&gt;</span>    select u.id as id,    user_name,    user_real_name,    user_location,    user_telephone,    role_id,    role_rank,    role_name,    role_description    from user as u left join user_role as ur    on u.id = ur.user_id    left join role as r    on r.id = ur.role_id    where u.id = #&#123;userId,jdbcType=BIGINT&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>这样直接关联再配合 MyBatis 的缓存 <code>&lt;cache/&gt;</code>，可以将性能调整到极致。</p><p>第一次查询数据库：</p><p><img src="/img/ORM_N+!_Problem7.png" srcset="/img/loading.gif" alt=""></p><p>第二次直接命中缓存，没有查询数据库</p><p><img src="/img/ORM_N+!_Problem8.png" srcset="/img/loading.gif" alt=""></p><h4 id="集合的多结果集"><a class="header-anchor" href="#集合的多结果集">⚡</a>集合的多结果集</h4><p>官方文档原话：</p><blockquote><p>从版本 3.2.3 开始，MyBatis 提供了另一种解决 N+1 查询问题的方法。</p></blockquote><blockquote><p>某些数据库允许存储过程返回多个结果集，或一次性执行多个语句，每个语句返回一个结果集。 我们可以利用这个特性，在不使用连接的情况下，只访问数据库一次就能获得相关数据。</p></blockquote><p>存储过程要比单个 SQL 快</p><p>虽然存储过程有三个好处：安全，简单，高性能，但是阿里归约中并不推荐，原因是难以调试和扩展，更没有移植性.</p><p>然而，这个规约我认为要视情况而定，大部分情况下都没有移植或者扩展的要求。不过每次去写一个存储过程也的确有些麻烦，而且此处我也尝试测试使用过，但是有报错的问题，没有多浪费时间解决，先留做记录，如果后续需要可以尝试使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- 相关子查询优化</title>
    <link href="/2020/7/27/MySQL-%E7%9F%A5%E8%AF%86-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <url>/2020/7/27/MySQL-%E7%9F%A5%E8%AF%86-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="相关子查询的-MySQL-错误优化-MySQL-5-7-以后不适用"><a class="header-anchor" href="#相关子查询的-MySQL-错误优化-MySQL-5-7-以后不适用">⚡</a>相关子查询的 MySQL 错误优化(MySQL 5.7 以后不适用)</h2><a id="more"></a><h3 id="问题"><a class="header-anchor" href="#问题">⚡</a>问题</h3><p>对于不相关子查询来说,我们会认为先执行子查询,在执行外层查询,但是实际不会: MySQL 会将相关的外层表压缩到子查询中,它认为这样可以更高效地查找到数据行</p><p>例如:</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> test.tabname2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'name'</span>);<span class="hljs-comment"># MySQL 不会这样执行:</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">from</span> test.tabname2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'name'</span>;<span class="hljs-comment"># 内层查询结果：1,3,5,7,9,11,13,15,17,1</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>);<span class="hljs-comment"># MySQL 实际执行:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname2     <span class="hljs-keyword">where</span> tabname.id=tabname2.id     <span class="hljs-keyword">and</span> tabname2.name=<span class="hljs-string">'name'</span>);<span class="hljs-comment"># 这时,子查询先根据 id 来关联外部表 tabname ,通过 explain 我们可以看到子查询是一个相关子查询(DEPENDENT SUBQUERY)</span><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> test.tabname2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'name'</span>);<span class="hljs-comment"># +----+--------------------+----------+-----------------+---------------+---------+---------+------+------+-------------+</span><span class="hljs-comment"># | id | select_type        | table    | type            | possible_keys | key     | key_len | ref  | rows | Extra       |</span><span class="hljs-comment"># +----+--------------------+----------+-----------------+---------------+---------+---------+------+------+-------------+</span><span class="hljs-comment"># |  1 | PRIMARY            | tabname  | ALL             | NULL          | NULL    | NULL    | NULL |   30 | Using where | </span><span class="hljs-comment"># |  2 | DEPENDENT SUBQUERY | tabname2 | unique_subquery | PRIMARY       | PRIMARY | 4       | func |    1 | Using where | </span><span class="hljs-comment"># +----+--------------------+----------+-----------------+---------------+---------+---------+------+------+-------------+</span><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname<span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.tabname2    <span class="hljs-keyword">where</span> tabname.id=tabname2.id <span class="hljs-keyword">and</span> tabname2.name=<span class="hljs-string">'name'</span>    );<span class="hljs-comment"># +----+--------------------+----------+--------+---------------+---------+---------+-----------------+------+-------------+</span><span class="hljs-comment"># | id | select_type        | table    | type   | possible_keys | key     | key_len | ref             | rows | Extra       |</span><span class="hljs-comment"># +----+--------------------+----------+--------+---------------+---------+---------+-----------------+------+-------------+</span><span class="hljs-comment"># |  1 | PRIMARY            | tabname  | ALL    | NULL          | NULL    | NULL    | NULL            |   30 | Using where | </span><span class="hljs-comment"># |  2 | DEPENDENT SUBQUERY | tabname2 | eq_ref | PRIMARY       | PRIMARY | 4       | test.tabname.id |    1 | Using where | </span><span class="hljs-comment"># +----+--------------------+----------+--------+---------------+---------+---------+-----------------+------+-------------+</span><span class="hljs-comment"># 然而,MySQL 的优化把不相关子查询变成了相关子查询,效率更低: 先扫描外层表,再逐个匹配内层表,如果外层表很大,这样效率降低更加明显</span></code></pre></div><h3 id="解决方案-使用连接查询"><a class="header-anchor" href="#解决方案-使用连接查询">⚡</a>解决方案:使用连接查询</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> tabname. * <span class="hljs-keyword">from</span> test.tabname <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> test.tabname2 <span class="hljs-keyword">using</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">where</span> tabname2.name=<span class="hljs-string">'name'</span>;<span class="hljs-comment"># +----+-------------+----------+--------+---------------+---------+---------+------------------+------+-------------+</span><span class="hljs-comment"># | id | select_type | table    | type   | possible_keys | key     | key_len | ref              | rows | Extra       |</span><span class="hljs-comment"># +----+-------------+----------+--------+---------------+---------+---------+------------------+------+-------------+</span><span class="hljs-comment"># |  1 | SIMPLE      | tabname2 | ALL    | PRIMARY       | NULL    | NULL    | NULL             |   20 | Using where | </span><span class="hljs-comment"># |  1 | SIMPLE      | tabname  | eq_ref | PRIMARY       | PRIMARY | 4       | test.tabname2.id |    1 |             | </span><span class="hljs-comment"># +----+-------------+----------+--------+---------------+---------+---------+------------------+------+-------------+</span><span class="hljs-comment"># 这次可以看到,select_type 变为两个简单查询simple</span><span class="hljs-comment"># 首先访问的是 tabname2,因为表 tabname2 的记录比较少,只需该表全表扫描,再查询子查询</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 博客( fluid 主题)升级记录</title>
    <link href="/2020/7/26/hexo-%E5%8D%9A%E5%AE%A2(fluid%E4%B8%BB%E9%A2%98)%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/7/26/hexo-%E5%8D%9A%E5%AE%A2(fluid%E4%B8%BB%E9%A2%98)%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p>更新相关软件版本</p> <!-- more --> <div class="hljs"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 安装更新 npm</span>sudo <span class="hljs-built_in">npm</span> install -g <span class="hljs-built_in">npm</span><span class="hljs-comment"># 安装更新 npm-check</span>sudo <span class="hljs-built_in">npm</span> install -g <span class="hljs-built_in">npm</span>-check<span class="hljs-comment"># 安装更新 npm-upgrade</span>sudo <span class="hljs-built_in">npm</span> install -g <span class="hljs-built_in">npm</span>-upgrade<span class="hljs-comment"># 运行 check</span>sudo <span class="hljs-built_in">npm</span>-check<span class="hljs-comment"># 运行 upgrade</span>sudo <span class="hljs-built_in">npm</span>-upgrade<span class="hljs-comment"># 更新 upgrade(全局组件)</span>sudo <span class="hljs-built_in">npm</span> update -g<span class="hljs-comment"># 更新 upgrade (生产环境依赖包)</span>sudo <span class="hljs-built_in">npm</span> update --save<span class="hljs-comment"># 更新 hexo-cli</span>sudo <span class="hljs-built_in">npm</span> i hexo-cli -g</code></pre></div></li><li><p>更新主题</p><ol><li><p>去 github 上面下载,直接解压包到相应 hexo 的 theme 文件夹</p></li><li><p>修改 hexo 根目录的 _config.yml 文件,设置最新主题名</p></li><li><p>运行 <code>hexo clean</code>,<code>hexo s</code>查看即可</p></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- explain 执行计划</title>
    <link href="/2020/7/26/MySQL-%E7%9F%A5%E8%AF%86-explain-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2020/7/26/MySQL-%E7%9F%A5%E8%AF%86-explain-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="explain-查询字段"><a class="header-anchor" href="#explain-查询字段">⚡</a>explain 查询字段</h2><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">The SELECT identifier:select 标识符,表示执行顺序</td></tr><tr><td style="text-align:center">select_type</td><td style="text-align:center">The SELECT type:查询类型</td></tr><tr><td style="text-align:center">table</td><td style="text-align:center">The table for the output row: 表名</td></tr><tr><td style="text-align:center">partitions</td><td style="text-align:center">The matching partitions:使用的哪些分区(对于非分区表值为null)</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">The join type: join 类型</td></tr><tr><td style="text-align:center">possible_keys</td><td style="text-align:center">The possible indexes to choose:可能用到的索引</td></tr><tr><td style="text-align:center">key</td><td style="text-align:center">The index actually chosen:实际选择的索引</td></tr><tr><td style="text-align:center">key_length</td><td style="text-align:center">The length of the chosen key:所选择索引的长度</td></tr><tr><td style="text-align:center">ref</td><td style="text-align:center">The columns compared to the index :显示索引的哪一列被使用了,可以是一个常数</td></tr><tr><td style="text-align:center">rows</td><td style="text-align:center">Estimate of rows to be examined:预计检查行数</td></tr><tr><td style="text-align:center">filtered</td><td style="text-align:center">Percentage of rows filtered by table condition:通过过滤条件之后对比总数的百分比</td></tr><tr><td style="text-align:center">Extra</td><td style="text-align:center">Additional information:其他信息,如 using file sort,using index,using index condition,using join buffer,using where</td></tr></tbody></table><h3 id="id"><a class="header-anchor" href="#id">⚡</a>id</h3><blockquote><p>The SELECT identifier. This is the sequential number of the SELECT within the query. The value can be NULL if the row refers to the union result of other rows. In this case, the table column shows a value like &lt;unionM,N&gt; to indicate that the row refers to the union of the rows with id values of M and N.</p><p>翻译:<br>id 是 SELECT 的标识符.它是查询中 SELECT 的<strong>顺序号</strong></p><p>如果该行引用其他行的并集结果,则该值<em>可以为 NULL</em>,在这种情况下,table 字段会显示类似&lt;unionM，N&gt;的值，以表示该行引用 ID 值为 M 和 N 的行的并集。</p></blockquote><p>也就是说,id 数字越大越先执行,如果说数字一样大,那么就从上往下依次执行,还有一种为 null 的情况,是由于这一行会 union 其他行的结果(其对应 select_type 为 union result)</p><h3 id="select-type"><a class="header-anchor" href="#select-type">⚡</a>select_type</h3><table><thead><tr><th style="text-align:center">select_type</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">SIMPLE</td><td style="text-align:center">Simple SELECT (not using UNION or subqueries): 简单查询,没有用到 union 或者子查询</td></tr><tr><td style="text-align:center">PRIMARY</td><td style="text-align:center">Outermost SELECT:最外层查询,即有 union 或者子查询的最外层查询,一个 SQL 整体语句有且仅有一个最外层查询</td></tr><tr><td style="text-align:center">UNION</td><td style="text-align:center">Second or later SELECT statement in a UNION: union 语句中,除了第一个表之外,第二和之后的查询都是 union</td></tr><tr><td style="text-align:center">DEPENDENT</td><td style="text-align:center">Second or later SELECT statement in a UNION, dependent on outer query: 与union一样，出现在union 或union all 语句中，但是这个查询要受到外部查询的影响</td></tr><tr><td style="text-align:center">UNION RESULT</td><td style="text-align:center">Result of a UNION: 包含 union 的结果集,在 union 和 union all 语句中,因为它不需要参与查询,所以id字段为null</td></tr><tr><td style="text-align:center">SUBQUERY</td><td style="text-align:center">First SELECT in subquery: 第一个出现的子查询. 即如果在 select 或者 where 里包含了子查询,那么子查询就是 subquery</td></tr><tr><td style="text-align:center">DEPENDENT SUBQUERY</td><td style="text-align:center">First SELECT in subquery, dependent on outer query: 和 subquery 一样,是第一个出现的子查询,并且它依靠外部查询.这就是**(相关子查询)**</td></tr><tr><td style="text-align:center">DERIVED</td><td style="text-align:center">Derived table SELECT (subquery in FROM clause): 派生表,from 子句中出现的子查询</td></tr><tr><td style="text-align:center">MATERIALIZED</td><td style="text-align:center">Materialized subquery</td></tr><tr><td style="text-align:center">UNCACHEABLE SUBQUERY</td><td style="text-align:center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td style="text-align:center">UNCACHEABLE UNION</td><td style="text-align:center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><blockquote><p>DEPENDENT typically signifies the use of a correlated subquery: dependent 一般代表用到相关子查询</p></blockquote><blockquote><p>DEPENDENT SUBQUERY evaluation differs from UNCACHEABLE SUBQUERY evaluation. For DEPENDENT SUBQUERY, the subquery is re-evaluated only once for each set of different values of the variables from its outer context. For UNCACHEABLE SUBQUERY, the subquery is re-evaluated for each row of the outer context.<br>DEPENDENT SUBQUERY 评估方式与 UNCACHEABLE SUBQUERY 不同.对于 DEPENDENT SUBQUERY,子查询仅针对其外部上下文中变量的每组不同值重新评估一次.对于UNCACHEABLE SUBQUERY,将为外部上下文的每一行重新评估子查询</p></blockquote><blockquote><p>The select_type value for non-SELECT statements displays the statement type for affected tables. For example, select_type is DELETE for DELETE statements<br>非 SELECT 语句的 select_type 值显示受影响表的语句类型.例如,对于 DELETE 语句,select_type 是 DELETE</p></blockquote><h3 id="table"><a class="header-anchor" href="#table">⚡</a>table</h3><blockquote><p>The name of the table to which the row of output refers. This can also be one of the following values:</p><p>&lt;unionM,N&gt; : The row refers to the union of the rows with id values of M and N.</p><p><derivedN> : The row refers to the derived table result for the row with an id value of N. A derived table may result, for example, from a subquery in the FROM clause.</p><p><subqueryN>: The row refers to the result of a materialized subquery for the row with an id value of N. See Section 8.2.2.2, “Optimizing Subqueries with Materialization”.</p><p>即: 通常是所查询的表名,或者表的别名,或者一个为查询产生临时表(如派生表、子查询、union 集合)的标示符</p></blockquote><h3 id="type"><a class="header-anchor" href="#type">⚡</a><strong>type</strong></h3><h4 id="system"><a class="header-anchor" href="#system">⚡</a>system</h4><blockquote><p>The table has only one row (= system table). This is a special case of the const join type.</p><p>只有一行数据,const 的特殊情况</p></blockquote><p>(如果是 Innodb，type 通常都是 all 或者 index)</p><h4 id="const"><a class="header-anchor" href="#const">⚡</a>const</h4><blockquote><p>The table has at most one matching row, which is read at the start of the query. Because there is only one row, values from the column in this row can be regarded as constants by the rest of the optimizer. const tables are very fast because they are read only once.</p><p>表最多具有一个匹配行,该行在查询开始时读取.因为只有一行,所以优化器的其余部分可以将这一行中列的值视为常量.const表非常快,因为它们只需要读取一次</p></blockquote><blockquote><p>const is used when you compare all parts of a PRIMARY KEY or UNIQUE index to constant values</p><p>当您将 PRIMARY KEY 或 UNIQUE 索引的所有部分与常量值进行比较时,将使用 const</p></blockquote><p>例如:</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name <span class="hljs-keyword">WHERE</span> primary_key=<span class="hljs-number">1</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tbl_name  <span class="hljs-keyword">WHERE</span> primary_key_part1=<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> primary_key_part2=<span class="hljs-number">2</span>;</code></pre></div><p>即: 针对唯一或者主键索引等值查询,查询条件是一个常量,从该表中读取最多一行</p><h4 id="eq-ref"><a class="header-anchor" href="#eq-ref">⚡</a>eq_ref</h4><blockquote><p>One row is read from this table for each combination of rows from the previous <a href="http://tables.It" target="_blank" rel="noopener">tables.It</a> is used when all parts of an index are used by the join and the index is a PRIMARY KEY or UNIQUE NOT NULL index.</p><p>对于先前表中的每行组合,从这一张表中读取一行.当 join 使用索引的所有部分并且索引是 PRIMARY KEY 或 UNIQUE NOT NULL 索引时,显示 eq_ref</p></blockquote><blockquote><p>eq_ref can be used for indexed columns that are compared using the = operator. The comparison value can be a constant or an expression that uses columns from tables that are read before this table.</p><p>eq_ref 可用于使用 = 运算符进行比较的索引列.比较值可以是常量,也可以是使用在此表之前读取的表中列的表达式</p></blockquote><p>例如:</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> ref_table,other_table  <span class="hljs-keyword">WHERE</span> ref_table.key_column=other_table.column;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> ref_table,other_table  <span class="hljs-keyword">WHERE</span> ref_table.key_column_part1=other_table.column  <span class="hljs-keyword">AND</span> ref_table.key_column_part2=<span class="hljs-number">1</span>;</code></pre></div><p>即: 唯一性索引扫描,对于每个来自于前面的表的记录,从该表中匹配到唯一一行,并且一般是等值匹配.驱动表只返回一行数据,且这行数据是第二个表的主键或者唯一索引,且必须为 not null.<br>也就是 t1 join t2,其关联条件都是主键或唯一索引,t1的一行,对应 t2 也只有一行(一般用到最左原则)</p><h4 id="ref"><a class="header-anchor" href="#ref">⚡</a>ref</h4><blockquote><p>All rows with matching index values are read from this table for each combination of rows from the previous tables. ref is used if the join uses only a leftmost prefix of the key or if the key is not a PRIMARY KEY or UNIQUE index (in other words, if the join cannot select a single row based on the key value). If the key that is used matches only a few rows, this is a good join type.</p><p>对于先前表中的每个行组合,将从该表中读取具有匹配索引值的所有行.如果 join 仅使用键的最左前缀,或者如果该键不是 PRIMARY KEY 或 UNIQUE 索引(换句话说,如果联接无法根据键值选择单个行),则使用ref.如果使用的键仅匹配几行,则这是一种很好的联接类型</p></blockquote><p>即: 非唯一性索引扫描,类似 eq_ref,只是关联条件只是普通索引,不是唯一或主键索引,t1 对应的 t2 会有多个匹配行</p><h4 id="ref-or-null"><a class="header-anchor" href="#ref-or-null">⚡</a>ref_or_null</h4><blockquote><p>This join type is like ref, but with the addition that MySQL does an extra search for rows that contain NULL values. This join type optimization is used most often in resolving subqueries</p><p>这种 join 类型类似于 ref,<strong>但是 MySQL 需要额外搜索包含 NULL 值的行</strong>.此联接类型优化最常用于解决子查询</p></blockquote><p>例如:</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> ref_table  <span class="hljs-keyword">WHERE</span> key_column=expr <span class="hljs-keyword">OR</span> key_column <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;</code></pre></div><h4 id="index-merge"><a class="header-anchor" href="#index-merge">⚡</a>index_merge</h4><blockquote><p>This join type indicates that the Index Merge optimization is used. In this case, the key column in the output row contains a list of indexes used, and key_len contains a list of the longest key parts for the indexes used</p><p>此 join 类型表示使用了索引合并优化.在这种情况下,输出行中的键列包含使用的索引列表,而 key_len 包含使用的索引的最长键部分的列表</p></blockquote><p>即: 使用同一张表的多个索引,将多个索引合并取交集或者并集,常见 and,or 的条件使用了不同的索引</p><h4 id="unique-subquery"><a class="header-anchor" href="#unique-subquery">⚡</a>unique_subquery</h4><blockquote><p>This type replaces eq_ref for some IN subqueries of the following form</p></blockquote><div class="hljs"><pre><code class="hljs sql">value IN (<span class="hljs-keyword">SELECT</span> primary_key <span class="hljs-keyword">FROM</span> single_table <span class="hljs-keyword">WHERE</span> some_expr)</code></pre></div><blockquote><p>unique_subquery is just an index lookup function that replaces the subquery completely for better efficiency.</p><p>unique_subquery 只是一个索引查找函数,<strong>可以完全替换子查询以提高效率</strong></p></blockquote><h4 id="range"><a class="header-anchor" href="#range">⚡</a>range</h4><blockquote><p>Only rows that are in a given range are retrieved, using an index to select the rows. The key column in the output row indicates which index is used. The key_len contains the longest key part that was used. The ref column is NULL for this type.</p><p>使用索引选择行,仅检索给定范围内的行.输出行中的 key 指示使用哪个索引.key_len包含使用的最长的键部分。此类型的ref列为NULL。</p></blockquote><blockquote><p>range can be used when a key column is compared to a constant using any of the =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, LIKE, or IN() operators:</p></blockquote><p>即: 只检索给定范围的行，使用一个索引来选择行,而且可以是范围常量比较</p><h4 id="index"><a class="header-anchor" href="#index">⚡</a>index</h4><blockquote><p>The index join type is the same as ALL, except that the index tree is scanned. This occurs two ways:</p><p>index 的类型除了扫描的是索引树之外和 ALL 差不多，而扫描索引树只在下面两种情况下发生</p></blockquote><ul><li><blockquote><p>If the index is a covering index for the queries and can be used to satisfy all data required from the table, only the index tree is scanned. In this case, the Extra column says Using index. An index-only scan usually is faster than ALL because the size of the index usually is smaller than the table data.</p><p>如果索引是查询的覆盖索引，并且可用于满足表中所需的所有数据，则仅扫描索引树。在这种情况下，<code>Extra</code> 列显示 <code>using index</code>。仅索引扫描通常比ALL快，因为索引的大小通常小于表数据。</p></blockquote></li><li><blockquote><p>A full table scan is performed using reads from the index to look up data rows in index order. Uses index does not appear in the Extra column.</p><p>使用对索引的读取来执行全表扫描，是按照索引顺序查找数据行。<code>using index</code>不会出现在 <code>Extra</code> 列中。</p></blockquote></li></ul><p>即：如果是覆盖索引，那么在 <code>extra</code> 列中会显示 <code>using index</code>，而如果没有用到覆盖索引，那么就不会在 <code>extra</code>列中显示，查询方式为全索引扫描。</p><h4 id="fulltext"><a class="header-anchor" href="#fulltext">⚡</a>fulltext</h4><blockquote><p>The join is performed using a FULLTEXT index.</p><p>用到全文索引时显示</p></blockquote><p>要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p><h4 id="ALL"><a class="header-anchor" href="#ALL">⚡</a>ALL</h4><blockquote><p>A full table scan is done for each combination of rows from the previous tables. This is normally not good if the table is the first table not marked const, and usually very bad in all other cases. Normally, you can avoid ALL by adding indexes that enable row retrieval from the table based on constant values or column values from earlier tables.</p><p>对来自先前表的行的每个组合进行全表扫描。如果该表是未标记为const的第一个表，则通常不好，并且在所有其他情况下通常非常糟糕。通常，可以通过添加索引来避免ALL，这些索引允许基于早期表中的常量值或列值从表中检索行。</p></blockquote><h3 id="possible-keys"><a class="header-anchor" href="#possible-keys">⚡</a>possible_keys</h3><p>可能用到的索引</p><blockquote><p>If this column is NULL, there are no relevant indexes. In this case, you may be able to improve the performance of your query by examining the WHERE clause to check whether it refers to some column or columns that would be suitable for indexing. If so, create an appropriate index and check the query with EXPLAIN again</p><p>翻译: 如果此列为 NULL,则没有相关的索引.在这种情况下,你可以通过检查 WHERE 子句来检查它是否引用了某些适合索引的列,从而可以提高查询性能.如果是这样,请创建一个适当的索引,然后再次使用 EXPLAIN 检查查询</p></blockquote><h3 id="keys"><a class="header-anchor" href="#keys">⚡</a>keys</h3><p>实际用到的索引</p><blockquote><p>It is possible that key will name an index that is not present in the possible_keys value. This can happen if none of the possible_keys indexes are suitable for looking up rows, but all the columns selected by the query are columns of some other index. That is, the named index covers the selected columns, so although it is not used to determine which rows to retrieve, an index scan is more efficient than a data row scan.</p><p>可能会显示一个 possible_keys 中不存在的索引.如果没有一个 possible_keys 索引适合查找行,但是查询选择的所有列都是其他索引的列,则可能发生这种情况.也就是说,这个索引覆盖了选定的列,因此尽管不使用索引来确定要检索的行,但索引扫描比数据行扫描更有效(<strong>索引覆盖的情况?</strong>)</p></blockquote><blockquote><p>For InnoDB, a secondary index might cover the selected columns even if the query also selects the primary key because InnoDB stores the primary key value with each secondary index. If key is NULL, MySQL found no index to use for executing the query more efficiently.</p><p>对于 InnoDB,即使查询也选择了主键,辅助索引也可能覆盖选定的列,因为 InnoDB 将主键值与每个辅助索引一起存储</p></blockquote><p>(可以用 force index,use index 或者 ignore index,选择:使用/建议/不使用索引)</p><h3 id="key-len"><a class="header-anchor" href="#key-len">⚡</a>key_len</h3><blockquote><p>The key_len column indicates the length of the key that MySQL decided to use. The value of key_len enables you to determine how many parts of a multiple-part key MySQL actually uses. If the key column says NULL, the key_len column also says NULL.</p><p>key_len 指示 MySQL 决定使用的索引的长度.key_len 的值使您能够确定 MySQL 实际使用的联合索引的多少部分</p></blockquote><h3 id="ref-v2"><a class="header-anchor" href="#ref-v2">⚡</a>ref</h3><blockquote><p>The ref column shows which columns or constants are compared to the index named in the key column to select rows from the table.</p><p>ref 显示将哪些列或常量与 explain 中 key 列中列出的索引进行比较来从表中选择行</p></blockquote><p>即显示关联的字段.如果使用常数等值查询,则显示 const,如果是多个表连接查询,则会显示关联表的字段</p><blockquote><p>If the value is func, the value used is the result of some function. To see which function, use SHOW WARNINGS following EXPLAIN to see the extended EXPLAIN output. The function might actually be an operator such as an arithmetic operator.</p><p>如果该值为 func,则使用的值是某些函数的结果.要查看哪个函数,在 EXPLAIN 之后使用 SHOW WARNINGS 来查看扩展的 EXPLAIN 输出.该函数实际上可能是算术运算符之类的运算符</p></blockquote><p>即如果是 func,说明条件判断时进行了数据类型转换或者使用了表达式或函数</p><h3 id="rows"><a class="header-anchor" href="#rows">⚡</a>rows</h3><blockquote><p>The ref column shows which columns or constants are compared to the index named in the key column to select rows from the table.<br>For InnoDB tables, this number is an estimate, and may not always be exact.</p><p>rows列指示MySQL认为执行查询必须检查的行数。<br>对于 InnoDB,此数字是估计值</p></blockquote><h3 id="filtered"><a class="header-anchor" href="#filtered">⚡</a>filtered</h3><p>表示此查询条件所过滤的数据的百分比，将 rows 除以 filtered 可以估算出整个表数据行数。</p><blockquote><p>The filtered column indicates an estimated percentage of table rows that will be filtered by the table condition. The maximum value is 100, which means no filtering of rows occurred. Values decreasing from 100 indicate increasing amounts of filtering. rows shows the estimated number of rows examined and rows × filtered shows the number of rows that will be joined with the following table. For example, if rows is 1000 and filtered is 50.00 (50%), the number of rows to be joined with the following table is 1000 × 50% = 500.</p><p>表示被条件过滤的行数的估计百分比.最大值为100,这表示未过滤行.值从100减小表示过滤量增加.rows 显示检查的估计行数，filtered 显示将与下表连接的行数.例如,如果 rows 是1000,filtered 是 50.00(50％),则与下表连接的行数是 1000×50％= 500。</p></blockquote><h3 id="extra"><a class="header-anchor" href="#extra">⚡</a>extra</h3><blockquote><p>This column contains additional information about how MySQL resolves the query</p></blockquote><h2 id="附录"><a class="header-anchor" href="#附录">⚡</a>附录</h2><h3 id="extra-列的几种情况"><a class="header-anchor" href="#extra-列的几种情况">⚡</a>extra 列的几种情况</h3><ol><li><p>using index:</p><blockquote><p>The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index.</p><p>仅使用索引树中的信息从表中检索列信息，而不必进行其他查找以读取实际行。当查询仅使用属于单个索引的列时，可以使用此策略。</p></blockquote><blockquote><p>For InnoDB tables that have a user-defined clustered index, that index can be used even when Using index is absent from the Extra column. This is the case if type is index and key is PRIMARY.</p><p>对于具有用户定义的聚集索引的InnoDB表，即使 <code>Extra</code> 列中没有 <code>using index</code>，也可以使用索引。如果 <code>type</code> 列是 <code>index</code> 并且 <code>key</code> 列是<code>PRIMARY</code>，就是这种情况。</p></blockquote><p>即：在索引列上进行查找，使用到了索引覆盖；或者是 type 为 index 且 key 为 primary 的 InnoDB 表的情况。</p><p>如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表面索引用来读取数据而非执行查找动作。</p></li><li><p>using index condition</p><blockquote><p>Tables are read by accessing index tuples and testing them first to determine whether to read full table rows. In this way, index information is used to defer (“push down”) reading full table rows unless it is necessary.</p><p>通过访问索引元组并首先对其进行测试以确定是否读取完整的表行来读取表。这样，除非有必要，否则索引信息将用于延迟（“下推”）读取整个表行。</p></blockquote><p>即：索引下推，当取出记录的时候就进行过滤，过滤掉不必要的记录。</p></li><li><p>using filesort</p><blockquote><p>MySQL must do an extra pass to find out how to retrieve the rows in sorted order. The sort is done by going through all rows according to the join type and storing the sort key and pointer to the row for all rows that match the WHERE clause. The keys then are sorted and the rows are retrieved in sorted order.</p><p>MySQL必须额外进行一遍，以按排序顺序检索行。通过根据联接类型遍历所有行并存储与WHERE子句匹配的所有行的排序键和指向该行的指针，可以完成排序。然后对键进行排序，并按排序顺序检索行。</p></blockquote><p>使用文件排序，常出现在 order by 或者 group by 语句中，且排序成分没有用到索引，此时需要在 <strong>内存中</strong> 进行排序，由于使用索引排序会好于文件排序，一般这种情况为了减小 CPU 资源消耗都可以考虑添加索引进行优化。</p><blockquote><p>出现条件：在 order by 或者在 group by 排序的过程中，order by 的字段不是索引字段，或者 select 查询字段存在不是索引字段，或者 select 查询字段都是索引字段，但是 order by 字段和 select 索引字段的顺序不一致，都会导致 fileSort</p></blockquote></li><li><p>using join buffer (Block Nested Loop 或者 Batched Key Access 或者 hash join)</p><blockquote><p>Tables from earlier joins are read in portions into the join buffer, and then their rows are used from the buffer to perform the join with the current table. (Block Nested Loop) indicates use of the Block Nested-Loop algorithm, (Batched Key Access) indicates use of the Batched Key Access algorithm, and (hash join) indicates use of a hash join. That is, the keys from the table on the preceding line of the EXPLAIN output are buffered, and the matching rows are fetched in batches from the table represented by the line in which Using join buffer appears.</p><p>来自较早联接的表被部分读取到 join 缓冲区中，然后从缓冲区中使用它们的行来执行与当前表的联接。使用 Blocked Nested Loop 或者 Batched Key Access 或 hash join 算法进行具体连接。即，将缓冲EXPLAIN输出的前一行中的表中的键，并从出现“使用连接缓冲区”的行所代表的表中批量提取匹配的行。</p></blockquote><blockquote><p>Hash joins are available beginning with MySQL 8.0.18; the Block Nested-Loop algorithm is not used in MySQL 8.0.20 or later MySQL releases.</p><p>从MySQL 8.0.18开始，可以使用哈希联接。MySQL 8.0.20或更高版本的MySQL中未使用“块嵌套循环”算法。</p></blockquote></li><li><p>using temporary</p><blockquote><p>To resolve the query, MySQL needs to create a temporary table to hold the result. This typically happens if the query contains GROUP BY and ORDER BY clauses that list columns differently.</p><p>为了解决该查询，MySQL需要创建一个临时表来保存结果。如果查询包含GROUP BY和ORDER BY子句以不同方式列出列，则通常会发生这种情况。</p></blockquote></li><li><p>using where</p><p>MySQL 服务器会在存储引擎检索行后再根据 where 条件进行过滤。</p><blockquote><p>A WHERE clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the Extra value is not Using where and the table join type is ALL or index.</p><p>WHERE子句用于限制要与下一个表匹配或发送给客户端的行。除非你专门打算从表中获取或检查所有行，否则，如果 <code>Extra</code> 值不是 <code>using where</code> 并且表 <code>type</code> 是 <code>ALL</code> 或 <code>index</code>，则查询中可能存在一些问题。</p></blockquote><p>即：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。</p><p>查询条件中分为限制条件和检查条件。5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。<code>extra</code> 列显示 <code>using index condition</code></p></li><li><p>using MRR</p><blockquote><p>Tables are read using the Multi-Range Read optimization strategy.</p><p>使用 Multi-Range Read 优化策略读取表。</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-TCP/IP</title>
    <link href="/2020/7/17/%E8%AE%A1%E7%BD%91-TCP-IP/"/>
    <url>/2020/7/17/%E8%AE%A1%E7%BD%91-TCP-IP/</url>
    
    <content type="html"><![CDATA[<ul><li><p>[x] TCP/IP 是网络层和传输层协议,是协议簇</p></li><li><p>[x] 如何理解 TCP (两点)</p><p>TCP 是面向<strong>连接</strong>的<strong>可靠</strong>传输,这里有两点,一是连接,二是可靠</p><p>连接指的是两方要去通信肯定需要连接,连接可以是虚拟的,也可以是物理真实存在的</p><p>TCP 的连接是一对 Socket 套接字</p><p>可靠指的是两方是由 socket 中的一对 ip:prot 和 ip:port,当客户端发送数据时,由于 ip:port 和 ip:port 是网络上唯一的,保证了可靠性</p></li><li><p>[x] TCP连接三次握手的过程</p><ol><li><p>server 首先要处在 listen 状态监听端口</p></li><li><p>client 发送 SYN ,client 进入<strong>同步已发送</strong> syn-sent 状态</p><p>SYN =1,seq = x,x 是自己初始化的序列号</p></li><li><p>server 收到后(如果同意连接),会发出确认报文 SYN + ACK,server 进入<strong>同步收到</strong> syn-revd 状态</p><p>ACK = 1,SYN = 1,ack = x+1,seq = y</p><p>确认号 ack 是 x+1</p><p>y 是自己初始化的序列号</p></li><li><p>client 收到 server 发送的 ACK 之后,还要再给服务端发送确认报文 ACK,此时,TCP建立, client 进入已建立链接 established 状态,<strong>开辟资源</strong></p></li></ol><p>ack=1,ack=y+1,序列号 seq=x+1</p><ol><li>server 收到之后,进入 establish 状态,会<strong>开辟资源</strong>,此时双方可以开始通信了</li></ol></li><li><p>[x] TCP 连接为什么需要发送最后第三次确认呢?</p><p>如果使用的是两次握手建立连接,假设有这样一种场景:</p><p>客户端发送了第一个请求连接并且没有丢失,只是因为在网络结点中滞留的时间太长了,由于TCP的 client 以为服务器没有收到,此时<strong>重新</strong>向服务器发送这条报文</p><p>此后客户端和服务器经过两次握手完成连接,传输数据,然后关闭连接</p><p>此时此前滞留的那一次请求连接,网络通畅了到达了服务器,这个请求该是失效的,但是,两次握手的机制将会让客户端和服务器再次建立连接,但是再次建立连接之后没有传输任何数据,这会导致不必要的错误和资源的浪费</p><p>同样的场景,如果采用的是三次握手,就算是那一次失效的报文传送过来了,服务端接受到了那条失效报文并且回复了确认报文,但是客户端不会再次发出确认,由于服务器收不到确认,就不会开辟资源,避免了资源的浪费</p></li><li><p>[x] 四次挥手</p><ol><li><p>首先,server 和 client 都是 established 状态</p></li><li><p>client 发送连接释放报文 FIN,client 进入<strong>终止等待状态1</strong> fin-wait-1</p><p>fin =1,seq=u(前面已经传输的最后一个字节的序列号+1),</p></li><li><p>server 收到连接释放 FIN 之后,发出确认报文 ACK,此时服务端进入<strong>关闭等待</strong>状态 close-wait</p><p>ACK = 1,ack = u+1,seq = v</p><p>此时 client 处于半关闭状态,即 client 不会发送数据了,但是 server 端还可以发送数据让 client 接收</p></li><li><p>client 收到 server 发送的 ACK 之后,进入<strong>终止等待状态2</strong> FIN-WAIT-2</p></li><li><p>server 发送完数据后,再向 client 发送连接释放报文 FIN,此时 server 进入<strong>最后确认</strong>状态 LAST-ACK</p><p>FIN = 1,ack = u+1,seq = w</p></li><li><p>client 收到 FIN 之后,发送 ACK 确认,此时 client 进入<strong>时间等待</strong>状态 TIME-WAIT</p><p>ACK =1,ack = w+1,seq = u+1</p><p>此时 TCP 还没有释放,必须经过一个最长报文寿命 2*MSL 时间后,才进入 CLOSE 状态</p></li><li><p>server 收到 ACK 之后,立即进入 CLOSE 关闭状态</p><p>server 结束要比 client 早</p></li></ol></li><li><p>[x] 为什么客户端最后还要等待2MSL? (两点)</p><p>MSL(Maximum Segment Lifetime),TCP允许不同的实现可以设置不同的MSL值</p><p>第一,保证客户端发送的最后一个 ACK 报文能够到达 server</p><p>因为这个 ACK 报文可能丢失</p><p>站在服务器的角度来看,我已经发送了 FIN+ACK 报文请求断开了,客户端还没有给我回应,应该是我发送的请求断开报文它没有收到,于是服务器又会<strong>重新发送一次 FIN+ACK</strong></p><p>而客户端就能在这个 2MSL 时间段内收到这个重传的报文,接着给出回应报文,并且会重启2MSL计时器</p><p>所以,TIME_WAIT 状态就是用来接收 server 重发可能丢失的 FIN+ACK 报文,并重新发送 ACK</p><p>第二,防止类似与&quot;三次握手&quot;中提到了的&quot;已经失效的连接请求报文段&quot;出现在本连接中</p><p>客户端发送完最后一个确认报文后,在这个 2MSL 时间中,就可以使本连接持续的时间内所产生的所有报文段都从网络中消失,这样新的连接中不会出现旧连接的请求报文</p></li><li><p>[x] 为什么建立连接是三次握手，关闭连接确是四次挥手呢?</p><p>建立连接的时候,服务器在 LISTEN 状态下,收到建立连接请求的SYN报文后,把 ACK 和 SYN 放在一个报文里发送给客户端</p><p>而关闭连接时,服务器收到对方的 FIN 报文时,仅仅表示对方不再发送数据了但是还能接收数据,而自己也未必全部数据都发送给对方了,所以己方可以立即关闭,也可以发送一些数据给对方后,再发送 FIN 报文给对方来表示同意再关闭连接,因此,己方 ACK 和 FIN 一般都会分开发送,从而导致多了一次</p></li><li><p>[x] 如果已经建立了连接，但是客户端突然出现故障了怎么办?</p><p>TCP还设有一个保活计时器,显然,客户端如果出现故障,服务器不能一直等下去,白白浪费资源</p><p>服务器每收到一次客户端的请求后都会重新复位这个计时器,时间通常是设置为2小时,若两小时还没有收到客户端的任何数据,服务器就会发送一个探测报文段,以后每隔75秒发送一次</p><p>若一连发送10个探测报文仍然没反应,服务器就认为客户端出了故障,接着就关闭连接</p></li></ul><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">更深入</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>net</tag>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-HTTP</title>
    <link href="/2020/7/17/%E8%AE%A1%E7%BD%91-HTTP/"/>
    <url>/2020/7/17/%E8%AE%A1%E7%BD%91-HTTP/</url>
    
    <content type="html"><![CDATA[<ul><li><p>[x] HTTP 请求报文包括</p><ol><li><p>请求行</p></li><li><p>请求头</p></li><li><p>请求正文</p></li><li><p>空行</p></li></ol></li><li><p>[x] HTTP 响应报文包括</p><ol><li><p>状态行</p></li><li><p>响应头</p></li><li><p>响应正文</p></li><li><p>空行</p></li></ol></li><li><p>[x] 完整的HTTP请求所经历的7个步骤</p><ol><li><p>建立TCP连接</p><p>在 HTTP 工作开始之前,Web 浏览器首先要通过网络与 Web 服务器建立连接,该连接是通过 TCP 来完成的</p><p>HTTP 是比 TCP 更高层次的应用层协议,根据规则,只有低层协议建立之后才能进行更高层协议的连接</p></li><li><p>浏览器向Web服务器发送请求行</p></li><li><p>浏览器发送请求头</p><p>浏览器发送其请求命令之后,还要以头信息的形式向 Web 服务器发送一些别的信息,之后浏览器发送了一个空白行来通知服务器,它已经结束了该头信息的发送</p></li><li><p>服务器响应行</p><p>客户机向服务器发出请求后,服务器会客户机回送响应, <code>HTTP/1.1 200 OK</code>,应答的第一部分是协议的版本号和响应状态码</p></li><li><p>服务器发送响应头</p><p>正如客户端会随同请求发送关于自身的信息一样,服务器也会随同应答向用户发送关于它自己的数据及被请求的文档</p></li><li><p>Web服务器向浏览器发送数据</p><p>服务器向浏览器发送头信息后,它会发送一个空白行来表示头信息的发送到此为结束</p><p>接着,它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据</p></li><li><p>Web服务器关闭TCP连接</p><p>一般情况下,一旦服务器向浏览器发送了请求数据,它就要关闭 TCP 连接,然后如果浏览器或者服务器在其头信息加入了 <code>Connection:keep-alive</code></p><p>TCP 连接在发送后将仍然保持打开状态,于是,浏览器可以继续通过相同的连接发送请求</p><p>保持连接节省了为每个请求建立新连接所需的时间,还节约了网络带宽</p></li></ol><p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p></li><li><p>[x] POST 和 GET 区别 (四点)</p><ol><li><p>都包含请求头请求行,POST 多了请求 body</p></li><li><p>GET 参数是直接添加到 URL 后面的,直接就可以在 URL 中看到内容,而 POST 是放在报文内部的,用户无法直接看到</p></li><li><p>GET 提交的数据长度是有限制的,因为 URL 长度有限制,具体的长度限制视浏览器而定,而POST没有长度限制</p></li><li><p>约定俗成,GET 多用来查询,请求参数放在 URL 中,不会对服务器上的内容产生作用,POST 用来提交</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网-HTTPS</title>
    <link href="/2020/7/17/%E8%AE%A1%E7%BD%91-HTTPS/"/>
    <url>/2020/7/17/%E8%AE%A1%E7%BD%91-HTTPS/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是HTTPS"><a class="header-anchor" href="#什么是HTTPS">⚡</a>什么是HTTPS?</h2><p>HTTPS 协议(HyperText Transfer Protocol over Secure Socket Layer): 一般理解为 HTTP+SSL/TLS = HTTPS,通过 SSL 证书来验证服务器的身份,并为浏览器和服务器之间的通信进行加密</p><p>SSL:Secure Socket Layer,安全套接字层</p><p>TLS(Transport Layer Security,传输层安全): 其前身是 SSL，它最初的几个版本(SSL 1.0、SSL 2.0、SSL 3.0) 由网景公司开发,1999年从 3.1 开始被 IETF 标准化并改名,发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本.SSL3.0和TLS1.0由于存在安全漏洞,已经很少被使用到.TLS 1.3 改动会比较大,目前还在草案阶段,目前使用最广泛的是 TLS 1.1、TLS 1.2</p><h2 id="浏览器在使用-HTTPS-传输数据的流程是什么-六点"><a class="header-anchor" href="#浏览器在使用-HTTPS-传输数据的流程是什么-六点">⚡</a>浏览器在使用 HTTPS 传输数据的流程是什么? (六点)</h2><ol><li><p>首先客户端通过 URL 访问服务器建立 SSL 连接,客户端会将生成一个随机数(client random),以及客户端支持的加密方法发送给服务端</p></li><li><p>服务端收到客户端请求后,会将网站支持的证书信息(证书中包含服务端的公钥)还有一个随机数(server random)传送一份给客户端</p></li><li><p>客户端的服务器开始协商 SSL 连接的安全等级,也就是信息加密的等级</p></li><li><p>客户端的浏览器根据双方同意的安全等级,生新成一个随机数(Premaster secret),然后利用服务端的公钥将生成的新随机数加密,并传送给服务端</p></li><li><p>服务器利用自己的私钥解密得到新随机数(Premaster secret),用(client random,server random,Premaster secret)生成对话密钥(session key)</p></li><li><p>服务器利用会话密钥加密与客户端之间的通信</p></li></ol><p><img src="https://pic4.zhimg.com/v2-a994fbf3094d737814fe01c2b919477b_r.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="为什么要用https-三点"><a class="header-anchor" href="#为什么要用https-三点">⚡</a>为什么要用https? (三点)</h2><ol><li><p>参数明文传输,不安全</p></li><li><p>数据的完整性未校验，容易被篡改</p></li><li><p>没有验证对方身份，存在冒充危险</p></li></ol><h2 id="HTTPS-的缺点-三点"><a class="header-anchor" href="#HTTPS-的缺点-三点">⚡</a>HTTPS 的缺点?(三点)</h2><ol><li><p>HTTPS 协议多次握手,导致页面的加载时间延长近50%</p></li><li><p>HTTPS 连接缓存不如 HTTP 高效,会增加数据开销和功耗</p></li><li><p>SSL 涉及到的安全算法会消耗 CPU 资源,对服务器资源消耗较大</p></li></ol><h2 id="HTTPS-和-HTTP-的区别-三点"><a class="header-anchor" href="#HTTPS-和-HTTP-的区别-三点">⚡</a>HTTPS 和 HTTP 的区别?(三点)</h2><ol><li><p>HTTPS 是 HTTP 协议的安全版本,HTTP 协议的数据传输是明文的,是不安全的,HTTPS 使用了 SSL/TLS 协议进行了加密处理</p></li><li><p>HTTP 和 HTTPS 使用连接方式不同,默认端口也不一样,HTTP 是80，HTTPS 是443</p></li><li><p>HTTP 属于应用层, HTTPS 由于加了 SSL,是应用层和传输层的结合</p></li></ol><h2 id="对称加密和非对称加密"><a class="header-anchor" href="#对称加密和非对称加密">⚡</a>对称加密和非对称加密?</h2><p>加密和解密同用一个密钥的方式称为<em>共享密钥加密</em>,也被叫做<em>对称密钥加密</em></p><p>共享加密方式加密时必须将密钥也发给对方</p><p>在互联网上转发密钥时,如果通信被监听那么密钥就会落入攻击者之手,同时也就失去了加密的意义</p><p>公开密钥加密方式很好地解决了共享密钥加密的困难:</p><p>公开密钥加密使用一对非对称的密钥:一把叫做私有密钥,另一把叫做公开密钥</p><p>使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的信息后,再使用自己的私有密钥进行解密</p><p>利用这种方式,不需要发送用来解密的私有密钥,也不用担心密钥被攻击者窃听而盗走</p><p>HTTPS采用共享秘钥加密和公开秘钥加密两者并用的<strong>混合加密</strong>机制</p><p>若密钥能够实现安全交换,那么有可能会考虑仅适用公开密钥加密来通信</p><p>但是公开密钥加密和共享密钥加密相比,处理速度要慢</p><p>公开密钥加密方式还是存在一些问题的,那就是无法证明公开密钥本身就是货真价实的公开密钥</p><p>例如当服务器发送公钥时被截取,然后替换了公钥,那么就会出现问题,所以解决办法是:数字证书认证机构 CA 颁发的公开密钥证书 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h2 id="为什么-HTTPS-要同时使用对称加密和非对称加密两种加密方式的混合模式？"><a class="header-anchor" href="#为什么-HTTPS-要同时使用对称加密和非对称加密两种加密方式的混合模式？">⚡</a>为什么 HTTPS 要同时使用对称加密和非对称加密两种加密方式的混合模式？</h2><p>因为对称加密速度比较快，但是对称加密无法保证加密密钥的安全传输，所以使用非对称密钥来将生成的对称密钥安全传输到双方，此后使用更快的对称加密密钥。</p><h2 id="为什么对称加密速度比较快？"><a class="header-anchor" href="#为什么对称加密速度比较快？">⚡</a>为什么对称加密速度比较快？</h2><p>对称加密主要的运算是位运算，速度是非常快的，例如 DES 算法(置换，位移，异或，迭代)。如果使用硬件速度会更快。</p><p>非对称加密计算一般都比较复杂，例如 RSA，它里面涉及到大数乘法、大数取模运算等等。</p><p>而幂运算的本质是乘法，乘法的基础单位是加法，也就是我们最常见的整数加。而在电路上实现加法比异或（XOR）要麻烦的多，况且后面还有一个模运算。因此非对称加密的速度自然而然是比不过对称加密的。</p><p>另外还有一个原因是，某些对称加密算法，例如 DES 算法中有些模式，如 ECB 模式等等，中间计算过程是可以并行计算的，更进一步提高加密解密的速度。</p><h2 id="如何保证-server-的公钥传到客户端时不被篡改呢"><a class="header-anchor" href="#如何保证-server-的公钥传到客户端时不被篡改呢">⚡</a>如何保证 server 的公钥传到客户端时不被篡改呢?</h2><blockquote><p>答: 1. 可信的第三方 CA 机构 2. 非对称加密</p></blockquote><p>HTTPS 中 RSA 非对称加密的两种模式:</p><ol><li><p>加密模式,保证数据传输方的数据安全性(不可被其他人读)</p><p>加密模式:私钥解密,公钥加密</p></li><li><p>认证模式,保证数据接受方的数据完整性(不可被其他人篡改)</p><p>认证模式: 私钥签名(加密),公钥认证(解密)</p></li></ol><p>CA 机构使用 CA 自己的私钥对 server 的公钥和 server 的一些信息统一<strong>加密/签名是</strong>,生成数字证书.</p><p>当 client 请求 server 时,server 将信息正文,有信息正文生成的数字签名<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>和数字证书<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>一起发送给 client.</p><p>这样,client 在接收时会根据浏览器内置的受信任的 CA 机构列表判断发来的签发证书的机构是否有效,如果有效,那么使用对应 CA 机构内置的 CA 的公钥<strong>解密/认证</strong> CA 发送的证书,从中得到 server 的公钥,并且,使用 server 的公钥解密/认证数字签名,如果得到的结果和信息正文散列后的摘要一致,那么说明 server 的公钥是安全的,且信息正文没有被篡改.</p><p>因为,1. 如果 server 向 client 发送的信息中,server 的公钥被恶意第三方篡改,但是第三方无法拿到 CA 的私钥对数字证书重新加密认证;2. 而如果使用第三方自己的私钥加密认证,client 会提示这是不受信任的机构;3. 如果是只修改了信息正文,那么数字签名会不对应;4. 如果修改了信息正文并想重新生成对应的数字签名也是不可能的,因为加密摘要要使用 server 的私钥,第三方拿不到</p><ul><li><p>如果只是 server 自己签发数字签名和公钥以及信息正文,没有第三方 CA 机构:</p><p>server 的公钥散列生成摘要,并使用自己的公钥对公钥和 server 的一些信息统一<strong>加密/认证</strong>,生成数字证书发送给 client</p><p>但是中途还是有可能被第三方拦截,如果替换了 server 公钥还是无法察觉</p></li><li><p>如果只是颁发数字证书,没有数字签名,信息正文可能会被篡改</p></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>数字证书: 信任的 CA 机构颁发,证书 = CA 使用自己的 CA 私钥<strong>加密/认证</strong> server 的公钥以及一些 server 的其他信息后的结果 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>数字签名: 将信息散列<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>生成摘要<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>,并使用自己的私钥对摘要加密,即生成数字签名 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>散列: 散列不同于加密,散列即不可逆 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>例如使用 MD5 算法将一个原值生成散列值,而这个散列值不可反推回原来的值 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识 -- BKA 优化</title>
    <link href="/2020/5/25/MySQL-%E7%9F%A5%E8%AF%86-BKA-%E4%BC%98%E5%8C%96/"/>
    <url>/2020/5/25/MySQL-%E7%9F%A5%E8%AF%86-BKA-%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Batched Kay Access</p><a id="more"></a><ul><li><p>目的:</p><p>BKA 是指在表连接的过程中为了提升 join 性能而使用的一种 <code>join buffer</code>,其作用是在读取被 join 表的记录的时候使用顺序 IO</p></li><li><p>适用条件: BKA 被使用的标识是 explain 中 extra 信息为 Batched Key Access</p></li><li><p>好处:</p><ol><li></li></ol></li><li><p>工作原理:</p><p>BKA将有序主建投递到存储引擎是通过 MRR 的接口的调用来实现的</p><p>所以BKA 依赖 MRR，如果要使用BKA, MRR 是需要先打开的</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 知识-- Unsafe</title>
    <link href="/2020/4/30/Java-%E7%9F%A5%E8%AF%86-Unsafe/"/>
    <url>/2020/4/30/Java-%E7%9F%A5%E8%AF%86-Unsafe/</url>
    
    <content type="html"><![CDATA[<h2 id="关于-unsafe"><a class="header-anchor" href="#关于-unsafe">⚡</a>关于 unsafe</h2><a id="more"></a><ol><li><p>不能使用提供的 getInstance() 方法获取单例对象</p><p>unsafe 是单例的</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</code></pre></div> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;    Class var0 = Reflection.getCallerClass();    <span class="hljs-comment">// 此处做了限制,非根类加载器 bootstrap class loader 调用会报错</span>    <span class="hljs-keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<span class="hljs-string">"Unsafe"</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> theUnsafe;    &#125;&#125;</code></pre></div></li><li><p>要想获得 unsafe 实例</p><ol><li><p>反射</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">reflectGetUnsafe</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        Field field = Unsafe.class.getDeclaredField("theUnsafe");        field.setAccessible(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-keyword">null</span>);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    log.error(e.getMessage(), e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div></li><li><p>修改 JVM 参数,把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过 Unsafe.getUnsafe 方法安全的获取 Unsafe 实例。</p> <div class="hljs"><pre><code class="hljs shell">java -Xbootclasspath/a: $&#123;path&#125;<span class="hljs-meta">#</span><span class="bash"> 其中path为调用Unsafe相关方法的类所在jar包路径</span></code></pre></div></li></ol></li></ol><h2 id="CAS-相关"><a class="header-anchor" href="#CAS-相关">⚡</a>CAS 相关</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// var2 字段值增加 var4</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;    <span class="hljs-keyword">int</span> var5;    <span class="hljs-comment">// 自旋 + CAS</span>    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-comment">// 获取当前对象 var1 中 var2 字段的地址值</span>        <span class="hljs-comment">// 即从内存中获取字段的真实值</span>        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);        <span class="hljs-comment">// 如果 CAS 失败,那么重试</span>        <span class="hljs-comment">// 如果成功,跳出循环</span>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));    <span class="hljs-keyword">return</span> var5;&#125;</code></pre></div><p>var2 这个偏移量是通过:</p><div class="hljs"><pre><code class="hljs java">valueOffset = unsafe.objectFieldOffset(TargetObject.class.getDeclaredField("fileName"));</code></pre></div><p>对于任意一个类要修改的字段,可以通过这种方式传入类名和字段名来获取对象字段的内存地址</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识-- CAS</title>
    <link href="/2020/4/30/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CAS/"/>
    <url>/2020/4/30/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-CAS/</url>
    
    <content type="html"><![CDATA[<p>CAS (Compare And Swap) (CompareAndSet): 比较并交换,比较并设定</p><a id="more"></a><p>CAS 是一种并发时用到的技术,其本质是一种算法</p><p>为了解决并发时修改共享变量的问题,传统的解决方式就是加锁,例如典型的 <code>synchronized</code> 关键字,但是加锁一般都是悲观锁,即首先认为每次都会进行多线程的竞争,所以首先加锁,其他线程需要阻塞直到锁释放</p><p>但是加锁可能会带来额外的性能开销,如果是对于轻量级的并发,或者只是线程交替执行,就可能显得很笨重</p><p>那么,乐观锁应运而生,而它的一个实现就是 CAS</p><p>乐观锁是首先认为没有其他线程会对同一个数据进行改变,而当真正去操作共享变量的时候,再去看共享变量有没有被更新,如果没有就进行一个原子性的业务操作(通过硬件支持将非原子性的操作变成原子性),反之操作失败</p><p>CAS 的思想当然也和上面的类似,只是具体实现细节需要我们探究</p><p>Java 中实现 CAS 的是 Unsafe 类,其中有一个本地方法</p><div class="hljs"><pre><code class="hljs java">compareAndSwapObject(Object var1, <span class="hljs-keyword">long</span> v2, Object v4, Object v5);</code></pre></div><p>其中 var1 就是要改变的类对象,v2 则是要修改的字段的内存地址,v4 则是未修改之前的预期值,v5 则是新的值</p><p>这个方法是通过 JNI 调用 Unsafe.cpp 文件的一个函数,而这个函数(在Linux 版本下)又是汇编语言的<code>cmpxchg</code>指令,所以实际上是硬件层面上提供的 API 实现的</p><p>CAS 产生的问题:</p><ol><li><p>只能对单一共享变量操作</p><p>如果需要对多个变量进行 CAS 同步更新,那么还是得加锁解决</p></li><li><p>ABA</p><p>如果一个线程 CAS 将 A 值改变成了 B,另一个线程再将 B 改变成了 A,然后又有一个线程看到的依然是 A,就会认为这个值一直是 A,没有改变,此时在将 A 改为 C,这样就覆盖了之前两个线程的操作</p><ul><li><p>解决办法是: 增加一个字段来标识整个对象的版本,一旦进行了修改,就改变版本号</p><p>JDK 的实现: AtomicStampedReference</p><p>将对象和一个版本戳组成一个内部类 pair,相比没有版本戳的例如 AtomicInteger 每次更新还需要传入预期的版本戳</p></li></ul></li><li><p>如果用到了 CAS + 自旋</p><p>如果 CAS 不成功,会一直自旋重试导致 CPU 占用资源</p><p>甚至类似产生死锁的问题,那么就会一直占用,更损耗性能</p><p>所以要根据情况选择是否要加入自旋,分场景考虑</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识- (杂谈) 高并发高可用 VS 多线程正确性</title>
    <link href="/2020/4/23/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%20(%E6%9D%82%E8%B0%88)%20%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8-VS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A3%E7%A1%AE%E6%80%A7/"/>
    <url>/2020/4/23/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%20(%E6%9D%82%E8%B0%88)%20%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8-VS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A3%E7%A1%AE%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="header-anchor" href="#写在前面">⚡</a>写在前面</h2><p>文章是学习并发编程的时候,觉得并发编程难学,想到什么情况下需要用到并发编程,然后想到了一些情况,故记录之</p><a id="more"></a><p>我认为最主要的两个场景应该是:</p><ol><li><p>使用的人变多了,被迫需要高并发高可用</p></li><li><p>其次就是要将大任务进行一个拆分,需要使用多线程提高速度和效率</p></li></ol><h2 id="正文"><a class="header-anchor" href="#正文">⚡</a>正文</h2><p>假设我们现在有两个业务场景,一个是支付宝转账,一个是淘宝秒杀(抢火车票另说)</p><p>现在我们想想,哪个场景高可用高并发是要完全保证的,哪个场景是正确性优先的</p><p>这个时候你又会问了,为什么要有优先呢?不能两个都保证吗?</p><p>这里不讲原因,先摆事实:</p><p>你去支付宝还花呗或者微信提现的时候,是不是一般都会提示你,<code>业务正在审核/处理,两个小时内完成/到帐</code>,这个就是个铁证:</p><p>因为设计到转账,必须保证金额的正确性,加少了减少了谁负责?而对于并发量没有很高的要求(一不要求实时到账,二也没有那么多人会对同一个账户进行转账操作)</p><p>所以这些操作一般都是有一个最低时效,在时效内部,实际上是不保证操作的正确性的,例如:账也转了,钱也扣了,但是对方可能根本就没有收到,后台程序实际上还在处理后半部分的业务,这样就没有保证高可用(立刻响应,立刻处理完成),而完成了后面的业务处理之后,对方收到了款,才是一个真正的转账,最后才保证了正确性</p><hr><p>然后就是淘宝秒杀,对于这个场景,高可用则肯定是需要完全保证的</p><p>你可能又会问了,那是不是就可以不保证正确性了呢?</p><p>那也不是,这里说的正确性是,不能多卖,说白了,库存100件,你也要保证最多只卖100件,不能多卖了</p><p>但是!</p><p>这样也不是说同时满足了高并发和完全正确性,只能说是部分的正确性,或者说对于原则行问题保证正确性(当然的,因为不能把程序写的有问题是写程序的起码要求),非原则问题在<strong>一定程度上</strong>牺牲正确性来实现高可用</p><p>什么叫一定程度上?</p><p>例如秒杀的时候,你可能会去用一个锁把查看库存,付款,扣库存这三个操作给锁住,保证多线程同步</p><p>那么如果是并发量不太大可能可以,但是并发量很大,那么很多付款就会一直阻塞,用户看不到付款的结果,体验很差,而且,服务器产生很多线程阻塞,可能 CPU 飙高乃至当机</p><p>一个可以的解决方法就是,设置会一个超时的锁,如果线程在设定好的时间范围内没有获取到锁,那么就直接返回,告诉用户付款超时,稍后再试</p><p>这样就是保证了服务器提供的服务是高可用的,因为不会产生大量线程阻塞,导致服务没有办法响应或者处理速度很慢,一定时间内没有拿到锁就返回失败结果,如果拿到锁,立刻处理完成就成功,说白了就是立刻响应,立刻处理</p><p>但是,实际上,服务器立刻响应,返回失败结果的时候,不是说库存卖完了,有可能库存还有,仅仅只是你没有获取到锁(买东西的资格),跟库存多少其实根本没关系,这个就是上面我理解的在一定范围内,牺牲非原则性正确性来保证服务的高可用</p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识-- ReentrantLock</title>
    <link href="/2020/4/21/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-ReentrantLock/"/>
    <url>/2020/4/21/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h2 id="ReentrantLock-初步设计思想"><a class="header-anchor" href="#ReentrantLock-初步设计思想">⚡</a>ReentrantLock 初步设计思想</h2><p>new 一个 ReentrantLock 之后,调用 lock 方法,改变锁的状态码,从0变为1,主线程获取到锁,然后继续执行</p><!-- more --><p>如果此时同一个线程多次调用则进行多次重入,状态码增加</p><p>如果是线程交替执行,即并发度不是很高,那么就不存在锁的竞争,可以依次获取锁,然后依次释放,循环往复,保证高性能高可用</p><p>但是如果并发度很大,那么就一定存在线程之前对锁的竞争,这时,如果是公平锁,那么先获取锁的线程先处理,后获取锁的排在一个等待队列,然后这个线程就 <code>park</code> 暂停,然后等待锁释放和通知,<code>unpark</code> 后,再去获取锁</p><p>(注意:此处的 park 和 unpark 只是一种抽象概念,不一定指 LockSupport 里面的方法,也可以是 interrupt 中断)</p><p>但是,这里虽然想的很容易理解,但是要实现却不是那么容易,且看我如下分析</p><h2 id="ReentrantLock-类数据结构"><a class="header-anchor" href="#ReentrantLock-类数据结构">⚡</a>ReentrantLock 类数据结构</h2><h3 id="ReentrantLock-抽象内部类-Sync-锁"><a class="header-anchor" href="#ReentrantLock-抽象内部类-Sync-锁">⚡</a>ReentrantLock 抽象内部类 Sync 锁</h3><p>图 ReentrantLockSyncAndExtend:</p><p><img src="/img/ReentrantLockSyncAndExtend.png" srcset="/img/loading.gif" alt="ReentrantLockSyncAndExtend"></p><p>图 ReentrantLockSyncAndExtend1:<br><img src="/img/ReentrantLockSyncAndExtend1.png" srcset="/img/loading.gif" alt="ReentrantLockSyncAndExtend1"></p><p>从源码和上图可知, Sync 只有第一个 <code>lock()</code> 方法是抽象的,有一个默认的非公平的 <code>nonFairTryAcquired(int)</code> 方法,这个方法是<strong>尝试</strong>获取锁的,并且是一种非公平的方式</p><h2 id="Sync-的公平锁具体实现"><a class="header-anchor" href="#Sync-的公平锁具体实现">⚡</a>Sync 的<strong>公平锁</strong>具体实现</h2><p>图 AQSAbstractTryAcquire:</p><p><img src="/img/ReentrantLockFairSync.jpg" srcset="/img/loading.gif" alt="ReentrantLockFairSync"></p><p>一个 lock 方法,一个 tryAcquire 方法</p><p>lock 方法是 Sync 的具体实现,而 tryAcquire 则是<strong>重写</strong>了 Sync 的父类 AQS 的方法</p><p><span id="ReentrantLockFairSync1">图 ReentrantLockFairSync1</span><br><img src="/img/ReentrantLockFairSync1.jpg" srcset="/img/loading.gif" alt="ReentrantLockFairSync1"></p><h2 id="ReentrantLock-加锁过程-公平锁"><a class="header-anchor" href="#ReentrantLock-加锁过程-公平锁">⚡</a>ReentrantLock 加锁过程 (公平锁)</h2><h3 id="第一次加锁"><a class="header-anchor" href="#第一次加锁">⚡</a>第一次加锁</h3><ol><li><p>new 是默认非公平锁(这里分析公平锁)</p> <div class="hljs"><pre><code class="hljs java">sync = <span class="hljs-keyword">new</span> FairSync();</code></pre></div></li><li><p>当程序中调用 <code>reentrantLock.lock()</code> 方法时</p><p>lock() 方法就会调用 <code>sync.lock()</code> 方法</p><p>(sync 锁具体实现 lock 方法的 非公平的锁和公平锁不同)</p><p>由上面两张图可知,在 <code>lock()</code> 方法里面直接调用的是 <strong>AQS</strong> 的 <code>acquire(int)</code> 方法, 并且参数为1</p></li><li><p>那我们再去看 AQS</p><p><span id="AQSAcquire"><img src="/img/AQSAcquire.jpg" srcset="/img/loading.gif" alt="AQSAcquire"></span></p><p>我们可以看到首先会调用 <code>tryAcquire(int)</code> 方法,这也是 AQS 中的一个方法,我们可以根据名称猜测这个方法是用来<em>尝试获取锁</em>的</p><p>点进去,发现:</p><p><img src="/img/AQSAbstractTryAcquire.png" srcset="/img/loading.gif" alt="AQSAbstractTryAcquire"></p><p>仅仅抛一个异常?!</p><p>这当然不可能,因为这样没有任何意义</p><p>再按住 <code>ctrl</code>和<code>alt</code>,鼠标点击 <code>tryAcquire</code>,出现如下具体实现:</p><p><img src="/img/AQSAbstractTryAcquire1.jpg" srcset="/img/loading.gif" alt="AQSAbstractTryAcquire2"></p><p>我们点击第一个,发现回到了 ReentrantLock 里面的 FairSync 静态内部类的 <code>tryAcquire(int)</code> 方法, <a href="#ReentrantLockFairSync1">见图 ReentrantLockFairSync1</a></p><p>这说明,内部的公平锁自己重写了 AQS 的方法但是没有加 <strong><code>@Override</code></strong> 注释!</p></li><li><p>再回到 ReentrantLock 看这个公平锁的 <code>tryAcquired(int)</code> 方法(和<a href="#ReentrantLockFairSync1">图ReentrantLockFairSync1 一样,只是把代码贴出来了</a>)</p><p>具体分析见<span id="ReentrantLockFairSyncTryAcquire">注释:</span></p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;    <span class="hljs-comment">// 拿到当前线程</span>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();    <span class="hljs-comment">// 拿到 AQS 的内部 volatile 变量 state</span>    <span class="hljs-keyword">int</span> c = getState();    <span class="hljs-comment">// 如果 state =0 说明此时没有线程拿到锁</span>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 第一个 hasQueuedPredecessors() 是 AQS 的内部方法,是用来判断自己需不需要排队</span>        <span class="hljs-comment">// 返回 false 在表示队列不存在或者队列中没有前驱(即队列中没有已经拿到锁的线程)</span>        <span class="hljs-comment">// 那么这个线程就不需要排队</span>        <span class="hljs-comment">// 为什么需要排队呢,最前面将思想的时候其实已经说了:</span>        <span class="hljs-comment">// 想想如果存在多线程竞争,而且又是公平锁,那么就需要排队等待,直到前面那个线程处理完了,后面的线程才能拿到锁,再去处理</span>        <span class="hljs-comment">// todo 这里理解排队要看之后的线程竞争或者其他特殊情况,我们这里假设的是第一个线程来拿锁,暂时不考虑,因为从开始到现在根本没有初始化队列(new FairSync 也没有初始化 Sync 父类的 AQS 队列)</span>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;                <span class="hljs-comment">// 下面调用 AQS 的 CAS 方法,原子操作,改变的是 AQS 内部的 state 变量</span>                <span class="hljs-comment">// CAS 尝试加锁</span>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;            <span class="hljs-comment">// 如果前面的条件成立,说明: 1. 自己不需要排队 2. 自己成功拿到锁了</span>            <span class="hljs-comment">// 此时就可以将锁设置为当前线程</span>            <span class="hljs-comment">// 注意,这个方法是 `AQS` 继承 `AOS` 这个抽象类自己内部的方法,表示是一个排他锁</span>            <span class="hljs-comment">// 关于 AOS 具体看下面相应的地方,这里就不多做解释,现在就认为是一个排他锁</span>            setExclusiveOwnerThread(current);             <span class="hljs-comment">// 返回 true,表示成功加上了排他锁</span>            <span class="hljs-comment">// 第一个线程到这里返回</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    <span class="hljs-comment">// 又有一个线程来了,如果锁状态不为0,说明已经加锁,并且该线程就是之前加锁的第一个线程,此时会重入,state +1,并返回 true,代表重入锁加锁成功</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;        <span class="hljs-comment">// 可能在这里会想,c 是最前面 getState() 方法得到的,为什么这里不用 CAS 来保证原子操作呢?</span>        <span class="hljs-comment">// 因为其它的线程如果来了,会首先排队,不会改变第一个线程的状态值</span>        <span class="hljs-comment">// 但是如果第一个线程此时刚好释放所了,岂不是重入错了?</span>        <span class="hljs-comment">// 这里就要看上面的 else-if 判断了,如果是同一线程重入,然后释放,然后再加锁是不可能的,一个线程怎么可能同时加锁和解锁呢!</span>        <span class="hljs-comment">// 上面是目前我的分析,如果加上锁自动释放(超时释放)的功能 tryLock 可能会有问题?</span>        <span class="hljs-comment">// 解答: tryLock 是在指定时间内获取锁,而不是在指定时间内释放拿到的锁,拿到锁释放必须由这个线程显式调用 unLock 方法,所以根本不会存在自动释放锁这个逻辑</span>        <span class="hljs-comment">// 超时释放指的是超过时间没有拿到就放弃抢锁,不是超时了就释放锁</span>        <span class="hljs-keyword">int</span> nextc = c + acquires;        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);        setState(nextc);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 如果锁状态不为0,并且是另一个线程来加锁,会返回 false</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p>关于 <code>hasQueuedPredecessors() </code> 方法,放到 AQS 章节再讲,这些 AQS 内部方法也有很多需要分析</p></li><li><p>方法 <code>tryAcquire(int)</code> 返回 true,回到<a href="#AQSAcquire">前面 AQS 的 acquire</a></p><p>此时 if 条件不成立,直接返回了,然后递归返回,就没有什么,结束程序中的 <code>reentrantLock.lock()</code> 方法,加锁成功,主程序继续执行</p></li></ol><h3 id="如果此时第一个线程又来加锁-重入"><a class="header-anchor" href="#如果此时第一个线程又来加锁-重入">⚡</a>如果此时第一个线程又来加锁(重入)</h3><p>此时在 <code>ReentrantLock</code> 中的 <code>FairSync</code> 的 <code>tryAcquire(int)</code> 方法里面,进入 else 判断,<a href="#ReentrantLockFairSyncTryAcquire">请看代码注释 else-if 部分</a></p><p><code>tryAcquire(int)</code> 返回 true, 然后也是和第一次拿到锁一样,调用递归返回,主程序继续执行</p><p>不过需要注意,<code>FairSync</code> 公平锁的父类 AQS 的内部状态 volatile 变量 state 每次都要加一,而每次释放锁的时候,state 才会减一,最后一定要变为0才释放了所有锁</p><h3 id="如果是第二个线程来了-也开始加锁-并且此时第一个线程还没有释放锁"><a class="header-anchor" href="#如果是第二个线程来了-也开始加锁-并且此时第一个线程还没有释放锁">⚡</a>如果是第二个线程来了,也开始加锁,并且此时第一个线程还没有释放锁</h3><ol><li><p>同上面两种情况,会调用 <code>sync.lock()</code> 方法,然后 <code>acquire(1)</code>,再然后 <code>tryAcquire(1)</code></p><p>但是此时 if 和 else 条件都不满足,会返回 false</p></li><li><p><a href="#AQSAcquire">此时AQS 的</a> <code>acquire(1)</code> 方法中 if 的第一个 <code>tryAcquire(1)</code> 取反,值为 true,进入 <code>acquiredQueue(addWaiter(Node.Exclusive,1))</code> 两个方法</p><p>这两个方法就不在这里分析了,因为这是属于 AQS 内部实现,而且很复杂,需要单独说</p><p>我们现在就只需要知道,这里第二个线程就会去在 AQS 内部排队等待</p><p>再然后,会调用 <code>selfInterrupt()</code> 方法,这个 AQS 方法比较简单,就把代码截出来了</p><p><img src="/img/AQSSelfInterrupt.png" srcset="/img/loading.gif" alt="AQSSelfInterrupt"></p><p>把当前线程中断,来让出 CPU 等待 AQS 的唤醒</p></li></ol><h2 id="ReentrantLock-加锁过程-非公平锁"><a class="header-anchor" href="#ReentrantLock-加锁过程-非公平锁">⚡</a>ReentrantLock 加锁过程 (非公平锁)</h2><p><span id="ReentrantLockNonFairSync">如图 ReentrantLockNonFairSync:</span></p><p><img src="/img/ReentrantLockNonFairSync.png" srcset="/img/loading.gif" alt="ReentrantLockNonFairSync"></p><h3 id="第一次加锁-v2"><a class="header-anchor" href="#第一次加锁-v2">⚡</a>第一次加锁</h3><ol><li><p>有源码和上图知,调用 <code>ReentrantLock.lock()</code> 方法时,会调用上图中非公平锁 NonFairSync 的方法</p><ol><li><p>首先会 CAS 直接尝试抢占锁,如果抢到了就直接上锁,程序正常返回</p><p>就是比公平锁少了一个判断方法 <code>!hasQueuedPredecessors()</code> 来判断需不需要排队</p><p>非公平锁当然不需要排队啦~</p></li><li><p>如果没有没有直接抢到,那么其实还是要排队,调用 AQS 的 <code>acquire()</code> 方法</p><p>注意,这个时候就不要认为之后的逻辑和公平锁一模一样,因为锁在继承 <code>AQS</code> 的实现的时候,都重写了 <code>AQS</code> 的 <code>tryAcquire()</code> 方法</p><p>对于非公平锁来说,它默认使用的是 <code>ReentrantLock</code> 类中 <code>Sync</code> 父类里面的 <code>nonFairTryAcquire()</code> 方法</p><ol><li><p>nonFairTryAcquire()</p><p><img src="/img/ReentrantLockNonFairTryAcquire.png" srcset="/img/loading.gif" alt="ReentrantLockNonFairTryAcquire"></p><p>和公平锁的实现没有太大差别,仅仅只是少了 <code>hasQueuedPredecessor()</code> 这个重要的查看队列的方法,会上来就去尝试获取锁,而不考虑是否存在等待队列</p></li></ol></li></ol></li></ol><h3 id="重入情况则和公平锁一致"><a class="header-anchor" href="#重入情况则和公平锁一致">⚡</a>重入情况则和公平锁一致</h3><p><a href="#ReentrantLockFairSyncTryAcquire">同上的 else-if</a></p><h3 id="第二个线程来加锁了"><a class="header-anchor" href="#第二个线程来加锁了">⚡</a>第二个线程来加锁了</h3><p>假设存在线程竞争,那么根据 <a href="#ReentrantLockNonFairSync">图</a>,和公平锁一样,还是会进入上图的 <code>nonFairTryAcquire()</code>,然后返回 false,然后调用 AQS 的 <code>addWaiter()</code> 和 <code>acquireQueued()</code> 加入到等待队列中,<code>selfInterrupt()</code>方法自我中断</p><h2 id="ReentrantLock-解锁过程"><a class="header-anchor" href="#ReentrantLock-解锁过程">⚡</a>ReentrantLock 解锁过程</h2><h3 id="线程调用了-unLock"><a class="header-anchor" href="#线程调用了-unLock">⚡</a>线程调用了 unLock</h3><p><img src="/img/ReentrantLockSyncUnLock.png" srcset="/img/loading.gif" alt="ReentrantLockSyncUnLock"></p><p>然而这个 <code>release(1)</code> 方法又是 AQS 内部的方法:</p><p><img src="/img/AQSRelease.png" srcset="/img/loading.gif" alt="AQSRelease"></p><p>从上面可以看到,这里首先调用了一个 <code>tryRelease(1)</code> 方法</p><p><img src="/img/ReentrantLockTryRelease.png" srcset="/img/loading.gif" alt="ReentrantLockTryRelease"></p><ol><li><p><code>tryRelease()</code> 方法</p><p>这个是 <code>ReentrantLock</code> 内部 <code>Sync</code> 自己实现的默认方法,并且公平锁和非公平锁调用一致</p><p>由于锁可以重入,所以这里 <code>getState()</code> 获取到的状态值可能大于1,所以此处要减去参数 release (=1) 拿到预期值</p><p>然后进行判断,如果不是锁持有的线程拿到锁会抛出异常(一般不会出现)</p><p>如果上面预期的状态值等于0,则说明锁可以释放,此时就把共享锁设为空;反之,不进行该操作</p><p>(注意:锁为空并不代表锁已经释放,因为锁的状态是由 state 字段标识的,此时并没有改锁的状态)</p><p>然后改变锁的状态 <code>setState()</code>,并且返回释放锁的结果</p><p>想想这里改变状态为什么不用 CAS 操作?原因其实上面提到一些</p><p>因为此时线程又不可能重入(这个线程正在释放,怎么可能会重入),如果是别的线程,在 <code>setState()</code> 操作之前,锁还没有释放又不可能来抢锁,所以这里就可以安安心心的进行锁的状态改变了</p></li><li><p>tryRelease() 方法返回了,之后就是 AQS 的内部实现和状态判断了</p><p>老规律还是把这个实现留在讲 AQS 的文章里面集中分析吧</p><p>我们只需要知道此时锁已经释放,并且把 AQS 的内部状态 state 重置成 0,并且锁头已经置为空就行了</p></li></ol><h2 id="写在后面"><a class="header-anchor" href="#写在后面">⚡</a>写在后面</h2><p>AQS 和 ReentrantLock 代码,首先看子路老师的视频和马士兵的视频,然后对着源码一点点分析,做笔记,再结合博客看</p><p>自己再把 AQS 和 ReentrantLock 的类图先理清楚,有哪些内部类,哪些方法,哪些是抽象的,哪些是具体实现,分别做了什么,一层层理清楚</p><p>这篇文章仅仅分析了 ReentrantLock, 很多更重要的代码其实在 AQS 里面,具体分析就暂时等待 AQS 的文章吧</p><p>要不然,ReentrantLock 用到了 AQS 的一部分 api,我们就去看 AQS, 看了 AQS 又不知道像 <code>tryAcquire()</code> 和 <code>acquire()</code> 到底分别在什么情况下使用,又要回到 ReentrantLock 去看 api 的应用,让人云里雾里,非常头疼</p><p>其实也没有分析很多,<s>这么一想其实 ReentrantLock 还挺简单的</s></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- ICP 优化</title>
    <link href="/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-ICP-%E4%BC%98%E5%8C%96/"/>
    <url>/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-ICP-%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Index Condition Pushdown (ICP)</p><ul><li><p>目的: 在取出索引的同时,提前判断 where 条件,从而提前过滤一部分不符合条件的记录</p>  <a id="more"></a></li><li><p>适用条件:explain 的 type 为 range,ref,eq_ref,ref_or_null,而 Extra 可以看到 using index condition</p></li><li><p>好处: 减少上层 SQL 层对记录的索取,从而提升数据库的整体性能</p></li><li><p>工作方式:</p><p>如果没有 ICP,在进行索引查询时,首先会根据索引查找记录,然后再根据 where 条件来过滤</p><p>而使用 ICP 之后,存储引擎在取出索引的同时,会判断是否可以进行 where 条件过滤,也就是<strong>将 where 部分过滤操作放到了存储引擎层</strong>,在某些查询下,可以大大减少上层 SQL 层对记录的索取,从而提高数据库的整体性能</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- MRR 优化</title>
    <link href="/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-MRR%20%E4%BC%98%E5%8C%96/"/>
    <url>/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-MRR%20%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Multi-Range Read (MRR)</p><ul><li><p>目的:通过将随机 IO 排序,优化为顺序 IO 减少磁盘随机访问</p>  <a id="more"></a></li><li><p>命令: <code>set optimizer_switch='mrr=on';</code></p></li><li><p>适用条件: explain 的 type 为 range,ref,eq_ref 类型的查询,extra 会显示 using MRR</p></li><li><p>好处:</p><ol><li><p>MRR使<strong>辅助索引</strong>的回表访问变得较为顺序</p><p>在<strong>辅助索引</strong>中,首先根据得到的查询结果按照主键升序排序,再去回表查找</p><p>这样的好处是:</p><ol><li><p>磁盘和磁头不再需要来回做机械运动</p></li><li><p>可以充分利用磁盘预读</p><p>可以把后面可能用到的数据预先读出来</p></li><li><p>在一次查询中，每一页的数据只会从磁盘读取一次</p><p>即减少缓冲池中页被替换的次数,每次用完就不会重复再加载进来了</p></li></ol></li><li><p>批量处理对键值的查询操作</p></li><li><p>此外,MRR 还可以将某些范围查询,拆分为键值对,以此来进行批量数据查询</p><p>好处是在拆分过程中,直接过滤一些不符合查询条件的数据,保证取出的都是有效的数据,而不会直接先根据一个条件取数据,然后再根据第二个条件进一步过滤</p></li></ol></li><li><p>工作方式(InnoDB 和 MyISAM):</p><ol><li><p>优化器将二级索引查询到的记录放到一块缓冲区中,这时数据是根据二级键值排序的</p></li><li><p>如果二级索引扫描到文件的末尾或者缓冲区已满,则使用<strong>快速排序</strong>对缓冲区中的内容按照<strong>主键</strong>进行排序</p></li><li><p>用户线程调用 MRR 接口取 cluster index,然后根据 cluster index 取行数据</p></li><li><p>当根据缓冲区中的 cluster index 取完数据,则继续调用上述过程,直至扫描结束</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- InnoDB 和 MyISAM</title>
    <link href="/2020/4/15/MySQL-%E7%9F%A5%E8%AF%86-InnoDB-%E5%92%8C-MyISAM/"/>
    <url>/2020/4/15/MySQL-%E7%9F%A5%E8%AF%86-InnoDB-%E5%92%8C-MyISAM/</url>
    
    <content type="html"><![CDATA[<h2 id="区别"><a class="header-anchor" href="#区别">⚡</a>区别</h2><ol><li><p>InnoDB 支持事务,MyISAM 不支持事务</p></li><li><p>InnoDB 是聚簇索引,MyISAM 是非聚簇索引</p><p>InnoDB 是聚簇索引,聚簇索引文件放在主键索引的叶子节点上,但是辅助索引需要两次查询:先查到主键,然后根据主键回表查到数据</p><p>对于 InnoDB 的聚集索引,就是<strong>表本身</strong></p><p>InnoDB 的聚集索引中,有主键列,事务 id,回滚指针,非主键列</p><p>MyISAM 是非聚簇索引,数据文件是分离的,索引保留的是数据文件的指针,主键索引和辅助索引是独立的</p></li><li><p>InnoDB 支持外键,MyISAM 不支持外键</p></li><li><p>InnoDB 不保存表的行数,MyISAM 保留了表的行数</p><p>所以 InnoDB 在 <code>count(*)</code> 会进行全表扫描</p></li><li><p>InnoDB 锁的最小粒度是行锁,MyISAM 最小粒度是表锁</p><p>MyISAM 在更新一行数据时会锁住整个表,限制并发量,这是 MySQL 5.2 将默认的 MyISAM 换成 InnoDB 的主要原因</p><p>不过 InnoDB 的行锁是实现在索引上的,所以如果没有命中索引行锁会退化成表锁</p></li><li><p>InnoDB 可以在崩溃后安全恢复,MyISAM 不行</p></li><li><p>InnoDB 键值一起保存，索引与数据一起载入InnoDB缓冲池;MyISAM键值分离，索引载入内存(key_buffer_size),数据缓存依赖操作系统</p></li></ol><h2 id="相同"><a class="header-anchor" href="#相同">⚡</a>相同</h2><p>索引都是 B+ 树结构</p><h2 id="如何选择"><a class="header-anchor" href="#如何选择">⚡</a>如何选择</h2><ol><li><p>MyISAM 管理非事务表，提供高速存储和检索以及全文搜索能力，如果表数据一般改变不大，只是执行大量读操作或者不需要事务管理，应该选择 MyISAM</p></li><li><p>没有特殊要求就选择 InnoDB</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识--索引</title>
    <link href="/2020/4/14/MySQL-%E7%9F%A5%E8%AF%86-%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/4/14/MySQL-%E7%9F%A5%E8%AF%86-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="几种索引"><a class="header-anchor" href="#几种索引">⚡</a>几种索引</h2><h3 id="聚集索引-聚簇索引-cluster-index-主键索引"><a class="header-anchor" href="#聚集索引-聚簇索引-cluster-index-主键索引">⚡</a>聚集索引 (聚簇索引 cluster index)(主键索引)</h3><p>聚集索引数据行的<strong>物理顺序</strong>与列值(一般是主键列)的逻辑顺序相同</p><a id="more"></a><p>注意,这里有一个很容易误解的点:</p><blockquote><p>这里说的是物理顺序,而不是物理上<strong>连续</strong></p><p>主要是由于是双向链表,而且会有页分裂时候的复制过程,那么在物理地址上,就肯定不是顺序的了</p></blockquote><p>聚簇表示数据行和相邻的键值(逻辑上)紧凑地存储在一起</p><p>因为无法同时把数据数据行存放在两个不同的地方,所以一个表中只能拥有<strong>一个聚集索引</strong></p><p>即对于 InnoDB 的聚集索引,就是表本身</p><ul><li><p>优点:</p><ol><li><p>把相关数据保存在一起,顺序读取,减少磁盘 IO</p></li><li><p>数据访问更快</p></li><li><p>覆盖索引扫描查询可以直接使用页节点的主键值</p></li></ol></li><li><p>缺点:</p><ol><li><p>虽然极大提高了 IO 密集应用的性能,但是如果数据全部放到内存中,访问顺序就没那么重要了</p></li><li><p>如果不是按照主键的顺序对表进行插入会非常慢(为了保持索引的物理顺序一致,可能在数据页中进行重排)</p></li></ol></li></ul><ol><li><p>更新索引列的代价很高,因为会强制将每个被更新的行移动到新的位置</p><ol><li><p>插入是可能面行页分裂问题,导致表占用更多的磁盘空间</p></li><li><p>可能导致全表扫描比较慢,尤其是行比较稀疏或者由于页分页导致数据存储不连续的时候</p></li><li><p>非聚簇索引可能要比想象的大,因为包含了所有引用行的主键列</p></li><li><p>回表成本</p></li></ol></li></ol><h3 id="非聚集索引-非聚簇索引-non-cluster-index-二级索引-辅助索引"><a class="header-anchor" href="#非聚集索引-非聚簇索引-non-cluster-index-二级索引-辅助索引">⚡</a>非聚集索引 (非聚簇索引 non cluster index)(二级索引,辅助索引)</h3><p>辅助索引是相对主键索引而言的,其实就是非聚集索引</p><p>聚集索引实际上不是一种单独的索引,而是一种数据存储方式</p><p>网上说:</p><blockquote><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的逻辑排列顺序是否一致</p></blockquote><p>实际上不对,我认为应该是:</p><p>聚集索引和非聚集索引的根本区别是聚集索引在叶子节点存储行,而非聚集索引则是存储指针</p><p>非聚集索引的叶子节点记录数据页的<strong>指针</strong>或者<strong>主键</strong>而不是数据,虽然不同引擎的非聚集索引都是指针,但是不同的引擎不同的指针类型不一样</p><p>MyISAM 引擎都是非聚集索引,而且索引的叶子节点存储的都是数据文件的指针</p><p>InnoDB 引擎的主键索引是聚集索引,主键索引叶子节点都是存一行记录,辅助索引是存储主键的值</p><p>在 InnoDB 里面主键索引是存储了<strong>一行的值</strong>,但是辅助索引(非聚集索引)仅仅存储<strong>主键</strong>,如果没有主键,则会自动选择一个可以唯一标识的字段,如果也没有,则存储默认隐含的 row id</p><p>如果用到了辅助索引,但是所选取的属性又没有存储,那么就会进行<strong>回表</strong>:先拿到主键,然后根据主键在主键索引上再进行查找,解决办法则可以用下面写到的覆盖索引</p><h3 id="覆盖索引-covering-index"><a class="header-anchor" href="#覆盖索引-covering-index">⚡</a>覆盖索引 (covering index)</h3><p>指查询语句的执行只用从索引中就能够获得,不必从表中读取,也可以称之为索引覆盖</p><p>一般多是联合索引</p><p>如果一个索引包含了(或覆盖了)查询语句中的字段和条件的数据就叫覆盖索引</p><p>索引覆盖成立时,SQL 只需要通过索引就可以返回查询的数据,避免了回表操作</p><p>覆盖索引使用 InnoDB 比 MyISAM 好,因为 InnoDB 使用聚集索引组织数据,如果二级索引中包含查询所需的数据,就不需要在聚集索引中查找了</p><p>explain 的 extra 中有 using index 表示用到了覆盖索引</p><p>(如果同时有 using index 和 using where 说明索引不仅仅用来读取数据,还被用来查找)</p><p>注意:</p><ol><li><p>覆盖索引一般不可 select *,而一般是索引中的,并且是所需要用到的列</p></li><li><p>不一定所有存储引擎都支持覆盖索引,并且不同的引擎实现方式都可能不同</p></li><li><p>Hash 索引和全文索引(FULL-Text)不存储值</p></li><li><p>最左匹配原则</p></li></ol><p>覆盖索引的优点:</p><ol><li><p>索引项一般比较小,可以访问更少的记录</p></li><li><p>索引按照值的大小记录,减少随机IO</p></li></ol><h3 id="全文索引-full-text-index"><a class="header-anchor" href="#全文索引-full-text-index">⚡</a>全文索引 (full text index)</h3><p>InnoDB 和 MyISAM 在 5.6 以后都支持全文索引</p><p>对于字符数量比较少的情况下,<code>like</code> 或者 <code>%</code> 都是常规解决方案,但是对于大量的文本数据检索，<code>like</code> 或者 <code>%</code> 是不可想象的</p><p>全文索引在大量的数据面前，能比 <code>like</code> 或者 <code>%</code> 快得多，速度不是一个数量级，但是全文索引可能存在精度问题</p><ul><li><p>倒排索引(inverted index): 它在辅助表中存储了单词和单词自身在一个或者多个文档中的位置映射,具体有两种表现形式:</p><ol><li><p>inverted file index,表现为 {单词,单词所在文档ID}</p></li><li><p>full inverted index,表现为 {单词,(单词所在文档ID,在文档中的具体位置)}</p></li></ol></li><li><p>InnoDB 采用 full inverted index 方式,将 (documentID,position)视为一个 ilist,单词视为 word,并且在 word 上建立索引</p><p>(word,ilist)就是两列,建立的表被称为 Auxiliary Table (辅助表),并且为了提升性能,一共有6张 Auxiliary Table</p><p>并且,由于有 position,所以可以进行模糊搜索</p></li><li><p>FTS Index Cache (全文检索索引缓存)</p><p>它是一个红黑树,根据(word,ilist)排序</p><p>所以可能写入数据的表已经更新,但是全文索引的更新数据还在 FTS 中,Auxiliary Table 还没有更新</p><p>InnoDB 会批量对 Auxiliary Table 进行批量更新,而不是一个个更新</p><p>这样当查询时,会首先将在 TFS 中对应的 word 字段合并到 Auxiliary Table 中,在进行查询</p><p>这种操作类似 Insert Buffer,不同的是 Insert Buffer 是持久对象,还是 B+ 树结构</p></li></ul><h3 id="哈希索引"><a class="header-anchor" href="#哈希索引">⚡</a>哈希索引</h3><p>基于哈希表实现</p><ul><li><p>缺点</p><ol><li><p>哈希冲突,对于每一个 hash 值相同的数据,查找时,必须进行逐行比较,而插入时也要维护相同 hash 值的数据</p></li><li><p>哈希索引只包含哈希值和行指针,而不存储字段值</p><ol><li><p>索引无法实现索引覆盖,必须回表</p></li><li><p>要么全部使用索引,要么不使用,无法使用部分索引加快查询速度</p></li><li><p>索引数据无法排序</p></li><li><p>必须精确匹配索引所有的列的查询才有效,不支持范围查询</p></li></ol></li></ol></li></ul><h3 id="其它索引"><a class="header-anchor" href="#其它索引">⚡</a>其它索引</h3><ul><li><p>外键索引: 对外键建立的索引,方便外键的级联</p></li><li><p>唯一索引: 索引值唯一</p></li></ul><h2 id="索引优化–建立高性能索引"><a class="header-anchor" href="#索引优化–建立高性能索引">⚡</a>索引优化–建立高性能索引</h2><ol><li><p>独立的列</p><p>SQL 语句的索引列不能是表达式的一部分,也不能是函数的参数 -&gt; 化简</p></li><li><p>前缀索引</p><p>如果索引是很长的字符列,使索引变得很大并且很慢,则可以在适当范围内降低索引的选择性,只对字符序列的前面几位建立索引</p><p>索引的选择性是指,不重复的索引值和记录总数的比值,选择性越高查询效率越高</p><p>缺点: 无法使用前缀索引做 order by 和 group by,也无法做覆盖扫描</p><p>如果有的列选择性都很低,例如 url 前面都是 www,那么我们可以尝试使用后缀索引,例如将 url 倒过来存 (类似的有爬虫中的倒排文档),再建立前缀索引</p></li><li><p>多列索引</p><p>MySQL 5.0 以后,其实查询可以同时使用多个单列索引进行扫描,并将结果合并 (explain 中 extra 的 <strong>index_merge</strong>)</p><p>虽然 MySQL 可以这样,但是实际上更多说明了表上的索引建的很糟糕:</p><blockquote><p>通常有多个 AND 条件,则一般需要包含所有相关列的多列索引,而不是多个独立的索引</p><p>通常有多个 OR 条件,则一般需要耗费大量 CPU 和内存资源在算法的缓存,排序和合并操作上,特别是索引的选择性不高,返回大量数据的时候</p><p>更重要的是,优化器不会把这些计算计算到查询成本中,优化器只关心随机读取</p><p>这样做不但更加消耗资源,还可能会影响查询的并发性</p></blockquote><p>在这种情况下,尽量建立多列索引甚至实现覆盖索引</p></li><li><p>选择合适的索引列顺序</p><blockquote><p>经验法则: 将选择性最高的索引放到最前列</p></blockquote><p>然而,这是不考虑排序和分组的情况下,只优化 where 条件的查找</p><p>如果可以的话,还是要考虑特殊的记录,例如,有一些特殊的记录,未登录的游客的session的记录查找就可能很庞大,这就需要我们在程序代码里面区分游客和普通用户了</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识 -- JMM</title>
    <link href="/2020/4/14/JVM-%E7%9F%A5%E8%AF%86-JVM-%E5%92%8C-JMM/"/>
    <url>/2020/4/14/JVM-%E7%9F%A5%E8%AF%86-JVM-%E5%92%8C-JMM/</url>
    
    <content type="html"><![CDATA[<h2 id="JMM-结构"><a class="header-anchor" href="#JMM-结构">⚡</a>JMM 结构</h2><p><img src="/img/JMM.png" srcset="/img/loading.gif" alt="JMM"></p><p>(再看看和 CPU 的结构像不像)</p><p><img src="http://cdn.yinchao.tech/CPU%20%E7%BB%93%E6%9E%84" srcset="/img/loading.gif" alt="CPU 结构"></p><h3 id="存储数据时"><a class="header-anchor" href="#存储数据时">⚡</a>存储数据时</h3><p>JMM 的工作空间主要存放<strong>私有数据</strong>和<strong>基本数据类型</strong></p><p>JMM 的共享空间主要存放<strong>线程共享数据</strong></p><h3 id="修改数据时"><a class="header-anchor" href="#修改数据时">⚡</a>修改数据时</h3><p>当线程修改私有数据时，<strong>直接在工作内存修改</strong></p><p>当线程1 和线程2 修改他俩共享的数据时，需要先从主内存将数据复制到工作内存中，修改完成后，需要再刷入共享内存中</p><h2 id="JMM-解释"><a class="header-anchor" href="#JMM-解释">⚡</a>JMM 解释</h2><p>JMM (Java Memory Model) 定义了 Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM 是整个计算机虚拟模型，所以 JMM 隶属于 JVM</p><p>Java 虚拟机规范中试图定义一种 <code>Java 内存模型</code>,来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>,以实现 Java 程序在各种平台下都能达到一致的内存访问效果</p><p>JMM 主要目标就是定义程序中各个变量的访问规则,即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</p><p>JMM 决定一个线程对共享变量的写入何时对另一个线程可见</p><p>JMM 即 Java 线程之间的通信是采用共享内存模型</p><p>Java 内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步</p><p>这里的内存模型是指,在特定的操作协议下,对特定的内存或高速缓存进行读写访问的过程抽象</p><h3 id="JMM-是抽象概念"><a class="header-anchor" href="#JMM-是抽象概念">⚡</a>JMM 是抽象概念</h3><p>JMM 是一个抽象概念，并不真是存在，但是无论是工作空间还是共享空间，都包括了真实的 CPU cache、寄存器和机器本身的内存等</p><ul><li><p>这样设计的好处是:</p><p>保证数据的<strong>隔离性</strong>,如果没有工作空间,一个线程读一个线程写,或者多个同时写入,就更容易数据不一致。</p></li><li><p>带来的缺点:</p><p>线程访问共享变量时,线程不安全</p><p>一个线程已经写完但是还没来得及刷入到内存中，但是另一个线程已经从内存中读入了原有的数据，会导致读到了脏数据</p></li></ul><h2 id="JMM-问题和目标"><a class="header-anchor" href="#JMM-问题和目标">⚡</a>JMM 问题和目标</h2><p>当对象和变量可以存储在计算机中不同的内存区域时,会出现两个主要问题:</p><ol><li><p>线程更新(写)到共享变量的可见性</p></li><li><p>读取,检查和写入共享变量时的竞争条件</p></li></ol><p>JMM 是围绕并发过程中如何处理可见性,原子性和有序性这3个特征建立起来的</p><ol><li><p>可见性: volatile,synchronized,final</p></li><li><p>原子性: 一个操作或多个操作,要么全部执行不被打断,要么都不执行</p></li><li><p>有序性: 计算机在执行程序时,为了提高性能,会进行指令重排(包括: 编译器优化重排,指令并行重排,内存系统重排)</p><ol><li><p>as-if-serial: 即在指令重排时,无论怎么优化,单线程程序执行程序的结果不会改变</p></li><li><p>happens-before</p><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系</p><ol><li><p>程序顺序规则: 一个线程中的每个操作,happens-before 于线程中的任意后续操作</p></li><li><p>监视器锁规则: 一个锁的解锁,happens-before 于随后对这个锁的加锁</p></li><li><p>volatile 规则: 对一个 volatile 域的写,happens-before 于任意后续对这个 volatile 域的读</p></li><li><p>传递性: 如果 A happens-before B,且 B happens-before C,那么 A happens-before C</p></li></ol><blockquote><p>特别注意:</p><p>两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！</p><p>happens-before 仅仅要求前一个操作执行的结果对后一个操作<strong>可见</strong>,且前一个操作按顺序排在第二个操作之前</p></blockquote><p>最后一句话的意思是,前一个操作可能后被执行，但是前一个操作的结果一定先于后一个结果之前被后一个操作看到,前一个操作也可以比后一个操作先或者后执行,但是一定是前一个操作先出结果</p></li></ol><p>这三个特征底层实现都是通过内存屏障实现的</p></li></ol><h2 id="JMM-和-JVM-的区别和联系"><a class="header-anchor" href="#JMM-和-JVM-的区别和联系">⚡</a>JMM 和 JVM 的区别和联系</h2><ul><li><p>联系:</p><p>JVM 就是按照 JMM 来划分的,定义了哪些是共享区域（共享空间）哪些是线程私有区域（工作空间）</p></li><li><p>区别:</p><p>JMM 是规范,是抽象模型,并不真实存在</p><p>而 Java 中的内存区域可能是内存也有可能是 CPU 的高速缓存，是具体存在的</p></li></ul><h2 id="JMM-具体如何工作的"><a class="header-anchor" href="#JMM-具体如何工作的">⚡</a>JMM 具体如何工作的</h2><p>不同的线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存完成。一个变量如何从主内存拷贝到工作空间，又如何从工作空间同步回共享空间，JMM定义了一下8种操作来完成，虚拟机实现时必须保证每一个操作的原子性。</p><ul><li><p>lock(锁定) 作用于主内存的变量，将变量标识为一条线程独占的状态。</p></li><li><p>unlock(解锁) 作用于主内存的变量，将一个处于锁定状态的变量释放出来，释放后的变量可以被其他线程锁定。</p></li><li><p>read(读取) 作用于主内存的变量，将变量的值从主内存传输到线程的工作内存，以便后面的load操作。</p></li><li><p>load(载入) 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p></li><li><p>use(使用) 作用于工作内存的变量,它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</p></li><li><p>assign(赋值) 作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码执行时执行这个操作。</p></li><li><p>store(存储) 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</p></li><li><p>write(写入) 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</p></li></ul><p><img src="http://cdn.yinchao.tech/JMM%20%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C.png" srcset="/img/loading.gif" alt="JMM 中的具体操作"></p><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ol><li><p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</p></li><li><p>不允许read和load、store和write操作之一单独出现</p></li><li><p>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</p></li><li><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</p></li><li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</p></li><li><p>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</p></li><li><p>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</p></li><li><p>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</p></li><li><p>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</p></li></ol><h2 id="JMM-和-MESI-的区别"><a class="header-anchor" href="#JMM-和-MESI-的区别">⚡</a>JMM 和 MESI 的区别</h2><p>有了MESI，为什么还需要JMM 及 volatile 关键字？</p><ol><li><p>并不是所有的硬件架构都提供了相同的一致性保证，不同的硬件厂商实现不同，JVM需要volatile统一语义。</p></li><li><p>可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型(JMM)中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>concurrent</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 常用指令</title>
    <link href="/2020/4/11/MySQL-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/4/11/MySQL-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><p>修改字段 video 为 utf8mb4 编码</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> slaughter_sheep_info <span class="hljs-keyword">change</span> video video <span class="hljs-built_in">varchar</span>(<span class="hljs-number">250</span>) <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4</code></pre></div>  <a id="more"></a></li><li><p>查看表和字段 DDL 信息</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> slaughter_sheep_info</code></pre></div></li><li><p>修改数据库默认字符集编码</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> Sheep <span class="hljs-keyword">default</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4;</code></pre></div></li><li><p>查看数据库 DDL 信息</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> sheep</code></pre></div></li><li><p>导出</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment"># 表结构</span>mysqldump <span class="hljs-comment">--column-statistics=0 -h(ip) -P(port) -u(username) -p(password) -d (dbName) &gt; (dbName).sql;</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>shellCommand</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识--连接join</title>
    <link href="/2020/4/11/MySQL-%E7%9F%A5%E8%AF%86-%E8%BF%9E%E6%8E%A5join/"/>
    <url>/2020/4/11/MySQL-%E7%9F%A5%E8%AF%86-%E8%BF%9E%E6%8E%A5join/</url>
    
    <content type="html"><![CDATA[<ul><li><p>在 MySQL 中，只有一种 Join 算法，也就是 Nested Loop Join，没有其他很多数据库所提供的Hash Join，也没有Sort Merge Join</p><p>Nested Loop Join 实际上就是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果还有第三个参与Join，则再通过前两个表的Join 结果集作为循环基础数据，再一次通过循环查询条件到第三个表中查询数据，如此往复。</p></li><li><p>Nested Loop Join 就是多个表的for循环,以幂次增长</p><p>例如</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t2 <span class="hljs-keyword">on</span> t1.a = t2.a;<span class="hljs-comment"># 等价的是:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t1,t2 <span class="hljs-keyword">where</span> t1.a = t2.a;</code></pre></div><p>这时会以一个表作为<strong>驱动表</strong>,然后拿到一行记录就做为新的条件去另一个表过滤数据</p><p>类似</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(tt1 in t1)&#123;    <span class="hljs-keyword">if</span>(tt1 is <span class="hljs-keyword">true</span>)&#123;        <span class="hljs-keyword">for</span>(tt2 in t2)&#123;            <span class="hljs-keyword">if</span>(tt2 is <span class="hljs-keyword">true</span> <span class="hljs-keyword">for</span> condition)&#123;                <span class="hljs-keyword">return</span>            &#125;        &#125;    &#125;&#125;</code></pre></div></li><li><p>MySQL 就使用 BNL 算法以及 <code>join buffer</code> 优化:</p><p>BNL (Block Nested Loop Join)算法原理：将外层循环的行/结果集存入 join buffer,内存循环的每一行数据与整个 buffer 中的记录做比较,可以减少内层循环的扫描次数</p><ul><li><p>适用条件</p><p>join buffer 只有当我们的 join 类型为 ALL,index,rang 或者是index_merge 的时候才能够使用</p></li></ul>  <!-- 因为如果是表比较小还好,如果表很大,那么一次性可能不能从磁盘全部把驱动表加载进内存,那么读到一定程度就需要把前面读到的从内存中删掉,然后再从磁盘继续读,这样驱动表就会被读取很多遍,有很大的 IO 开销 --><p>直接嵌套查询效率肯定很低,因为当驱动表得到一条数据之后,就会在被驱动表里面找符合条件的数据,而被驱动表需要从磁盘加载到<strong>内存</strong>才能进行条件匹配</p><p>而每次访问被驱动表,都要进行一次IO,并且在内存中的每一条记录只会和驱动表结果集的一条记录做匹配,之后就会被从内存中清除掉,然后再从驱动表结果集中拿出另一条记录,再一次把被驱动表的记录加载到内存中一遍</p><p>周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了</p><p>MySQL 使用 join buffer 就是这么做的</p><p>它不再是每次从驱动表取出一条数据就在另一个表里面找,而是取出一定大小之后,再一起在另一张表里找,批量查找比单次查找效率高一些</p><blockquote><p>join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 join buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的多条驱动表记录做匹配，，所以这样可以显著减少被驱动表的 I/O 代价</p><p>最好的情况是 join buffer 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。这种加入了 join buffer 的嵌套循环连接算法称之为<strong>基于块的嵌套连接</strong>(Block Nested-Loop Join)算法</p><p>另外需要注意的是，驱动表的记录并不是所有列都会被放到join buffer中，只有查询列表中的列和过滤条件中的列才会被放到join buffer中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样可以在join buffer中放置更多的记录</p></blockquote><p>注意: join buffer 只是通过先查驱动表,在一起放到另一个表的条件里面,如果驱动表还是很多,应该还是会有多次读取驱动表的情况</p><ul><li><p>join 优化总结:</p><ol><li><p>让驱动表得到的数据尽可能的少,减少内层循环次数</p></li><li><p>优化内层循环次数,</p></li><li><p>被驱动表 join 字段加索引(使用 index nested loop join 优化)</p></li><li><p>join buffer,并增大 buffer size</p></li></ol></li></ul></li><li><p>消除外联接</p><blockquote><p>内连接的驱动表和被驱动表的位置可以相互转换，而左连接和右连接的驱动表和被驱动表是固定的。这就导致内连接可能通过优化表的连接顺序来降低整体的查询成本，而外连接却无法优化表的连接顺序</p></blockquote><blockquote><p>外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用子句中的过滤条件的记录，NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--内存溢出和内存泄漏</title>
    <link href="/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>内存溢出(MemoryOverflow)就是你要求分配的内存超出了系统给你的,导致系统无法再给你提供内存资源（内存资源耗尽）</p><a id="more"></a><p>内存泄漏(MemoryLeak)就是申请到了内存空间,但是没有及时清理内存垃圾,或者用到了不属于自己的内存,于是产生泄漏</p><p>例子:</p><ol><li><p>内存溢出则是一个时间点,即申请内存但是申请不到,没有多余的内存分配了</p><p>例如死循环 new 对象,但是又不用 (MemoryLeak),仅仅加入到 list 里面,最后还在继续申请但是已经没有内存空间了,结果发生 OOM (MemoryOverflow)</p></li><li><p>内存泄漏是指一个过程,或者说一段时间</p><p>泄漏是说<strong>程序逻辑问题</strong>,造成申请的内存无法正确释放,或者是你用到了不属于你的内存 (例如数组越界)</p><p>例如:堆栈调用过多,会导致超出虚拟机栈深度,StackOverFlowError,实际上也是一种内存泄漏</p><p>内存溢出是申请的内存空间没有被正确释放,导致后续程序里这块内存被永远占用（<strong>可达但无用</strong>）,这样会造成程序能使用的内存越来越少,内存空间就这么一点点被蚕食,再去申请就会没有多余的内存,会使程序抛出 OOM 异常,导致内存溢出</p><p>溢出是代码编写问题,这样无论多少内存,早晚都会被占用光的</p><p>比喻就是：比如有10张纸，本来一人一张，画完自己擦了还回去，别人可以继续画，现在有个坏蛋要了纸不擦不还，然后还跑了找不到人了，如此就只剩下9张纸给别人用了(泄漏)，这样的人多起来后，最后大家一张纸都没有了。(最终溢出)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--OOM的几种情况</title>
    <link href="/2020/3/31/JVM-%E7%9F%A5%E8%AF%86-OOM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <url>/2020/3/31/JVM-%E7%9F%A5%E8%AF%86-OOM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<ul><li><p>堆</p><ol><li><p>内存<strong>溢出</strong> (MemoryOverflow)</p> <a id="more"></a><p>程序中的确需要很多对象,但是没有多余的空间再放入一个新的对象了</p></li><li><p>内存<strong>泄漏</strong> (Memory Leak)</p><p>大量无用的对象产生导致没有空间了</p><p>使用工具查看泄漏对象到 GC Roots 的引用链,从而定位泄漏代码的位置</p></li></ol></li><li><p>栈</p><ol><li>栈扩容时没有办法申请到足够大的空间 (只有允许动态扩展栈容量的虚拟机上才会发生,HotSpot 不可以)</li></ol><ul><li><p>HotSpot 只有在多线程下,才会出现 OOM,而在单线程下,实际上是 StackOverFlowError</p><p>常见的 StackOverFlowError 是请求的栈深度大于实际的栈空间大小,并且发生错误会有明确的堆栈打印</p><p>而在多线程下,操作系统 os 分配给每个进程的内存是有限制的.对于 JVM,主要把这个内存分配给堆和栈</p><p>而如果在多线程下,栈越大,所占用的内存越多,越容易发生 OOM</p><p>如果是产生了过多的线程而导致 OOM 的异常的,且不能减少线程数或者更换64位虚拟机的情况下,就只能通过减少最大堆和减少栈容量来换取更多的线程</p></li></ul></li><li><p>方法区</p><ol><li><p>大量类信息,造成内存溢出</p></li><li><p>其实还包括运行时常量池的内存溢出</p></li></ol></li><li><p>程序计数器是 JVM 唯一没有定义 OOM 的地方</p></li><li><p>直接内存</p><ol><li><p>直接或间接用到了直接内存的地方 (间接用到常见的有 NIO)</p><p>一个明显的特征是 Heap Dump 文件中不会看见明显的异常</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--垃圾收集器</title>
    <link href="/2020/3/30/JVM-%E7%9F%A5%E8%AF%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2020/3/30/JVM-%E7%9F%A5%E8%AF%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>基于分代收集理论</h1><a id="more"></a><h2 id="新生代收集器-Minor-GC"><a class="header-anchor" href="#新生代收集器-Minor-GC">⚡</a>新生代收集器 (Minor GC)</h2><h3 id="Serial"><a class="header-anchor" href="#Serial">⚡</a>Serial</h3><ol><li><p>标记-复制算法</p></li><li><p>单线程: 不仅仅是只有一条收集线程,更是进行垃圾收集时必须暂停其他工作线程的工作</p></li><li><p>有 “STOP THE WORLD”,降低用户体验</p></li><li><p>优点是: 简单高效,仍然是 HotSpot 虚拟机客户端模式下的默认新生代收集器</p><p>因为它是所有收集器里额外内存消耗最小的,适用于内存资源受限的场景</p><p>由于没用线程交互的开销,可以获得最高的单线程收集效率</p></li><li><p>推荐搭配 Serial Old 使用</p></li></ol><h3 id="ParNew"><a class="header-anchor" href="#ParNew">⚡</a>ParNew</h3><ol><li><p>标记-复制算法</p></li><li><p>ParNew 实质上是 Serial 收集器的多线程版本</p></li><li><p>ParNew 是 HotSpot 虚拟机服务端模式下的默认新生代收集器</p></li><li><p>ParNew 在单线程的环境下绝对不会有比 Serial 收集器更好的效果</p></li><li><p>ParNew 最先退出历史舞台,只能和 CMS 一起使用</p></li></ol><h3 id="Parallel-Scavenge"><a class="header-anchor" href="#Parallel-Scavenge">⚡</a>Parallel Scavenge</h3><ol><li><p>标记-复制算法</p></li><li><p>多线程,能够并行收集</p></li><li><p>特点是保证一个可控的吞吐量<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>,而 CMS 保证的是一个缩短用户线程的停顿时间</p></li><li><p>也被成为&quot;吞吐量优先收集器&quot;</p></li></ol><h2 id="老年代收集器-Major-GC"><a class="header-anchor" href="#老年代收集器-Major-GC">⚡</a>老年代收集器 (Major GC)</h2><h3 id="Serial-Old"><a class="header-anchor" href="#Serial-Old">⚡</a>Serial Old</h3><ol><li><p>标记-<strong>整理</strong>算法</p></li><li><p>单线程</p></li><li><p>默认是 HotSpot 虚拟机客户端模式下默认的老年代收集器</p></li><li><p>如果在服务端下,有两种用途:</p><ol><li><p>JDK 5 以前,与 Parallel Scavenge 搭配使用</p></li><li><p>另一种就是作为 CMS 收集器发生失败时的后备预案,在并发收集时发生 Concurrent Mode Failure 时使用</p></li></ol></li></ol><h3 id="Parallel-Old"><a class="header-anchor" href="#Parallel-Old">⚡</a>Parallel Old</h3><ol><li><p>Parallel Scavenge 的老年代版本</p></li><li><p>标记-整理算法</p></li><li><p>多线程</p></li></ol><h3 id="CMS-Concurrent-Mark-Sweep"><a class="header-anchor" href="#CMS-Concurrent-Mark-Sweep">⚡</a>CMS (<strong>Concurrent Mark Sweep</strong>)</h3><ol><li><p>Old GC, CMS 独有</p></li><li><p>标记-<strong>清除</strong>算法</p></li><li><p>以获取最短回收停顿时间为目标</p></li><li><p>运作过程更复杂</p><ol><li><p>初始标记</p><p>仅仅标记 GC Roots 能够关联到的对象,速度快</p></li><li><p>并发标记</p><p>从 GC Roots 的直接关联对象开始遍历整个对象图,耗时长但是不用停顿用户线程</p></li><li><p>重新标记</p><p>修正并发标记期间,因用户线程继续运作而导致标记变动的一部分对象的标记记录,停顿时间比初始标记时间稍长</p></li><li><p>并发清除</p><p>清理删除掉已经标记死亡的对象</p></li></ol><p>初始标记和重新标记两个过程仍然需要 “Stop The World”</p></li><li><p>缺点:</p><ol><li><p>面向并发的程序对处理器资源比较敏感</p><p>虽然并发阶段不会导致用户线程停顿,但是由于占用了一部分资源,会导致应用程序变慢,降低总吞吐量</p></li><li><p>无法处理&quot;浮动垃圾&quot;</p><p>浮动垃圾是由于在并发清除阶段,用户线程继续产生的垃圾对象,而此次垃圾收集不能回收他们,只能等到下一次再清除</p><p>而且需要留足够的内存空间提供给用户线程使用,因此 CMS 收集器不能像其他收集器那样,等老年代几乎完全满了再进行收集</p><p>如果预留内存无法满足程序分配新对象的需要,有可能出现 “Concurrent Mode Failure” 失败,此时虚拟机就会启动预备方案,临时启用 Serial Old 收集器执行 GC,但这样停顿时间就很长了</p></li><li><p>标记-清除产生的大量空间碎片</p><p>无法找到足够大的连续空间分配大对象,而不得不产生另一次完全 “Stop the World” 的 Full GC</p></li></ol></li></ol><!-- # 不分代垃圾收集 --><h2 id="其他"><a class="header-anchor" href="#其他">⚡</a>其他</h2><h3 id="G1-Garbage-First"><a class="header-anchor" href="#G1-Garbage-First">⚡</a>G1 (Garbage First)</h3><ol><li><p>Mixed GC</p></li><li><p>被 Oracle 称为&quot;全功能的垃圾收集器&quot;</p></li><li><p>不再分代收集,而是面向整个堆的任何部分组成回收集 Set 进行回收,同时也是面向局部收集</p><p>注意,收集范围还是整个堆,但将堆划分为每一个 Region 看做是一个局部,每个 Region 代表不同的代,具体是哪个代是动态的,而不是像以前那样的要么是新生代,要么是老年代,要么是整个堆</p><p>即以前都是什么区域决定什么对象,现在是<strong>对象决定区域</strong></p></li><li><p>是否回收衡量标准不是代数,而是哪块内存的多少,是回收的经验时间,即回收的收益大小</p><p>通过维护这样一个优先级列表,每次回收价值更大的对象</p></li><li><p>每一个 Region 可以扮演, Eden, Survivor, Major 或者 Humongous 区域</p></li><li><p>运作过程</p><ol><li><p>初始标记</p><p>仅仅标记 GC Roots 能直接关联的对象,暂停用户线程,但耗时较短</p></li><li><p>并发标记</p><p>唯一不用暂停用户线程的阶段</p><p>从 GC Roots 开始对堆中的对象进行可达性分析,递归扫描整个对象的对象图</p></li><li><p>最终标记</p><p>短暂暂停用户线程,用于处理并发标记时有引用变动的对象</p></li><li><p>筛选回收</p><p>更新 Region 的统计数据,对各个 Region 的回收价值和成本进行排序</p><p>根据用户期望的停顿时间来制定回收计划,可以把一部分 Region 的存活对象复制到空的 Region 当中,再清理旧 Region</p><p>并且,由于是按照 Region 清理,G1 不会产生内存碎片!</p></li></ol></li><li><p>里程碑:通过追求能够应付应用的内存分配速率</p><p>不追求一次把整个 Java 堆全部清理干净,而只要保证收集的速度能跟得上对象分配的速度就能工作的很完美</p></li><li><p>特点总结:</p><ol><li><p>不分代</p></li><li><p>建立可预测的时间停顿模型,可以指定最大停顿时间</p></li><li><p>分 Region 的布局,不会产生空间碎片</p></li><li><p>按照收益回收的红利</p></li></ol></li><li><p>缺点:</p><ol><li><p>内存占用大</p><p>和 CMS 一样,使用卡表来处理跨区指针,但是比 CMS 更加复杂,占用堆的20%空间甚至更多</p></li><li><p>执行负载</p><p>G1 除了使用写屏障来更新卡表之外,还为了实现原始快照搜索(STAB)算法,用写屏障来跟踪并发时的指针变化情况,导致用户线程在执行阶段有额外的负担</p></li></ol></li></ol><h2 id="低延迟垃圾收集器"><a class="header-anchor" href="#低延迟垃圾收集器">⚡</a>低延迟垃圾收集器</h2><p>几乎整个工作过程都是并发的,只有在初始标记,最终标记阶段有短暂的停顿,且停顿时间基本固定</p><h3 id="Shenandoah"><a class="header-anchor" href="#Shenandoah">⚡</a>Shenandoah</h3><ol><li><p>和 G1 有很多相似的地方</p><p>内存布局 初始标记,并发标记的思路 …</p></li><li><p>G1 就是由于合并了 Shenandoah 的代码才能获得多线程 Full GC 的支持</p><p>G1 修改的代码也会反映到 Shenandoah 上面</p></li><li><p>相比 G1 的改进</p><ol><li><p>G1 的筛选回收阶段是多线程并行但不是并发的,而 Shenandoah 可以</p></li><li><p>默认不使用分代收集</p></li><li><p>G1 中的记忆集变成了连接矩阵的全局数据结构 —— 二维表,减少维护消耗</p></li></ol></li><li><p>运作过程</p><ol><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记</p></li><li><p><strong>并发清理</strong></p><p>清理那些整个 Region 连一个存活对象都没有的</p></li><li><p><strong>并发回收</strong> (核心)</p><p>先把回收集里面的存活对象复制到未被使用的 Region</p><p>但是这个复制对象的过程是在并发时完成的, 就可能会出现一边复制,一边读的问题</p><p>而它是通过读屏障和被称为 Brooks Pointers 的转发指针来解决的</p></li><li><p>初始引用更新</p><p>把所有指向旧对象的引用修正到复制到的新地址</p><p>只是建议一个线程集合点,会产生短暂的暂停</p></li><li><p><strong>并发引用更新</strong></p><p>真正开始引用更新,不再需要沿着对象图进行搜索,只需要按照内存物理地址的顺序,顺序搜索出引用类型</p></li><li><p>最终引用更新</p><p>修正 GC Roots 中的引用</p></li><li><p>并发清理</p><p>经过并发回收和引用更新之后,整个回收集中所有的 Region 已再无存活对象, 最后再调用一次并发清理过程回收 Region 的空间</p></li></ol><ul><li><p>关于 Brooks Pointers</p><p>其实原来的解决方案是设置自陷陷阱,主动触发异常,再进入预设好的异常处理器中,再由代码逻辑吧访问转发到复制后的对象上.但是如果没有操作系统的支持,会导致用户态频繁转到内核态,代价很大</p><p>而在原有对象布局结构的最前面统一增加一个新的引用字段,在不处于并发移动的i情况下,该引用指向自己</p><p>这样,当对象有了一份新的副本时,只需要就对象指针的值,指向新对象.只要就对象的内存依然存在,虚拟机内存中所有通过旧引用地址访问代码便仍然可用,都会被转发到新对象上继续工作</p><ul><li><p>但是请注意,这个设计导致了必然会出现多线程竞争问题</p><p>例如当复制对象完成后,用户修改了旧对象,收集器线程才刚刚更新指针</p><p>所以,对指针转发的操作必须采用同步措施,在统一时间内只能让用户线程或者收集器线程其中之一访问</p></li><li><p>还有一点是执行频率问题</p><p>在面向对象编程的语言中,对象访问是非常重要的,非常频繁的,而 Shenandoah 同时设置读,写屏障,带来了数量庞大的性能开销</p></li></ul></li></ul></li></ol><h3 id="ZGC"><a class="header-anchor" href="#ZGC">⚡</a>ZGC</h3><ol><li><p>染色指针技术,将指针的高四位提取出来存储四个标志信息</p></li><li><p>运作过程</p><p>ZGC 的四个大阶段都是可以并发执行的,仅仅两个阶段中间会有短暂的停顿用户线程</p><ol><li><p>并发标记</p><p>和 G1, Shenandoah 类似,只不过标记是在指针上而不是在对象上进行的</p></li><li><p>并发预备重分配</p><p>根据特定的查询条件统计要清理的 Region, 将这些 Region 重新组成分配集,准备复制到其他的 Region 中</p></li><li><p>并发重分配 (核心)</p><p>把重分配集中的存活对象复制到新的 Region 上,并为重分配集中的每个 Region 维护一个转发表,记录从旧对象到新对象的转发关系</p><p>如果用户线程此时访问了位于重分配集中的对象,这次访问将会被预置的内存屏障所截获,然后立即根据 Region 上的转发表记录,将访问转发到新复制的对象,这种行为成为指针的 “自愈”</p><p>相比 Shenandoah 的转发指针,每次都会有转发的固定开销,ZGC 运行时的负载比 Shenandoah 要低一些</p></li><li><p>并发重映射</p><p>修正整个堆中只想重分配集中旧对象的所有引用,类似 Shenandoah 的并发引用更新</p><p>但是 ZGC 这个任务并不是那么迫切的,因为即使是旧引用,也是可以自愈的,也不过是一次转发和修正</p><p>因此,ZGC 把这个阶段的工作合并到了下一次垃圾收集的并发标记阶段,节省了一次遍历所有对象图的开销</p></li></ol></li></ol><ul><li><p>优点</p><p>由于 ZGC 完全没有记忆集,甚至没有分代,所以给用户线程的运行负担小很多</p></li><li><p>缺点</p><ol><li><p>ZGC 对整个堆回收的速度较慢,但是由于对象的分配速率很高,并且很多朝生夕灭,但是在此时又被当作是存活对象,没有标记回收,导致产生了很多浮动垃圾</p><p>因为较长的回收时间,和高速产生的对象,并且这个过程如果持续维持的话,堆中能够用于腾挪的空间会越来越小</p><p>目前解决办法是尽可能的增加堆的大小,但是要本质上解决,还是必须引入分代收集理论,将对象都在一个专门的区域创建,然后专门对这个区域进行更快,更频繁的收集</p></li></ol></li></ul><h3 id="Epsilon"><a class="header-anchor" href="#Epsilon">⚡</a>Epsilon</h3><p>不能够进行垃圾收集</p><h1>垃圾收集器的范围</h1><ul><li><h2 id="Partial-GC"><a class="header-anchor" href="#Partial-GC">⚡</a>Partial GC</h2><ul><li><h3 id="Minor-GC-Young-GC"><a class="header-anchor" href="#Minor-GC-Young-GC">⚡</a>Minor GC / Young GC</h3><p>仅仅是收集新生代</p></li><li><h3 id="Old-GC-CMS-独有模式"><a class="header-anchor" href="#Old-GC-CMS-独有模式">⚡</a>Old GC (CMS 独有模式)</h3><p>收集老年代</p></li><li><h3 id="Major-GC"><a class="header-anchor" href="#Major-GC">⚡</a>Major GC</h3><p>同 Old GC,收集老年代</p></li><li><h3 id="Mixed-GC-G1-独有模式"><a class="header-anchor" href="#Mixed-GC-G1-独有模式">⚡</a>Mixed GC (G1 独有模式)</h3><p>目标是收集整个新生代和老年代</p></li></ul></li><li><h2 id="Full-GC-Major-GC"><a class="header-anchor" href="#Full-GC-Major-GC">⚡</a>Full GC / Major GC</h2><p>收集整个 Java 堆和方法区</p></li></ul><p>注意:</p><blockquote><p>Major GC 有不同语义,要弄清楚到底是指与 Full GC 同样的整个堆和方法区的收集,还是值与 Old GC 类似的仅仅老年代堆的收集</p></blockquote><h1>并发和并行</h1><ol><li><p>并行 (Parallel): 多条垃圾收集器线程之间的关系,说明同一时间有多条这样的线程在协同工作,通常默认用户线程此时处于等待状态</p></li><li><p>并发 (Concurrent): 描述的是垃圾收集器线程和用户线程之间的关系,说明同一时间垃圾收集器线程和用户线程都在运行,但由于垃圾收集器线程占用了一部分系统资源,应用程序虽然还行响应,但是吞吐量会受到一定影响</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>吞吐量=(运行用户代码时间)/(运行用户代码+_垃圾收集的时间) <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识-硬件内存架构</title>
    <link href="/2020/3/29/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/3/29/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="CPU-工作机制"><a class="header-anchor" href="#CPU-工作机制">⚡</a>CPU 工作机制</h2><p>CPU 速度快,但是数据存放到内存中,而内存相对较慢,所以 CPU 中间加上 cache 多级高速缓存来提升数据读取速度</p><a id="more"></a><p><img src="/img/CPU.png" srcset="/img/loading.gif" alt="CPU"></p><h3 id="cache-缓存工作机制"><a class="header-anchor" href="#cache-缓存工作机制">⚡</a>cache 缓存工作机制</h3><ol><li><p>当 CPU 要去读取一个数据时,会先去缓存中查找,找不到再去内存中找</p></li><li><p>在内存中找到了,同时把这个数据所在的数据快调入缓存中</p><p>即把临近的共64 byte 的数据一同载入,因为临近的数据可能被访问的几率更大,下次就可以直接在缓存中查找数据,这样就增加了缓存的<strong>命中率</strong>(cache hit)了</p></li></ol><h3 id="CPU-缓存一致性问题"><a class="header-anchor" href="#CPU-缓存一致性问题">⚡</a>CPU 缓存一致性问题:</h3><p>如上图所示,cache 之和特定的 CPU 进行通信,多核 CPU 就会出现并发问题: 一个线程在读,另一个在写,导致数据不一致问题</p><ul><li>解决方案:<ol><li><p>总线锁</p><p>使用 CPU 提供的一个 LOCK# 信号,当一个处理器在总线上输入此信号,其他处理器的请求将被阻塞,那么该处理器就可以独占共享锁</p> <span class="label label-danger">todo为什么是共享锁?</span><p>粒度比较大,会降低 CPU 的吞吐量 [1]</p></li><li><p>缓存锁(缓存一致加锁)</p><p>控制锁的粒度,核心是缓存一致协议,不同的 CPU 厂商有不同的实现方式,例如 MESI: 当修改变量时,如果数据是共享变量,会将 cache line 置为无效,所以其他的 CPU 就从内存中读数据,不会再去 cache 中读取数据</p> <!-- <span class="label label-danger">todo解决了可见性,但是无法保证同步?</span> --></li></ol></li></ul><h3 id="线程和硬件架构"><a class="header-anchor" href="#线程和硬件架构">⚡</a>线程和硬件架构</h3><p>进程 -&gt; 线程 -&gt; os 内核线程 -&gt; CPU 线程</p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--JVM 内存区域</title>
    <link href="/2020/3/29/JVM-%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <url>/2020/3/29/JVM-%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-内存区域"><a class="header-anchor" href="#Java-内存区域">⚡</a>Java 内存区域</h2><ol><li>Java 虚拟机在执行 Java 程序的过程中将它所管理的内存区域分成若干个不同的数据区域,称为 Java 内存区域.(<strong>即运行时数据区</strong>)</li></ol><a id="more"></a><ol><li><p>分为五个部分:</p><p><code>程序计数器</code>,<code>虚拟机栈</code>,<code>本地方法栈</code>,<code>Java 堆</code>,<code>方法区</code></p><p>其中前三个是线程隔离的,后两个是线程共享的</p><p>其实还有<code>直接内存</code>是线程共享的,不过直接内存不属于 Java 运行时的内存区域</p></li><li><p>特别的,在 JDK 1.8 之后,原本也被称为永久代的方法区,就不要再称呼为永久代了,因为已经由一个叫做元空间的东西来实现了.</p></li></ol><h3 id="具体的每一个部分"><a class="header-anchor" href="#具体的每一个部分">⚡</a>具体的每一个部分:</h3><ol><li><p>程序计数器</p><p>它占用一小块内存空间,可以看作是当前线程所执行的字节码的行号指示器</p><p>Java 虚拟机的多线程是通过线程轮流切换,分配处理器执行时间的方式来实现的,因此,为了让每条线程切换后都能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,让各个线程的执行不相互影响</p><p><code>字节码解释器</code> 工作时就是通过改变这个计数器来选取下一条需要执行的字节码指令</p><p>JVM 内存区域中唯一一个没有定义 OOM 的区域</p></li><li><p>方法区:</p><ul><li><p>存储: 类信息,常量,static 变量, JIT (Java 即时编译)后的缓存</p></li><li><p>JIT 即时编译</p><p>对象被拆散为标量类型间接地在栈上分配内存</p></li><li><p>JDK 7 以前还叫 永久代, JDK 8 之后就是元空间,其实都是对方法区的实现</p><p>但是注意,元空间实际上不属于虚拟机内存,而是本地内存</p><ol><li><p>为什么改变:</p><ol><li><p>首先是 JDK 8 是 HotSpot 为了融合 JRocket 虚拟机,后者没有永久代</p></li><li><p>永久代经常用空间不够而发生内存溢出(MemoryOverflow),更换成永久代之后,元空间大小之取决于本地内存大小,减少 OOM 的发生</p></li></ol></li></ol></li></ul></li><li><p>Java 堆 (别名 GC 堆)</p><ul><li><p>存储:实例对象</p></li><li><p>具体还可分为:</p><ol><li><p>Eden</p></li><li><p>from survivor</p></li><li><p>to survivor</p><p>GC 发生前, to survivor 区一定是清空的</p><p>GC 时,首先把 Eden 区的对象 复制到 to survivor,对于 from survivor 要进行判断是否达到年龄阈值,如果达到了,就直接复制到老年代,没有则还是复制到 to survivor 区,并且此时对象年龄加一</p><p>如果 to survivor 区满了,那么直接把剩余的对象放入到老年代中</p><p>复制阶段完成后,可以视为 Eden 区 和 from survivor 区全部是死对象,最后 from 和 to 区会调换名字,在下次 GC 时, to 会变成 from</p></li><li><p>old</p></li></ol></li><li><p>对象分配规则</p><ol><li><p>对象优先分配在新生代 Eden 区，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC</p></li><li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）</p><p>这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>长期存活的对象进入老年代</p><p>虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加1，知道达到阀值对象进入老年区。</p><p>注意: JDK 7 可以设置年龄超过15,JDK 8 不可以,暂时不知道原因</p><p>不可以超过15很好理解:</p><p>对象头的 mark word 只设置了4个位来存储年龄信息,2^5-1=15,最多把一个字节用完也只能存到15</p></li><li><p>动态判断对象的年龄</p><p>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p></li><li><p>空间分配担保机制</p><p>每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC，如果小于检查 HandlePromotionFailure 设置，如果 true 那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</p></li><li><p>为什么要进行空间担保？</p><p>是因为新生代采用复制收集算法，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</p></li></ol></li></ul></li><li><p>虚拟机栈区 (内存模型)</p><p>是 Java <strong>方法</strong> 的运行时 <strong>内存模型</strong> Java Memory Model</p><p>因为线程之间的通信是通过 JMM 控制的</p><p>每一个栈帧对应一个方法,每一个方法的调用到执行完成就对应着一个栈帧在虚拟机从入栈到出栈的过程</p><p>栈帧中有: 局部变量表,操作数栈,动态连接,方法出口</p><p>局部变量表包括: <strong>基本数据类型,对象引用(可以是对象起始地址的引用指针,也可能是代表对象的句柄)</strong></p><p>局部变量表所需的内存在<strong>编译期间</strong>完成分配,分配多大空间是完全确定的,运行期间不会改变局部变量表的大小</p><p>注意:</p><blockquote><p>这里我之前不理解为什么是不会在运行时改变局部变量表的大小的,例如在 while- true 的循环里面,一直 new 对象,这个不就是动态增加的吗,数量是不确定的</p><p>然后我发现,new 对象是要显式赋值给一个引用对象的,或者加入到 list 里面,前者对象引用就在局部变量表里面,后者的引用则通过 list 的起始地址或者数组下标可以找到每个对象,实际上还是在局部变量表里面,没有区别</p></blockquote></li><li><p>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</p><ol><li><p>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</p></li><li><p>堆与栈的分离,使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</p></li><li><p>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</p></li><li><p>垃圾回收,</p></li><li><p>面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。</p></li></ol></li><li><p>为什么不把基本类型放堆中呢？</p><p>因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- Spring @Bean 和 @Component</title>
    <link href="/2020/3/21/Spring-%E7%9F%A5%E8%AF%86-Spring-Bean-%E5%92%8C-Component/"/>
    <url>/2020/3/21/Spring-%E7%9F%A5%E8%AF%86-Spring-Bean-%E5%92%8C-Component/</url>
    
    <content type="html"><![CDATA[<h2 id="我的理解"><a class="header-anchor" href="#我的理解">⚡</a>我的理解</h2><p>当学习 Spring 框架的时候,我们会使用 Java configuration + annotation 的方法配置依赖,例如使用 @Component 注解在 Service,dao,mapper 等类, 这样来注册给 IoC 容器,让它来管理这个 Bean 并且自动装配所需要的依赖</p><a id="more"></a><p>但是有个问题,@Component 也是用于 Bean 上,那么 @Bean 注解又是什么呢?</p><p>首先我们要知道 @Bean 在什么情况下会用到:</p><p>对于我们自己手动写的类,可能直接在类上加入 @Component 注解就可以直接让 Spring IoC 容器来管理对象的产生了</p><p>但是,对于需要用到的第三方的组件,这种情况下,除非将它的开源的代码重新整合到项目里面,否则我没有办法在它的 jar 包中的 class 文件反编译后的 Java 文件的类上加入 @Component 注解,但是这种整合源码的方法肯定是不可能的</p><p>而如果不加入 @Component ,我们自己去 new 这个对象也可以,这个时候就需要我们自己去管理这个对象,相当于做了一部分 IoC 容器做到事情,这样还是不太好</p><p>而且,如果这个对象还需要一些依赖,有些依赖甚至还需要从 Spring IoC 容器管理的依赖去取,自己管理的方法就不行了</p><p>也就是说,我们需要自己完成这个第三方对象的创建,但是,虽然创建我只需要 new Class() 就可以了,但是我还需要把这个创建好的对象交给 Spring IoC 容器来管理</p><p>此时,我们就可以在配置类上加上 @Configuration 注解,然后在创建对象的方法上面加上 <code>@Bean</code> 注解 (并且这个方法返回这个对象),这样就把我们手动生成的对象交给 Spring 的 IoC 容器进行管理了,如果这个类还需要依赖,只要你把所需要的依赖作为参数声明到方法上, Spring IoC 容器就可以将依赖自动传给这个方法,进而把依赖注入给这个类</p><hr><h2 id="官方文档"><a class="header-anchor" href="#官方文档">⚡</a>官方文档</h2><blockquote><p>The central artifacts in Spring’s new Java-configuration support are @Configuration-annotated classes and @Bean-annotated methods.</p><p>Spring 的新 Java Configuration支持中的主要构件是 @Configuration 注释的类和 @Bean 注释的方法。</p></blockquote><p>这句话意思是,@Configuration 和 @Bean 是 Spring 的 Java Configuration 编码方式中提供支持的</p><blockquote><p>The @Bean annotation is used to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring’s <beans/> XML configuration, the @Bean annotation plays the same role as the <bean/> element. You can use @Bean-annotated methods with any Spring @Component. However, they are most often used with @Configuration beans.</p><p>@Bean批注用于指示方法实例化，配置和初始化要由Spring IoC容器管理的新对象。对于那些熟悉Spring的<beans /> XML配置的人来说，@ Bean注释与<bean />元素具有相同的作用。您可以将@Bean注释的方法与任何Spring @Component一起使用。但是，它们最常与@Configuration bean一起使用。</p></blockquote><p>这段话是说,@Bean 可以等同于使用 Spring schema 编码方式中的 xml 中的 <code>&lt;bean&gt;</code></p><blockquote><p>Annotating a class with @Configuration indicates that its primary purpose is as a source of bean definitions. Furthermore, @Configuration classes let inter-bean dependencies be defined by calling other @Bean methods in the same class.</p><p>用@Configuration注释类表示该类的主要目的是作为Bean定义的来源。此外，@Configuration类允许通过调用同一类中的其他@Bean方法来定义Bean间的依赖关系。</p></blockquote><h3 id="Full-Configuration-vs-“lite”-Bean-mode"><a class="header-anchor" href="#Full-Configuration-vs-“lite”-Bean-mode">⚡</a>Full @Configuration vs “lite” @Bean mode?</h3><blockquote><p>When @Bean methods are declared within classes that are not annotated with @Configuration, they are referred to as being processed in a “lite” mode. Bean methods declared in a @Component or even in a plain old class are considered to be “lite”, with a different primary purpose of the containing class and a @Bean method being a sort of bonus there. For example, service components may expose management views to the container through an additional @Bean method on each applicable component class. In such scenarios, @Bean methods are a general-purpose factory method mechanism.</p><p>如果在未使用@Configuration注释的类中声明@Bean方法，则将它们称为以“精简”模式进行处理。在@Component或甚至在 POJO 中声明的Bean方法被认为是“精简版”，其中包含类具有不同的主要用途，而@Bean方法在那里具有一定的优势。例如，Service 组件中可以通过每个适用组件类上的其他@Bean方法将管理视图公开给容器。在这种情况下，@ Bean方法是一种通用的<strong>工厂方法</strong>机制。</p></blockquote><blockquote><p>Unlike full @Configuration, lite @Bean methods cannot declare inter-bean dependencies. Instead, they operate on their containing component’s internal state and, optionally, on arguments that they may declare. Such a @Bean method should therefore not invoke other @Bean methods. Each such method is literally only a factory method for a particular bean reference, without any special runtime semantics. The positive side-effect here is that no CGLIB subclassing has to be applied at runtime, so there are no limitations in terms of class design (that is, the containing class may be final and so forth).</p><p>与完整的@Configuration不同，lite @Bean方法无法声明Bean之间的依赖关系。取而代之的是，它们在其包含组件的内部状态上进行操作，并且还可以根据可能声明的自变量进行操作。因此，一个@Bean方法不应调用其他@Bean方法。每个此类方法实际上只是针对特定bean引用的工厂方法，而没有任何特殊的运行时语义。这里的积极副作用是，不必在运行时应用CGLIB子类，因此在类设计方面没有任何限制（即，包含类可以是最终类，依此类推）。</p></blockquote><blockquote><p>In common scenarios, @Bean methods are to be declared within @Configuration classes, ensuring that “full” mode is always used and that cross-method references therefore get redirected to the container’s lifecycle management. This prevents the same @Bean method from accidentally being invoked through a regular Java call, which helps to reduce subtle bugs that can be hard to track down when operating in “lite” mode.</p><p>在常见情况下，@ Bean方法将在@Configuration类中声明，以确保始终使用“完全”模式，因此跨方法引用将重定向到容器的生命周期管理。这样可以防止通过常规Java调用意外地调用同一@Bean方法，这有助于减少在“精简”模式下运行时难以跟踪的细微错误。</p></blockquote><h2 id="Bean-使用"><a class="header-anchor" href="#Bean-使用">⚡</a>@Bean 使用</h2><blockquote><p>You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.</p><p>你可以在 <strong><code>@Configuration</code></strong> 注释的类或 <strong><code>@Component</code></strong> 注释的类中使用@Bean注释。</p></blockquote><p>例如</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferServiceImpl <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();    &#125;&#125;</code></pre></div><blockquote><p>However, this limits the visibility for advance type prediction to the specified interface type (TransferService). Then, with the full type (TransferServiceImpl) known to the container only once, the affected singleton bean has been instantiated. Non-lazy singleton beans get instantiated according to their declaration order, so you may see different type matching results depending on when another component tries to match by a non-declared type (such as @Autowired TransferServiceImpl, which resolves only once the transferService bean has been instantiated).</p><p>但是，这将高级类型推断的功能的可见性限制为指定的接口类型（TransferService）。然后，仅使容器明白完整类型（TransferServiceImpl）一次，就可以实例化受影响的单例bean。非懒惰单例bean根据其声明顺序实例化，<strong>因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试通过未声明的类型进行匹配</strong>（例如@Autowired TransferServiceImpl，仅当transferService bean具有被实例化）。</p></blockquote><blockquote><p>If you consistently refer to your types by a declared service interface, your @Bean return types may safely join that design decision. However, for components that implement several interfaces or for components potentially referred to by their implementation type, it is safer to declare the most specific return type possible (at least as specific as required by the injection points that refer to your bean).</p><p>如果您通过声明的服务接口一致地引用同一类型，则@Bean返回类型可以安全地加入该设计决策。但是，<strong>对于实现多个接口的组件</strong>或由其实现类型潜在引用的组件，声明可能的<strong>最具体的返回类型</strong>（至少与引用您的bean的注入点所要求的具体类型一样）更为安全。</p></blockquote><blockquote><p>A @Bean-annotated method can have an arbitrary number of parameters that describe the dependencies required to build that bean. For instance, if our TransferService requires an AccountRepository, we can materialize that dependency with a method parameter, as the following example shows:</p><p>@Bean注释的方法可以具有任意数量的参数，这些参数描述构建该bean所需的依赖关系。例如，如果我们的TransferService需要一个AccountRepository，则可以使用方法参数来实现该依赖关系，如以下示例所示：</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">(AccountRepository accountRepository)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(accountRepository);    &#125;&#125;</code></pre></div><h2 id="Configuration-的使用"><a class="header-anchor" href="#Configuration-的使用">⚡</a>@Configuration 的使用</h2><blockquote><p>@Configuration is a class-level annotation indicating that an object is a source of bean definitions. @Configuration classes declare beans through public @Bean annotated methods. Calls to @Bean methods on @Configuration classes can also be used to define inter-bean dependencies.</p><p>@Configuration是类级别的注释，指示对象是Bean定义的源。@Configuration类通过公共@Bean注释方法声明bean。对@Configuration类的@Bean方法的调用也可以用于定义Bean之间的依赖关系。</p></blockquote><blockquote><p>This method of declaring inter-bean dependencies works only when the @Bean method is declared within a @Configuration class. You cannot declare inter-bean dependencies by using plain @Component classes.</p><p>仅当在@Configuration类中声明@Bean方法时，此声明bean间依赖性的方法才有效。您不能使用普通的@Component类声明Bean间的依赖关系。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据源和数据连接池</title>
    <link href="/2020/3/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/2020/3/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="数据源"><a class="header-anchor" href="#数据源">⚡</a>数据源:</h2><a id="more"></a><p>简单理解为数据源头，提供了应用程序所需要数据的位置。它是连接到实际数据库的一条路径而已，数据源中并无真正的数据，它仅仅记录的是你连接到哪个数据库，以及如何连接的</p><p>数据源保证了应用程序与目标数据之间交互的规范和协议，目标数据的存储可以是数据库，文件系统等等。</p><p>数据源定义了位置信息，用户验证信息和交互时所需的一些特性的配置，同时它封装了如何建立与数据源的连接，向外暴露获取连接的接口。</p><p>应用程序连接数据库无需关注其底层是如何如何建立的，也就是说应用业务逻辑与连接数据库操作是松耦合的。</p><p>数据源大致分为2种：不提供数据连接池和提供数据连接池管理。</p><h2 id="数据连接池"><a class="header-anchor" href="#数据连接池">⚡</a>数据连接池</h2><ul><li><p>JDBC操作的步骤：</p><ol><li><p>加载驱动程序</p></li><li><p>连接数据库</p></li><li><p>操作数据库</p></li><li><p>关闭数据库，释放连接</p></li></ol><p>但是当与数据库交互频繁时，这种模式会严重影响程序的性能。时间和空间消耗大多数消耗在连接和销毁中，而非数据库处理。</p><p>Spring 默认的 <code>Spring-jdbc</code> 的 DriverManagerDataSource 就是不提供连接池的,该数据源对于应用程序的每一个连接请求都建立新的连接，当应用程序使用完毕后，再执行销毁操作。</p></li><li><p>使用数据库连接池</p><p>数据库连接是负责分配、管理和释放数据库连接。数据库连接池里专门保存着全部的数据库连接，以后用户用数据库操作的时候不用再重新加载驱动、连接数据库之类的，而直接从此空间中取走连接，关闭的时候直接把连接放回到此空间之中。</p><p>Spring Boot 是采用 HikariCP 来作为默认的数据源。</p></li></ul><h2 id="Spring-中的常用数据访问技术"><a class="header-anchor" href="#Spring-中的常用数据访问技术">⚡</a>Spring 中的常用数据访问技术</h2><ol><li><p>JDBC</p><p>Java数据库连接，（Java Database Connectivity，简称 JDBC ）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序<strong>接口</strong>，用于在 Java 语言编程中与数据库连接的 API</p><p>也就是说,JDBC是一个规范，它提供了一整套接口( 是 API 而不是 interface ,但是只是低级 API 或者叫底层 API,因为它直接调用 SQL 命令 ,其他有各自封装好 JDBC 的高级 API, 例如 JDBI)，允许以一种可移植的访问底层数据库 API。使用 JDBC 驱动程序来访问数据库，并用于存储数据到数据库中.</p></li><li><p>Spring Data JPA</p><p>Spring Data JPA 基于 Hibernate，而 Hibernate 是一个让人又爱又恨的技术。</p><p>同原生 JDBC 相比，Hibernate 极大地简化了开发工作量；但另一方面，因为 Dirty Check、延迟加载、各种如 ManyToOne 等映射规则，又让 Hibernate 成为了一个复杂技术。而这些复杂性，平时很少直接用到，但是却增加了 Hibernate 的开发和调试难度。</p></li><li><p>Spring Data JDBC</p><p>Spring Data JDBC 的目的是为了给基于 JDBC 的数据库应用提供 Repository 封装。</p><blockquote><p>简单说，就是为了让大家用到类似于 Spring Data JPA 中 JpaRepository 的功能，但是不引入任何ORM框架。</p></blockquote><p>也就是我们经常在代码里看到 JDBCTemplate 这个辅助类进行开发</p></li><li><p>MyBatis</p><p>和 Hibernate 一样是第三方 ORM 数据库框架。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。</p><p>注意:</p><blockquote><p>Hibernate是全自动ORM框架，而Mybatis是半自动的。hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- Spring IOC 的应用</title>
    <link href="/2020/3/17/Spring-%E7%9F%A5%E8%AF%86-Spring-IOC-%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/3/17/Spring-%E7%9F%A5%E8%AF%86-Spring-IOC-%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Spring 实现IoC的思路和方法</p> <a id="more"></a><ol><li><p>Spring 实现 IoC 是通过配置信息来描述类与类之间的配置关系,然后由去解析这些配置信息</p><p>步骤:</p><ol><li><p>应用程序中提供类和依赖对象</p></li><li><p>通过配置,把所有需要用到的类交给容器 (schema,annotation,Java configuration)</p></li><li><p>再描述一遍类和依赖对象的关系</p></li></ol></li></ol></li><li><p>Spring IoC 使用例子:</p><ol><li><p>方式一: schema</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 声明类 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexDaoImpl"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 声明类 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"service"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexService"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 声明依赖对象 --&gt;</span>        <span class="hljs-comment">&lt;!-- 方法一: 基于 setter 方法,** name 和属性名无关,只和 setter 方法名有关** --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dao"</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- 方法二: 基于构造函数 --&gt;</span>        <span class="hljs-comment">&lt;!-- &lt;constructor-arg ref="dao"/&gt;--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>但是请注意,这里有一个很坑的点,或者说我基础不扎实的地方:</p><blockquote><p>当使用方法一的时候,不要写任何构造器,因为如果不写还好,JVM 可以自动给你生成默认的空构造方法</p><p>但是如果写了带依赖参数的构造器,那么 JVM 将不会为你生成默认的空构造方法,这样使用 setter 注入会报错 <code>No default constructor found</code></p><p>所以要么就不写带参数的构造方法(不和 <code>构造函数注入</code> 混用),要么,就再写上无参构造函数</p></blockquote> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 在主函数里面使用 ClassPathXmlApplicationContext 传入这个 xml 配置文件</span>ClassPathXmlApplicationContext classPathXmlApplicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:spring.xml"</span>);<span class="hljs-comment">// getBean 的参数是 service,和类名其实无关,之和 xml 的 id 有关</span>Service Service = (IndexService) classPathXmlApplicationContext.getBean(<span class="hljs-string">"service"</span>);service.test();</code></pre></div></li><li><p>方式二: annotation ( 与 schema 或者 Java Configuration 集成)</p><ol><li><p>方法一:annotation + schema</p><ol><li><p>首先需要开启 Spring 对注解的支持:</p><p>在 xml 里面写上 <code>&lt;context:component-scan base-package=&quot;ind.yinchao.ioc.test1&quot;/&gt;</code></p><p>这样离不开 xml,不太好</p></li></ol></li><li><p>方法二:annotation + Java Configuration 更改主函数的 Context (已经体现 <strong><code>自动装配</code></strong>)</p><p>新建 Java 配置文件</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// @configuration 就是生命这是代替 xml 的配置文件</span><span class="hljs-meta">@Configuration</span>()<span class="hljs-comment">// @componentScan 开启扫描</span><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"ind.yinchao.ioc.test2"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span></span>&#123;&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs java">AnnotationConfigApplicationContext annotationConfigApplicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre></div></li></ol><p>然后就可以使用注解了</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//声明类</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-comment">// 声明依赖关系</span>    <span class="hljs-meta">@Autowired</span>    Dao dao;&#125;&lt;!-- 声明类 --&gt;<span class="hljs-meta">@Component</span>(<span class="hljs-string">"dao"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DaoImpl</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"daoImpl1);</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;</span></code></pre></div></li><li><p>方式三: schema + annotation + Java Configuration 混合使用</p><p>在 Java Configuration + annotation 的基础上,在 Java 配置文件类 SpringConfiguration 中加上 <code>@ImportResource(&quot;SpringConfiguration.xml&quot;)</code> 以启用 schema</p></li><li><p>使用 <strong>schema</strong> 的问题:</p><p>如果我们类与类之间有了依赖关系,那么为什么还要在声明类的配置中来再描述一遍依赖对象呢?这样不就冗余了吗</p><p>解决:</p><p>使用 Spring 的 <strong>自动装配</strong> 完成上面的第三步,不需要在第二步完成类的描述之后再去进行冗余的类与依赖对象的描述</p><p>在 xml 配置文件的头部最后加上 <code>default-autowired = &quot;no|byType|byName|construct&quot;</code>,分别对应:</p><ol><li><p>no|default: 不自动装配</p></li><li><p>byType: 自动属性注入</p><p>需要 set 方法</p><p>type: 依赖属性的类型</p></li><li><p>byName 自动名字注入:</p><p>需要 set 方法</p><p>name: set方法按一定规律的名字</p><p>例如 setTest ,那么 xml 中对应的依赖类 id 就为 test</p></li><li><p>自动通过构造方法注入:需要带参构造方法</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在主程序的配置入口处配置 最后加上 default-autowired="byType"--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexDaoImpl"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"service"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexService"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dao"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li></ol></li><li><p>使用 annotation + Java Configuration 的问题 (schema 也类似,就不再举例)</p><p>实现类有两个:</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"dao2.1"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexDaoImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IndexDao</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"impl2.1"</span>);    &#125;&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"dao2.2"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexDaoImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IndexDao</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"impl2.2"</span>);    &#125;&#125;</code></pre></div><p>这时如果在 Service 类里面继续写依赖就会报错</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-meta">@Autowired</span>    IndexDao dao&#125;</code></pre></div><blockquote><p>No qualifying bean of type ‘test2.IndexDao’ available: expected single matching bean but found 2: dao2.1,dao2.2</p></blockquote><p>因为 @Autowired 默认是根据 byType 查找,这里出现了两个 IndexDao 的实现,那么就有两个相同的类型,就会出错</p><p>解决:</p><ol><li><p>方法一: @Autowired 是先根据 byType 如果没有找到,会使用 byName</p><p>这样,那我们只需要修改 Service 里面的依赖变量名 dao -&gt; indexDaoImpl1,这样就可以找到 IndexDaoImpl1 这个类了</p><p>注意,和 setter 方法无关</p></li><li><p>使用 @Resource 是根据 byName 查找的,解决方式同上</p></li><li><p>虽然还是使用 @Resource ,这里我们还可以使用 @Qualifier 指定 Bean 的名字</p></li></ol></li><li><p>作用域 Scope</p><p>一个很坑的点: singleton bean 需要 prototype bean 的时候, 被依赖的 prototype bean 可能只会初始化一次,那么 prototype 就失效了</p><p>解决</p><ol><li><p>implement ApplicationContextAware</p><p>需要用到 Spring 的 API 侵入性很强</p></li><li><p>通过 @Lookup(“indexDaoImpl1”)注解</p><p>@Lookup 写在一个 abstract 方法上,并返回依赖</p><p>再将这个类设置为 abstract</p><p>这个类就不需要 @Autowired 或者 @Resource 注解了,直接在外部调用 Service 的方法里面再调用那个 abstract 方法即可</p><p>@Lookup(“indexDaoImpl1”),可以通过指定 bean 来防止有多个同类型的 type</p><p>@Lookup() 实际上是<strong>依赖查找 DL</strong>!</p></li></ol></li><li><p>Bean 生命周期的<strong>回调</strong> (lifecycle callback)</p><p>创建 Bean 时的回调 (销毁时同理)</p><ol><li><p>方式一: 实现 InitializingBean 接口,重写 afterPropertiesSet 方法</p></li><li><p>方法二: 对于基于 xml 的情况,可以在 bean 标签里加上</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">default-init-method</span>=<span class="hljs-string">"init"</span>&gt;</span></code></pre></div><p>并指定方法名</p></li><li><p>方法三: 在方法上写一个注解 @PostConstruct</p></li></ol></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK(7和8) 源码搭建</title>
    <link href="/2020/3/11/%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95-JDK(7%E5%92%8C8)%20%E6%BA%90%E7%A0%81%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/3/11/%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95-JDK(7%E5%92%8C8)%20%E6%BA%90%E7%A0%81%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="方法一"><a class="header-anchor" href="#方法一">⚡</a>方法一:</h2><p><a href="https://blog.csdn.net/getyouwant/article/details/50428753" target="_blank" rel="noopener">能够用的方法,这样直接修改了源文件,感觉不太好</a></p><a id="more"></a><h2 id="方法二"><a class="header-anchor" href="#方法二">⚡</a>方法二:</h2><ol><li><p>首先去官网下载对应系统版本的 JDK7 和 JDK8</p><p>(因为 JDK 不同版本的实现可能不一样,例如 HashMap 的底层实现由链表改成红黑树,所以下两个版本更保险)</p><p><strong>注意一个很坑的地方:</strong></p><blockquote><p>不要下 Open JDK,之前下载了 OpenJDK7的源码,编译一直报错,但是去官网下载的 OracleJDK8 则没有问题!</p></blockquote></li><li><p>下好后解压,源文件路径在</p><blockquote><p>JDK 根目录(例如:/opt/jdk-8u212-linux-x64/jdk1.8.0_212/src.zip) 的 src.zip 解压后的文件</p></blockquote></li><li><p>IDEA 下创建 maven 项目</p><ol><li><p>创建好项目后,再创建两个 module: jdk7 和 jdk8,分别对应 jdk 的两个版本,对应的 language level 分别设定7和8</p><p>注意:</p><p>新建 module 的父 module 不能为空,一定要是原来的项目 module</p></li><li><p>把下好的源码包完整复制到对应 module 的src文件中,并且在 project structure 里面标记 src 文件夹为 source</p></li></ol></li><li><p>整合依赖</p><ol><li><p>打开 project structure, 找到最左边的 Libraries, 点击 + ,添加一个 新的 Project Library, 找到 jdk7 这个 module 的 src 文件夹,添加</p><p>jdk8 module 同理</p></li><li><p>Modules 侧边栏中， 选择 jdk7 module 上方的 dependencies, 在点击右侧的 + 号,添加 module dependency 可以看到之前添加的 Libraries jdk7,点击添加</p><p>jdk8 module 同理</p></li><li><p><strong>第二坑的环节是这个:</strong> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>上一步 Libraries 添加好对应的 module 后,还必须将后添加的 Library 的顺序排到原来 module JDK 的前面,否则点击对应的类,还是使用 JDK 的字节码反编译后的文件</p></li><li><p>要注意版本,要在每个 module的 pom.xml 文件里面指定 Java 版本(complier version 和 target version)</p><p>例如:</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre></div><p>运行时的环境要比较低,用1.7即可,而 各自 module 的版本可以自由设置更高一些的版本</p></li></ol></li><li><p>各自的模块编译一段时间没有报错后,就可以愉快的查看对应类的 .java 文件,而非字节码反编译的只读文件,还可以直接在源码上写注释啦!</p></li><li><p>如果想要测试,就可以直接在对应 JDK 的版本的 module 中写测试样例</p></li><li><p>如果想要 debug 那么就要在 settings --&gt; debug --&gt; Stepping --&gt; Do not step into the classes 下 , 把 Java.* 取消勾选</p><p>之后打上断点就可以看看 JDK 程序是如何一步步跳转调用的了</p><p>如果 debug 进入到了 URLClassLoader 里面,就去下方的 BreakPoints,把 Java Exception BreakPoints 取消勾选</p><p>如果有一些通用性的类不想进入,例如 Object,可在 settings 的 Do not step into the classes 中加入相关的类</p><p>但是需要注意:<br>如果要写注释,尽量不要增加行,否则调试的位置就会和本来的位置不一致</p><p>还以为可能是 JVM 去掉了注释的原因?但是源代码也有自己的注释,debug 时不会出问题</p><p>可以确认是由于类加载子系统的双亲委派模型的原因,导致即使在编辑器可以设定更改指向文件,但是对于 JVM 来说,只要你没有打破双亲委派模型,虚拟机就不会去加载你项目中的同名类</p><p>ps: 这里可以算得上是 JVM 知识在实际应用中的点,以后有空了可以试着打破双亲委派机制,也是一个亮点</p></li></ol><hr><p>开源项目:</p><ol><li><p>(<a href="https://github.com/kangjianwei/LearningJDK#start-of-content" target="_blank" rel="noopener">https://github.com/kangjianwei/LearningJDK#start-of-content</a>)</p></li><li><p>(<a href="https://github.com/raysonfang/jdk1.8-source-analysis" target="_blank" rel="noopener">https://github.com/raysonfang/jdk1.8-source-analysis</a>)</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/klordy_123/article/details/82915450" target="_blank" rel="noopener">参考博客</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- IOC、DIP、DI</title>
    <link href="/2020/3/10/Spring-%E7%9F%A5%E8%AF%86-IOC%E3%80%81DIP%E3%80%81DI/"/>
    <url>/2020/3/10/Spring-%E7%9F%A5%E8%AF%86-IOC%E3%80%81DIP%E3%80%81DI/</url>
    
    <content type="html"><![CDATA[<h2 id="控制反转-IOC-Inversion-of-Control"><a class="header-anchor" href="#控制反转-IOC-Inversion-of-Control">⚡</a>控制反转 IOC (Inversion of Control )</h2><ol><li><p><span id="IOC">IoC </span>是面向对象编程中的一种<strong>设计思想</strong>,用于降低代码的耦合度,可以说是一种目的,一个目标</p></li><li><p>IoC 是原则和目标,而具体<strong>实现的方式</strong>有多种,其中最常见的就是依赖注入 (DI) (dependency Injection),其他的方式还有依赖查找 (DP) ( dependency Lookup)和依赖拖拽等</p> <!-- more --></li><li><p>实现 IoC 的地方,我们可以称为 IoC 容器</p></li><li><p><span id="dependency">什么是依赖?</span></p><p>依赖是面向对象编程中的一个概念,因为是面向对象编程,一个类 A 可能要用到其它的类 B 的属性或者方法,那么就说 A 依赖 B</p></li><li><p>什么是控制反转?</p><p>如果 A 依赖 B,那么一般来说,我们要么需要在类 A 中显式使用 new 关键字来创建类 B 的对象</p><p>而使用 IoC,我们只需要声明一下我们需要用到哪些对象,不需要显式的通过 new 来生成依赖对象,反而把对象的创建交给一个 IoC 容器处理和<strong>管理</strong></p><ul><li><p>其控制就是指:创建依赖对象</p></li><li><p>反转就是指: 类 A 需要创建依赖对象 B,但是在类 A 里面不显式创建,而是把创建过程交给第三方,第三方创建好之后,在自动传给我(依赖注入,DI),或者我自己去找(依赖查找,dependency lookup,DL),即<strong>反转创建依赖对象这个过程</strong></p></li></ul></li><li><p>为什么要使用 IoC</p><ol><li><p>最主要原因:面向对象编程时,需要频繁的创建对象,而手动创建管理对象可能会出现问题</p><p>例如:ServiceA 依赖 ServiceB,ServiceB 依赖 ServiceC,而 ServiceC 则同时依赖 ServiceA 和 ServiceB</p><ol><li><p>考虑循环依赖的问题(Spring 解决循环依赖的方案是三级缓存)</p><p>如果我们考虑可能的循环依赖的问题直接new 对象可能会出问题,因为 ServiceB 依赖的对象 ServiceC 没有创建,这样我们就没法直接在 ServiceA 里面写 <code>new ServiceB()</code>,当然 new 其他 Service 同理,这样程序肯定会报错</p><p>那么如果我们不再类内部创建对象,而是通过<strong>构造函数</strong>,<strong>接口</strong>或者 <strong>setter 方法</strong>传入依赖对象,这样的可以在一定程度上避免在内部创建依赖对象的问题,把这三个对象的创建由其他用于管理的类执行,这样可能可行,但是非常麻烦,因为每一个对象我们都需要来手动管理,然后自己控制赋给相应的对象</p><p>并且,更重要的是,如果你这么做了,<strong>实际上就是实现了 IoC</strong>,而且是使用 DI 的方式:把依赖的创建权交给了第三方的类,而这个第三方的实现类就是 IoC 容器</p><p>不过,这个是你自己手动实现的,而 Spring 的 IoC 容器已经为我们实现了这个,那么我们直接使用即可</p></li><li><p>就算不考虑循环依赖,但是如果创建类之后有一些通用性的配置,每次要自己实现很麻烦</p><p>比如我想要在 Service 里实现事务,那么我就要在里面的每个方法里面自己实现,而业务代码里面充斥着这种模板性的代码就很不好,可读性和维护性都很差</p><p>而如果交给 IoC 容器,你可以通过一些标识(例如注解 @Transactional)告诉容器,容器在创建每一个对象的时候,就可以自己进行相关控制,有的需要加上事务或者是其他的配置,它就可以自动的加上</p></li></ol></li></ol></li><li><p>总结 IoC 的好处(统一管理,体现了<strong>自动装配</strong>)</p><ol><li><p>最重要的就是可以不用程序员手动创建对象,而是把对象的创建和相关管理交给 IoC 容器,IoC 容器自动给你组装好,使程序员可以专注于业务逻辑</p><p>上层无需知道下层的创建过程,将创建细节隐藏,降低了对象之间的耦合度,程序员不需要知道依赖对象如何创建的,将多余的创建对象的责任交给容器,增加了灵活性</p></li><li><p>将一些通用性的配置代码交给 IoC 容器统一配置,程序员不需要考虑与业务无关的东西,简化开发,IOC 容器自动给你配置好</p></li><li><p>IoC 容器容易控制实现单例模式,节省空间,效率高</p></li><li><p>方便单元测试 mock</p></li><li><p>…</p></li></ol></li></ol><h2 id="依赖倒置原则-DIP-Dependence-Inversion-Principle"><a class="header-anchor" href="#依赖倒置原则-DIP-Dependence-Inversion-Principle">⚡</a>依赖倒置原则 DIP (Dependence Inversion Principle)</h2><ol><li><p>依赖可能产生的问题</p><p>如果类 A 里面有一个属性是类 B,这样 A 直接依赖 B 会因为耦合过高产生一些问题,比如扩展性不好,牵一发而动全身等等</p><ol><li><p>例子</p><p>例如我之前用 Java 写过的一个 <a href="https://github.com/YME86/JShell" target="_blank" rel="noopener">JShell Demo</a>,最开始我在主函数里面对用户输入的指令进行一个个 if-else 判断,再去创建对应的类来调用函数来实现相应的功能</p> <div class="hljs"><pre><code class="hljs java">...<span class="hljs-keyword">if</span>(<span class="hljs-string">"cd"</span>.equals(str))&#123;    Cd.apply(input);    <span class="hljs-comment">// 对于依赖是非静态的方法或者属性</span>    Cd cd = <span class="hljs-keyword">new</span> Cd(string);    cd.apply(input);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"exit"</span>.equals(str))&#123;    Exit.apply(input);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ...</code></pre></div><p>这样的代码耦合度就很大,因为功能的实现完全依赖其他的实现类,而主函数就需要对那些依赖类进行创建和管理</p><p>如果要增加新的指令,那么就必须修改主函数增加对命令的 if-else 判断,以此创建新的类,这样非常麻烦,扩展性不好</p></li></ol></li><li><p><span id="DIP">DIP: 是设计模式的一个原则,体现的是<strong>面向接口编程的思想</strong></span></p><ol><li><p>例子</p><p>第二次改良我就写了一个接口,所有不同具体的功能类就得去实现这个接口,需要根据字符串生成不同的类不是通过 if-else 判断,而是通过反射实例化对象</p><p>而这样的好处是,我在主函数里面调用接口的方法即可,不需要关心到底是哪一个具体实现类实现了这个接口,因为无论是哪个具体实现类,我们都是要调用那个接口的方法,这样就在主函数里面消除了冗余的 if-else 语句,同时使代码变得更有扩展性,也更加能够维护.</p><p>这样,主函数<strong>不依赖具体实现</strong>而是<strong>依赖接口</strong>,而具体实现类又通过自己的具体实现去<strong>依赖抽象接口</strong>,这样就实现了<strong>依赖倒置原则 DIP</strong></p></li></ol></li></ol><p>下面这段话摘自 Wikipedia: <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><blockquote><p>With the addition of an abstract layer, both high- and lower-level layers reduce the traditional dependencies from top to bottom<br>Nevertheless, the “inversion” concept does not mean that lower-level layers depend on higher-level layers<br>Both layers should depend on abstractions that draw the behavior needed by higher-level layers.</p><p>通过添加抽象层，高层和较低层都从上到下减少了传统的依赖关系。<br>但是，“反转”概念并不意味着较低层依赖于较高层。<br>这两层都应<strong>依赖于抽象</strong>，这些抽象描述出更高层所需要的行为</p></blockquote><ol><li><p>IoC 和 DIP 的关系</p><p>IoC 和 DIP 有关，但与之不同，后者涉及通过共享抽象来解耦高层和低层之间的依赖关系。</p><p>IoC 体现的是</p><ol><li><p>类及其依赖的<strong>产生</strong>通过容器统一管理并分发,是为了简化开发,实现 IoC 是通过 DI 或者 DL 之类的技术</p></li><li><p>而 DIP 是一种经验,体现面向抽象(接口)编程的一种思想</p><p>说白了,我认为,虽然 IoC 只关心类的生命周期,但是实现比较难,而且不用 IoC 框架就得自己实现,来解决类与类之前的关系</p><p>DIP 则不同,不实现 DIP 程序也能使用,但是扩展性和维护性很差,而实现了 DIP,程序可能就很优雅,增强了扩展性和可维护性</p></li></ol></li></ol><h2 id="依赖注入-DI-Dependence-Injection"><a class="header-anchor" href="#依赖注入-DI-Dependence-Injection">⚡</a>依赖注入 DI ( Dependence Injection)</h2><ol><li><p>在 Spring Framework 的 IoC 容器中，配置有三种:xml、annotation 以及 Java config.通过 IoC 容器的控制,把对象的从生成到销毁全部管理起来,再通过依赖注入 DI 的方式将生成的对象提供给所需的类</p></li><li><p>可以说依赖是问题,而注入则是解决方案,同理还有依赖查找和依赖拖拽</p></li><li><p>依赖注入如何实现</p><p>IoC 容器创建好对象后,</p><ol><li><p>通过构造函数传入对象</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    B b;    A(B b)&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre></div></li><li><p>通过 setter 方法传入对象</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    B b;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre></div></li><li><p>通过实现接口</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceName</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">implement</span> <span class="hljs-title">InterfaceName</span></span>&#123;    B b;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre></div><p>前两个可能好理解,但是第三个感觉可能有些鸡肋?</p><p>其实使用接口则是声明了一种依赖的能力,也是可以使用的,只不过 Spring 没有提供</p></li></ol></li><li><p>依赖注入和依赖查找的区别:</p><ol><li>依赖注入只是被动接收,而依赖查找则是需要自己主动去找</li></ol></li></ol><hr><p>总结:</p><ol><li><p>术语:</p><ol><li><p><a href="#dependency">依赖(dependencies)</a>:是面向对象编程中的一个概念,因为是面向对象编程,一个类 A 可能要用到其它的类 B,那么就说 A 依赖 B.</p></li><li><p><a href="#IOC">控制反转(Inversion of Control,简称 IoC)</a>:为了解偶,将依赖对象的创建交给一个特定的容器(实现了 IoC 的类)来管理对象的生命周期,而不由程序本身实现;是一种设计思想</p></li><li><p><a href="#DIP">依赖倒置原则(Dependencies Inversion Principle,简称 DIP)</a>:是设计模式的一个原则,体现的是<strong>面向接口编程的思想</strong></p></li><li><p><a href="#DI">依赖注入(Dependencies Injection,简称 DI)</a></p></li><li><p>上面好像各种实现方式都说有构造函数,setter 方法,接口,这个实际上就是<strong>传递依赖的三种方式</strong>,而无论是 DI、DIP、IoC,实际上解决的就是依赖的问题</p></li></ol></li></ol><hr><p>参考文献:</p><ol><li><p><a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" rel="noopener">IoC Wikipedia</a></p></li><li><p><a href="https://www.zhihu.com/question/23277575" target="_blank" rel="noopener">IoC 知乎</a></p></li><li><p><a href="https://blog.csdn.net/briblue/article/details/75093382" target="_blank" rel="noopener"> IoC 、DIP 和 DI</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">DIP Wikipedia</a></p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener">en</a> <a href="https://zh.wikipedia.org/wiki/%E4%25%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">zh</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitBook生成电子书(pdf)</title>
    <link href="/2020/3/3/GitBook%E7%94%9F%E6%88%90%E7%94%B5%E5%AD%90%E4%B9%A6(pdf)/"/>
    <url>/2020/3/3/GitBook%E7%94%9F%E6%88%90%E7%94%B5%E5%AD%90%E4%B9%A6(pdf)/</url>
    
    <content type="html"><![CDATA[<ol><li>先 clone 仓库 (前提是 gitbook 仓库)</li></ol><a id="more"></a><ol start="2"><li><p>安装 npm 和相关 module 以及其他插件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装 npm</span>sudo pacman -S npm<span class="hljs-meta">#</span><span class="bash"> 安装 gitbook 命令行工具</span>sudo npm install gitbook-cli -g<span class="hljs-meta">#</span><span class="bash"> 此时 gitbook -V 可以看到版本号</span><span class="hljs-meta">#</span><span class="bash"> 安装caliber</span>sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin<span class="hljs-meta">#</span><span class="bash"> 检查所需要的 ebook-convert 插件是否安装成功</span>ebook-convert --version</code></pre></div><p><a href="HTTPS://CALIBRE-EBOOK.COM/DOWNLOAD">CALIBER 全平台下载地址</a></p></li><li><p>准备生成 EBOOK</p> <div class="hljs"><pre><code class="hljs SHELL">cd [项目文件夹]<span class="hljs-meta">#</span><span class="bash"> 可以看到有 SUMMARY.md,cover.jpg 等,确认是一个 gitbook类型的仓库</span><span class="hljs-meta">#</span><span class="bash"> 安装所需插件</span>gitbook install <span class="hljs-meta">#</span><span class="bash"> 生成电子书以 pdf 为例</span>gitbook pdf<span class="hljs-meta">#</span><span class="bash"> 可以看到有一个 book.pdf 文件已经生成</span></code></pre></div></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux下添加环境变量</title>
    <link href="/2020/2/26/Linux%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2020/2/26/Linux%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="header-anchor" href="#写在前面">⚡</a>写在前面</h2><p>$PATH:决定了 shell 将到哪些目录中去寻找命令或程序，PATH 的值是一系列目录，当运行一个程序时，Linux 将在这些目录下进行搜寻编译链接</p><a id="more"></a><p>添加格式为：</p><blockquote><p>PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:------:<PATH N></p></blockquote><p>编辑完成之后，通过 source .bashrc(如果是 zsh 的话,就是 .zshrc)命令立刻生效</p><p>需要注意的是，最好不要把当前路径 “./” 放到 PATH 里，这样可能会受到意想不到的攻击。</p><p>完成后，可以通过 echo $PATH 查看当前的搜索路径。这样定制后，就可以避免频繁的启动位于 shell 搜索的路径之外的程序了。</p><h2 id="步骤"><a class="header-anchor" href="#步骤">⚡</a>步骤</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改 .zshrc 文件 （如果是 bash，则是 .bashrc）</span>vim ~/.zshrc<span class="hljs-meta">#</span><span class="bash"> 在文件最后加上这样一行</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-variable">$PATH</span> 后面就是路径</span>export PATH="$PATH:/opt/gtm.v1.3.5"<span class="hljs-meta">#</span><span class="bash"> 使修改立刻生效</span>source .zshrc</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ObjectBox</title>
    <link href="/2020/2/19/ObjectBox/"/>
    <url>/2020/2/19/ObjectBox/</url>
    
    <content type="html"><![CDATA[<ol><li><p>介绍:</p><p><a href="https://github.com/objectbox/objectbox-java" target="_blank" rel="noopener">github地址</a></p> <a id="more"></a><p><a href="https://objectbox.io/cn" target="_blank" rel="noopener">官方首页</a></p><p><a href="https://docs.objectbox.io/" target="_blank" rel="noopener">文档</a></p><p><a href="https://objectbox.io/features/" target="_blank" rel="noopener">好处</a>:</p><ol><li><p>速度快:</p><p>无论是传统的 sqlite 还是 Google 推荐的 realm 和 room , 甚至作者之前的产品 GreeDao 在速度上非常有优势.</p><p><img src="https://objectbox.io/wordpress/wp-content/uploads/2018/06/performance-front-page.png" srcset="/img/loading.gif" alt="比较"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/10/163e630d5cccaf06?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="比较2"></p><blockquote><p>从图上可以看出除了在加载 100k 的大量数据的时候 ObjectBox 的速度慢于 Realm，在执行其他数据操作的时候 ObjectBox 的性能对其他两位都是近乎碾压式的存在</p></blockquote><p>官方说是世界上最快的嵌入式数据库!</p><blockquote><p>为了提供高性能的数据库；我们开发ObjectBox。经过测试，ObjectBox是世界上最快的嵌入式数据库。</p></blockquote></li><li><p>是一个 NoSQL 第三方数据库(不是 ORM)</p><p>ObjectBox 并不是一个典型 ORM，它是完全为对象构建的；所以它没有行，列和数据库。没有行，列和 SQL —— ObjectBox 是一个从零开始的对象数据仓库（没有 ORM，没有 SQLite）。</p></li><li><p>调试方便：</p> <div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-comment">// 详情见下面的全局配置示例</span>AndroidObjectBrowser(boxStore).start(context.applicationContext)</code></pre></div> <div class="hljs"><pre><code class="hljs shell">adb forward tcp:8090 tcp:8090</code></pre></div><p>在浏览器输入<a href="http://localhost:8090/index.html" target="_blank" rel="noopener">http://localhost:8090/index.html</a>就可以在网页看到数据的内容了!</p></li></ol> <!-- 1. 其他 --> <!-- ObjectBox 的团队似乎对 RxJava 不太感冒，主要是介意引入RxJava 之后急剧增加的包体积和方法数，所以 ObjectBox 自己封装了一套支持 Reactive Extensions 的接口。 --></li><li><p>博客文章</p><p><a href="https://juejin.im/post/5b1c34fae51d4506ce34a56b" target="_blank" rel="noopener">https://juejin.im/post/5b1c34fae51d4506ce34a56b</a></p><p><a href="https://juejin.im/post/5a0e7bdc6fb9a0451a75f38e" target="_blank" rel="noopener">https://juejin.im/post/5a0e7bdc6fb9a0451a75f38e</a></p><p><a href="https://www.jianshu.com/p/e9996296a982" target="_blank" rel="noopener">https://www.jianshu.com/p/e9996296a982</a></p><p><a href="https://www.jianshu.com/p/e4ebaa433ae7" target="_blank" rel="noopener">https://www.jianshu.com/p/e4ebaa433ae7</a></p><p><a href="https://zhuanlan.zhihu.com/p/31146878" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31146878</a></p></li><li><p>项目例子:</p><ol><li><p>代码地址:</p><p><a href="mailto:git@github.com">git@github.com</a>:objectbox/objectbox-examples.git</p></li><li><p>心得体会</p><p>此项目有很多 module 使用 android-app-kotlin 这一个 module 就好</p><p>android-app-kotlin module 里面有两个类似的文件分别是 NoteActivity 和 ReactiveNoteActivity</p><p>其区别是,前者使用对数据进行更改需要刷新页面的时候,是使用重新查找全部内容然后重新渲染,并且调用 notifyDataSetChanged()方法实现,其思想较简单.</p><p>而 ReactiveNoteActivity 虽然也是重新查找数据并显示,但却是使用订阅观察者模式和多线程的方法,而和前者顺序顺序执行有所区别.</p><p>我猜测可能是基于效率和方便复用的考量</p><p>因为当用户增加文本的时候,会刷新全部数据,把最新的数据刷新上去,但是此时增加按钮应该是阻塞状态.(觉得这个想法有点牵强,不过也是因为这个比较简单的原因,如果是上传大文件或者是项目逻辑比较复杂的时候就应该很有用了)</p><p>复用是为了方便,因为不需要再每次的 addNote() 方法里面顺序调用 updateNotes() 方法重新查找并将数据保存到内存的list里面,而是隐式调用这个方法,减少模板代码的书写.</p></li></ol></li><li><p>注意事项</p><ol><li><p>先编译项目否则会提示有的类找不到</p></li><li><p>必须要一个自增 ID 才行, 用注解 @Id 标识</p></li><li><p>apply plugin: ‘io.objectbox’ 一定要添加到 dependencies 模块后面</p></li><li><p>但是,如果 put、find 这些方法全是同步的，对于大量数据的存和查都是耗时操作，如果直接写在主线程会阻塞主线程，尤其是 find 方法，而 ObjectBox 的 Reactive 封装显然没有 RxJava 那么强大，</p></li><li><p>尽量使用全局配置</p> <div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> ObjectBox &#123;    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> boxStore: BoxStore    <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;        boxStore = MyObjectBox.builder().androidContext(context.applicationContext).build()        <span class="hljs-keyword">if</span> (BuildConfig.DEBUG) &#123;            <span class="hljs-keyword">val</span> start = AndroidObjectBrowser(boxStore).start(context.applicationContext)            Log.d(App.TAG, <span class="hljs-string">"browser start status: <span class="hljs-variable">$start</span>)"</span>)        &#125;    &#125;&#125;</code></pre></div></li><li><p>(手机路径)默认保存位置在 /data/data/包名/files/objectbox/data.mdb</p></li><li><p>设置查询个数</p> <div class="hljs"><pre><code class="hljs kotlin">Query.find(<span class="hljs-built_in">Long</span> offset, <span class="hljs-built_in">Long</span> limit)</code></pre></div></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh</title>
    <link href="/2020/2/3/ssh/"/>
    <url>/2020/2/3/ssh/</url>
    
    <content type="html"><![CDATA[<h2 id="ssh免密登陆"><a class="header-anchor" href="#ssh免密登陆">⚡</a>ssh免密登陆</h2><a id="more"></a><div class="hljs"><pre><code class="hljs shell">cd ~/.ssh<span class="hljs-meta">#</span><span class="bash"> 生成公有和私有密钥id_rsa.pub和iid_rsa</span><span class="hljs-meta">#</span><span class="bash">需要输入的密码地方按回车即可</span>ssh-keygen -t rsa -C '标记'ls -alssh-copy-id -i id_rsa.pub java@218.199.68.208<span class="hljs-meta">#</span><span class="bash">验证登陆</span>ssh -i ./id_rsa java@218.199.68.208</code></pre></div><h2 id="ssh别名登陆"><a class="header-anchor" href="#ssh别名登陆">⚡</a>ssh别名登陆</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">没有config就创建</span>vim ~/.ssh/config</code></pre></div><div class="hljs"><pre><code class="hljs xml">#加入以下配置:Host feidianHostName 218.199.68.208User javaIdentityFile ~/.ssh/id_rsa.pubIdentitiesOnly yes#去相应服务器上用 vim .ssh/authorized_keys 查看是否已经添加</code></pre></div><h2 id="使用ssh连接到github"><a class="header-anchor" href="#使用ssh连接到github">⚡</a>使用ssh连接到github</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 先将~/.ssh目录下的id_rsa.pub文件内容粘贴,再去Github的个人设置的页面,把内容复制过去,在title写下标签,例如:Linux,方便以后管理</span><span class="hljs-meta">#</span><span class="bash"> 测试能否连接上</span>ssh -T git@github.com<span class="hljs-meta">#</span><span class="bash"> 一般来说第一次会出现提示让你确定是否继续连接输入yes即可</span><span class="hljs-meta">#</span><span class="bash"> 如果要等待很长一段时间或者出现timeout的情况,那么可能是本机的防火墙端口配置出现了问题,则修改~/.ssh/config文件</span>vim ~/.ssh/config</code></pre></div><div class="hljs"><pre><code class="hljs xml">Host github.com# 把下方的Email改成自己的EmailUser YourEmailHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa## 修改端口号为443Port 443</code></pre></div><p>再次ssh -T测试即可</p><h2 id="ssh连接Gitlab"><a class="header-anchor" href="#ssh连接Gitlab">⚡</a>ssh连接Gitlab</h2><p>和Github配置同理,如果出现timeout,则修改配置文件:</p><div class="hljs"><pre><code class="hljs xml">Host gitlab.com# 把下方的Email改成自己的EmailUser YourEmailHostname altssh.gitlab.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>shellCommand</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidSetting</title>
    <link href="/2020/1/25/AndroidSetting/"/>
    <url>/2020/1/25/AndroidSetting/</url>
    
    <content type="html"><![CDATA[<h1>Android Studio配置</h1><a id="more"></a><ul><li><p>解决Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 1.6. Please specify proper ‘-jvm-target’ option</p><p>在app/build.gradle文件内添加以下内容</p>  <div class="hljs"><pre><code class="hljs gradle">android &#123;    ...    compileOptions &#123;        <span class="hljs-keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8        <span class="hljs-keyword">targetCompatibility</span> JavaVersion.VERSION_1_8    &#125;    kotlinOptions &#123;        jvmTarget = JavaVersion.VERSION_1_8.toString()    &#125;&#125;</code></pre></div></li><li><p>加入toasty</p><p>在app/build.gradle文件中加入:</p>  <div class="hljs"><pre><code class="hljs gradle"><span class="hljs-keyword">allprojects</span> &#123;    <span class="hljs-keyword">repositories</span> &#123;    ...    maven &#123; url <span class="hljs-string">"https://jitpack.io"</span> &#125;    &#125;&#125;</code></pre></div><p>在module/build.gradle文件中加入:</p>  <div class="hljs"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;    <span class="hljs-comment">// add Toasty</span>    implementation <span class="hljs-string">'com.github.GrenderG:Toasty:1.4.2'</span>&#125;</code></pre></div></li><li><p>使用viewBinding</p><p>在app/build.gradle文件中加入:</p>  <div class="hljs"><pre><code class="hljs xml">android&#123;    ...    viewBinding&#123;        enabled = true    &#125;&#125;...dependencies &#123;    // add viewBinding    implementation 'cz.kinst.jakub:viewmodelbinding:2.0.0'&#125;</code></pre></div><p>如果想要在生成 binding class 时忽略某个布局文件, 我们需要在该布局文件的根元素添加 <code>tools:viewBindingIgnore=&quot;true&quot;</code> 属性.</p><p>注意:</p><blockquote><p>目前ViewBinding的功能还不够完善，比如XML中使用了 inClude 标签时无法对view进行引用。</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cron表达式</title>
    <link href="/2020/1/10/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/1/10/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Cron表达式是一个字符串，以五个或者六个空格隔开，分为6或7个域，每一个域代表一个含义</p><a id="more"></a><p>秒 (0～59)<br>分 (0～59)<br>小时 (0～23)<br>天 (0-31/28/30) <strong>月的第几天</strong><br>月 （0-11）<br>星期 (1-7) <strong>星期几</strong><br>年份 (1970~2099)</p><p>每个元素可以是:</p><ul><li><p>一个具体值</p></li><li><p>一个连续区间(9-12)</p></li><li><p>一个间隔时间</p><p>0/5: 表示从0开始每间隔5，写到哪个元素就表示间隔的是哪个元素，如果写到了秒，那么表示从0开始，每隔5秒执行一次。</p></li><li><p>一个列表</p><p>(1,3,5): 表示第1,3,5时间执行</p></li><li><p>通配符</p><p>(，- * / L W #)</p><p>月份的日期和星期的日期这两个元素是互斥的，必须对其中一个设置通配符 <code>？</code></p></li></ul><p>通配符的详解</p><ul><li><code>*</code> 所有可能的值</li><li><code>/</code> 指定数值的增量</li><li><code>？</code> 表示不指定值</li><li><code>L</code> 表示最后，只能用在<code>日</code>或者<code>周</code>那一栏</li><li><code>W</code> 离指定日期最近的那个工作日(周一至周五), 只能在<code>日</code>那一栏使用。</li><li><code>#</code> 表示每月的第几个周几</li></ul><p><strong>注意</strong>：</p><ol><li><p>基本都允许的字符： ， - * ？</p></li><li><p>特别的:</p><p>表示<code>日</code>的域还可以用 L W</p><p>星期也可以用 L</p></li></ol><p>例如：</p><ol><li><p>0 55 23 L * ? 表示每月的最后一天的23:55分</p></li><li><p>0 0/30 9-17 * * ? ? ? 朝九晚五工作时间内每半小时</p></li><li><p>0 0 12 ? * WED 表示每个星期三中午12点</p></li><li><p>0 0 12 * * ? 每天12点触发</p></li><li><p>0 15 10 ? * * 每天10点15分触发</p></li><li><p>0 * 10 * * ? 每天10:00-10:59每分钟触发一次</p></li><li><p>0 0/5 10 * * ? 每天 10:00-10:59每隔5分钟触发</p></li><li><p>0 0/5 10,15 * * ? 每天10:00-10:59,15:00-15:59(每隔5分触发)</p></li><li><p>0 0-5 15 * * ? 每天15:00-15:05每分触发</p></li><li><p>0 10,55 14 ? 3 WED 3月份每周三14:10触发 ,14:55触发</p></li><li><p>0 15 10 ? * MON-FRI 从周一到周五每天10:15分触发</p></li><li><p>0 15 10 15 * ? 每月15号10:15分触发</p></li><li><p>0 15 10 L * ? 每月最后一天的10:15分触发</p></li><li><p>0 15 10 ? * 6L 每月最后一周的星期五的10:15分触发</p></li><li><p>0 15 10 ? * 6L 2017-2020 从2017年到2020年每月最后一个星期五的10:15分触发</p></li><li><p>0 15 10 ? * 6#3 每月的第三周的星期五10:15触发</p></li><li><p>0 0 12 1/5 * ? 每月的第一天开始每隔5天的12:00触发一次</p></li><li><p>0 11 11 11 11 ? 每年的11月11号 11点11分触发(光棍节)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java聊天器</title>
    <link href="/2019/12/14/Java%E8%81%8A%E5%A4%A9%E5%99%A8/"/>
    <url>/2019/12/14/Java%E8%81%8A%E5%A4%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>项目地址</h1><p><a href="https://github.com/Chao-Yin-Github/javaChartDemo" target="_blank" rel="noopener">https://github.com/Chao-Yin-Github/javaChartDemo</a></p><a id="more"></a><h1>项目介绍</h1><ul><li><p>开发环境</p><ul><li><p>Manjaro 18.1.4 Juhraya</p></li><li><p>JDK:1.8.0_212</p></li><li><p>intellij-idea 2019.3</p></li></ul></li><li><p>本项目基于Java NIO开发，使用到了以下技术:</p><ol><li><p>Java NIO</p><p>使用ServerSocketChannel和SocketChannel，完成客户端和服务端socket通道的建立，来实现数据传输</p></li><li><p>使用slf4j日志框架进行日志管理和程序信息输出</p></li><li><p>使用lombok简化Java Bean的Setter和Getter方法、构造方法、toString等模板化方法的撰写</p></li><li><p><strong>自定义数据传输协议</strong>(Transmission.java)**</p></li></ol></li><li><p>技术栈分析</p><ul><li><p>NIO</p><ul><li><p>背景</p><p>NIO是jdk1.4才引入的，有人称作Non-Blocking-IO(非阻塞IO)，还有人喜欢把他成为New-IO。</p><p>我认为各自都有理，首先Non-Blocking-IO就不用说了，因为NIO提供了非阻塞的IO模式，这和传统的BIO(Blocking-IO)有了明显区别。</p><p>那为什么New-IO也是可以的呢，因为NIO是面向缓冲的(Buffer oriented)，基于通道(Channel)(双工，既能读也能写)的IO操作方法，这样就和老式的BIO面向流(Stream oriented)(单方向，只能读或者只能写)的操作，有了本质的区别，所以把它称作New-IO也不无道理。</p></li></ul></li><li><p>使用自定义协议传输数据(Transmission.java)</p><ul><li><p>背景:</p><p>当我在基本分别完成传输字符串和传输文件的功能时，遇到了一个问题，NIO的Server是单线程的，那么就不能通过一般的方式解决传输文件和文本字符串的问题。</p><p>因为如果是多线程的服务端，可以在有一个新的连接到服务端时，服务端就开启一个线程专门处理这个客户端的连接，多个客户端之间不会混乱。</p><p>这样，我这个用户1可以先发送一个标识符来标识一下，我接下来将要发送文本字符串还是文件。如果有客户2同时发送别的信息，服务端的这两个线程之间是不会受到任何影响的。</p><p>但是通过NIO写的服务端是单线程处理连接的，这样，一个用户1发送一个标识符表示接下来会发送一个字符串，但是这时，又有另外一个用户把文件发送过来，服务端是没法分辨出到底是哪一个客户端发送的标识符，也无法分辨出是哪一个客户端发送的数据，这样服务端就会混乱掉。</p></li><li><p>解决办法</p><ol><li><p>方法一：</p><p>最容易想到的是：</p><p>既然服务端无法标识用户，那么客户端就可以规定一个长度一定的标识，然后后面接着数据一起发送给服务端，那么服务端就可以直接把标识信息和数据一起读出来。</p><p>我传输文件用的是FileChannel，然后再使用transferFrom和transferTo方法来实现传到SocketChannel里面和从SocketChannel里面读取数据到FileChannel。</p><p>这样转化其实是可行的，但是我觉得有些麻烦也不够优雅。</p></li><li><p>方法二：</p><p>和方法一一样，都是把标识信息和数据一起传输，但是方式略有不同。</p><p>对于发送方的客户端，我们可以把信息和数据全部封装成一个类，然后我们就可以把这个类序列化成字符串，再把字符串转化为字节数组用SocketChannel传输。</p><p>而服务端则将接收的字节数组反序列化成对象，从中提取需要的信息，再序列化传输给另一个客户端。</p><p>至于另一个接收方的客户端，则同理，将获得的字节数组反序列化成对象，就可以拿到数据进行处理获取相应的内容了。</p></li></ol></li><li><p>选择方法二的理由</p><p>我认为方法二比方法一更好的理由是:如果自定义一个类传输数据，我们就可以把这个类称作为一种数据传输协议。</p><p>因为像http传输协议就是一个基于tcp/ip的传输协议，它定义了请求/响应行(Request/Response Line)，请求/响应头(Request/Response Header)，空行和请求/响应数据(Request/Response Body)，所有使用http协议都要有它所规定的这些结构。</p><p>而这个Transmission类其实也是一样的道理，声明了数据的类型(TransmissionType)，也保存了数据内容(content)本身，还有消息目的方的信息(destinationNumber)等等信息。</p><p><strong>由此，我可以大胆把这个Transmission类称作为我自己的一个聊天器协议！</strong></p></li><li><p>Transmission.java</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transmission</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 数据内容</span><span class="hljs-comment">     */</span> <span class="hljs-keyword">private</span> String content;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文件类型</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> TransmissionType transmissionType;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送目的客户编号</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> destinationNumber;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 原客户编号</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sourceNumber;&#125;</code></pre></div></li><li><p>TransmissionType.java</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> TransmissionType implements Serializable &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文件类型</span><span class="hljs-comment">     */</span>    FILE,        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文本字符串</span><span class="hljs-comment">     */</span>    STRING,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 信息</span><span class="hljs-comment">     */</span>    MESSAGE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * id标识</span><span class="hljs-comment">     */</span>    UUID&#125;</code></pre></div></li><li><p>那这个Transmission类如何传输文本字符串和文件这两种数据呢？</p><p>对于文本字符串自不必说，把要发送的字符串存到content字段里即可，接收方可以直接获取content字段内容。</p><p>至于传输文件，我是先把文件转化成字节数组，再用Base64加密以防字符集乱码，再转化成字符串存到content里。</p><p>接收数据时，则跟发送数据时的操作正好相反，先把读到的字节数组转化成Transmission类，再拿到content字段内容之后，先用Base64解密，再转化为文件保存下来。</p></li></ul></li></ul></li><li><p>可能时由于网络速度的限制加上NIO的特性，这个在本地测试没问题，可是一放到服务器上就出现超过一定大小文件就发送失败的问题。可能和服务器的网速太慢还有NIO非阻塞的特性两者综合作用的结果。因为网速较慢，所以有时服务端接收到一半就认为没有数据了，而客户端的数据还没有发送上来，而服务端又是NIO非阻塞的特性，所以很可能数据读到一半就停止了，开始转化信息，但是数据不完整就会出错。这个由于时间问题还没有解决，以后有空的时候还是想找找其他方法解决一下。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中对象和对象引用的区别</title>
    <link href="/2019/12/6/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/12/6/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="对象"><a class="header-anchor" href="#对象">⚡</a>对象</h2><p>对象是什么?</p><p>在《Java编程思想》里，是这样解释的：</p><a id="more"></a><blockquote><p>“按照通俗的说法，每个对象都是某个类（class）的一个实例（instance），这里，‘类’就是‘类型’的同义词。”</p></blockquote><p>所以对象是类的实例。而类就是类型的意思。</p><h2 id="对象引用"><a class="header-anchor" href="#对象引用">⚡</a>对象引用</h2><p>同样是《Java编程思想》里面的一句话：</p><blockquote><p>“每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。”</p></blockquote><p>用一个例子来理解</p><div class="hljs"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();</code></pre></div><p>A a则仅仅是对象的声明，是在栈上创建了一个对象引用。</p><p>即a是一个对象引用而非对象本身。</p><p>而只有当new A()这个操作调用之后，才在堆上创建一个类A的对象，或者说是实例。</p><p>而a = new A()；才是真正把a这个对象引用和对象本身关联上。</p><h2 id="对象和对象引用的区别"><a class="header-anchor" href="#对象和对象引用的区别">⚡</a>对象和对象引用的区别</h2><p>下面看一个例子</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">int</span> b = a[<span class="hljs-number">0</span>];        b = <span class="hljs-number">123</span>;        System.out.println(a[<span class="hljs-number">0</span>]);    &#125;&#125;</code></pre></div><p>如果我们认为Java中的引用和C中的指针是同一个东西的话，上面这段Java程序就应该对应的下面这段c++程序</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">1</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> *b = a;*b = <span class="hljs-number">123</span>;<span class="hljs-built_in">cout</span>&lt;&lt;a[<span class="hljs-number">0</span>];<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>这段C++程序的结果当然是123。</p><p>但上面第一段Java程序输出结果当然是0而不是123。</p><p>这是因为Java中的引用虽然和C++的指针看似好像一样，都是描述变量的工具，但实际上还是有差别的。</p><hr><p>Java中的变量只有两种类型，一种是基本数据类型，还有一种是引用类型。</p><p>当作为参数传递给一个方法时，处理这两种类型的方式是相同的。Java中都是<strong>按值传递</strong>，没有引用传递。即：</p><p>按值传递意味着传递的是原始值的一个副本。这样，即使函数改变了值，改变的也是原始值的副本，而非原始值本身。</p><p>而引用传递则意味着函数接收的就是原始值本身，这样当函数修改这个值，那么对应的原始值也会被修改。</p><p>看一个例子</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinchao</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewClassForTest</span> </span>&#123;    <span class="hljs-keyword">int</span> a;    String name;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinchao</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMethod</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        String string = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"123"</span>);        NewClassForTest newClassForTest = <span class="hljs-keyword">new</span> NewClassForTest();        newClassForTest.a = <span class="hljs-number">1</span>;        newClassForTest.name =  <span class="hljs-string">"test1"</span>;        change(string,newClassForTest);        System.out.println(string);        System.out.println(newClassForTest.a+<span class="hljs-string">"\n"</span>+newClassForTest.name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(String newString,NewClassForTest newClassForTest)</span> </span>&#123;        newString = <span class="hljs-string">"1234"</span>;        newClassForTest.a = <span class="hljs-number">2</span>;        newClassForTest.name = <span class="hljs-string">"test2"</span>;    &#125;&#125;</code></pre></div><blockquote><p>结果：<br>123<br>2<br>test2</p></blockquote><p>那么在此处为什么同样是通过change方法，string的结果没变，而newClassForTest的改变了?</p><ul><li><p>对于string因为在change方法中，newString这个对象引用已经不再指向原来的对象&quot;123&quot;了</p><p>在 new String的过程中，newString 这个对象引用已经把原来的指向取消，而且建立了一个新的指向到这个新的&quot;1234&quot;。而原来的string还是指向到原来的&quot;123&quot;，并没有收到对象引用副本改变指向的影响。</p></li><li><p>对于newClassForTest，newClassForTest.a = 2;实际上是把对象的属性赋了新的值。函数形参和实参都是对象的引用，而且都是指向同一个对象，和副本并无关系，和是否在函数内也没有关系。这两个newClassForTest并没有主从之分，一个对象引用改变的对象的属性,另一个对象引用的对象当然也会随之改变。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql中的相关子查询和不相关子查询</title>
    <link href="/2019/10/28/SQL%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8C%E4%B8%8D%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <url>/2019/10/28/SQL%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8C%E4%B8%8D%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<ul><li><p>不相关子查询：</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ×<span class="hljs-keyword">from</span> tableOneName<span class="hljs-keyword">where</span> columnName <span class="hljs-keyword">in</span> (    <span class="hljs-keyword">select</span> columnName    <span class="hljs-keyword">from</span> tableTwoName    <span class="hljs-keyword">where</span> condition);</code></pre></div>  <a id="more"></a><p>类似上面这种<strong>先执行子查询</strong>，得到一个集合或者值，然后将这个集合或者值作为一个<strong>常量</strong>，再带入到父查询中作为父查询的一个条件。</p></li><li><p>相关子查询</p><p>通俗来说，相关子查询就是：子查询要用到父查询中的值。</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> *<span class="hljs-keyword">from</span> tableOneName<span class="hljs-keyword">where</span> columnOneName <span class="hljs-keyword">in</span> (    <span class="hljs-keyword">select</span> columnOneName    <span class="hljs-keyword">from</span> tableTwoName    <span class="hljs-keyword">where</span> tableTwoName.columnTwoName = tableOneName.columnTwoName)</code></pre></div><p>先扫描副查询的数据表中的<strong>每一条</strong>记录，然后将当前这条记录中的子查询会用到的数据，<strong>带入到子查询中</strong>，然后<strong>再执行子查询</strong>，得到结果，然后再将这个结果<strong>回代</strong>到父查询中，判断父查询的值是否为true，如果为true则把这条记录放回到结果集中，反之，如果为false，则不会把这条记录放到结果集中。</p><blockquote><p>此时，子查询就用到了父查询的结果</p></blockquote></li><li><p>如何判断是相关的还是不相关的子查询？</p><p>如果子查询不能脱离父查询单独执行，那么就是相关子查询。</p></li><li><p>EXISTS</p><p>exists的概念和相关子查询的概念相似，它的作用就是判断子查询得到的<strong>结果集是否是一个空集</strong>。</p><p>它和相关子查询一样，在子查询中用到父查询的条件。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql中having 和 where的区别</title>
    <link href="/2019/10/24/SQL%E4%B8%ADhaving%E5%92%8Cwhere%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/10/24/SQL%E4%B8%ADhaving%E5%92%8Cwhere%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ul><li><p>having 是对结果进行筛选</p><p>having是一个过滤声明，所谓过滤是在查询数据库的结果返回之后进行过滤，即在结果返回之后起作用，并且having后面可以使用“聚合函数”。</p>  <a id="more"></a></li><li><p>where 是在查询数据的时候直接对数据库进行筛选</p><p>where是一个约束声明，在查询数据库的结果返回之前对数据库中的查询条件进行约束，即在结果返回之前起作用，且where后面不能使用“聚合函数”。</p></li><li><p>聚合函数，是对一组值进行计算并且返回<strong>单一值</strong>的函数。聚合函数一定是返回一个结果。</p></li><li><p>where后面之所以不能使用聚合函数是因为where的执行顺序在聚合函数之前</p></li><li><p>having 是对查出来的结果进行过滤，这样就不能对没有查出来的值进行过滤。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 -- 状态模式(state)</title>
    <link href="/2019/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F(state)/"/>
    <url>/2019/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F(state)/</url>
    
    <content type="html"><![CDATA[<h2 id="一句话概括"><a class="header-anchor" href="#一句话概括">⚡</a>一句话概括</h2><p>状态模式<strong>允许对象在内部状态时改变它的行为，对象看起来好像修改了它所属的类。</strong></p><a id="more"></a><p>用途：</p><p>主要是解决当控制一个对象装换的条件表达式过于复杂的时候，把状态判断逻辑转移到表示不同状态的一系列类当中。<strong>可以把复杂的判断逻辑简化。</strong></p><h2 id="例子"><a class="header-anchor" href="#例子">⚡</a>例子</h2><p>现在有这样一个需求：</p><blockquote><p>有一个糖果机，当有人把25美分的硬币放到机器里，转动曲柄，这个机器就会弹出糖果。<br>但是，这个机器有好几种状态，在某些状态下可以弹出糖果，而在某些状态下不能。</p></blockquote><p>如下图所示，用圆圈表示状态，箭头表示行为。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/289823/1571417665158-d62d91cf-f506-44b2-a01f-203f80039da0.png" srcset="/img/loading.gif" alt="糖果机"></p><h3 id="if-else-switch-case-大法"><a class="header-anchor" href="#if-else-switch-case-大法">⚡</a>if-else / switch case 大法</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GumBall</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 糖果机状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> State state;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 糖果数目</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;GumBall(<span class="hljs-keyword">int</span> number) &#123;<span class="hljs-keyword">if</span> (number &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">this</span>.number = number;state = State.NO_QUARTER_STATE;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">this</span>.number = <span class="hljs-number">0</span>;state = State.NO_CANDY_STATE;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 投入一个25美分硬币买糖果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"投入硬币"</span>);<span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",已经放有硬币，请稍候"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">",售罄"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">",正在出货，请等待"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 允许投入硬币的情况</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",成功投入一枚硬币"</span>);state = State.HAS_QUARTER_STATE;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 拿回硬币</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"退款"</span>);<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">",已售罄"</span>);&#125;<span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",没有硬币"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">",硬币已存入"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",退还硬币成功"</span>);state = State.NO_QUARTER_STATE;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 转动曲柄</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"转动曲柄"</span>);<span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",未付款，请先投入硬币"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">"，已售罄"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">"，请稍候正在出货"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">""</span>);state = State.GOING_TO_PRODUCE_STATE;dispense();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 分发糖果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"分发糖果"</span>);<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">",没有糖果，无法出货"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",没有硬币，请先付款"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",请先转动曲柄"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">",出货成功"</span>);number--;<span class="hljs-keyword">if</span> (number == <span class="hljs-number">0</span>) &#123;System.out.println(<span class="hljs-string">"糖果卖完了"</span>);state = State.NO_CANDY_STATE;&#125; <span class="hljs-keyword">else</span> &#123;state = State.NO_QUARTER_STATE;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"state:"</span> + String.valueOf(state) + <span class="hljs-string">"\tinventory:"</span> + number;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 装填糖果</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> number 新加入糖果数量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refill</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;System.out.println(<span class="hljs-string">"before refill:"</span> + <span class="hljs-keyword">this</span>.number);<span class="hljs-keyword">this</span>.number += number;<span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span> || state == State.NO_CANDY_STATE) &#123;state = State.NO_QUARTER_STATE;&#125;System.out.println(<span class="hljs-string">"after refill:"</span> + <span class="hljs-keyword">this</span>.number);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> State &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 没有25美分</span><span class="hljs-comment"> */</span>NO_QUARTER_STATE,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 有25美分</span><span class="hljs-comment"> */</span>HAS_QUARTER_STATE,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 即将产生糖果</span><span class="hljs-comment"> */</span>GOING_TO_PRODUCE_STATE,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 售罄</span><span class="hljs-comment"> */</span>NO_CANDY_STATE&#125;&#125;</code></pre></div><p>主函数测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;GumBall gumBall = <span class="hljs-keyword">new</span> GumBall(<span class="hljs-number">2</span>);System.out.println(gumBall.toString());<span class="hljs-comment">// 正常流程</span>gumBall.insertQuarter();gumBall.turnCrank();System.out.println(gumBall.toString());<span class="hljs-comment">// 直接退款无效</span>gumBall.ejectQuarter();System.out.println(gumBall.toString());<span class="hljs-comment">// 投钱再取出,再转动曲柄，无效</span>gumBall.insertQuarter();gumBall.ejectQuarter();gumBall.turnCrank();System.out.println(gumBall.toString());<span class="hljs-comment">// 投钱再转动曲柄,再取出，有效</span>gumBall.insertQuarter();gumBall.turnCrank();gumBall.ejectQuarter();System.out.println(gumBall.toString());<span class="hljs-comment">// 没货了</span>gumBall.insertQuarter();gumBall.ejectQuarter();gumBall.turnCrank();System.out.println(gumBall.toString());&#125;&#125;</code></pre></div><p>输出：</p><blockquote><p>state:NO_QUARTER_STATEinventory:2</p></blockquote><blockquote><p>投入硬币,成功投入一枚硬币<br>转动曲柄<br>分发糖果,出货成功<br>state:NO_QUARTER_STATEinventory:1</p></blockquote><blockquote><p>退款,没有硬币<br>state:NO_QUARTER_STATEinventory:1</p></blockquote><blockquote><p>投入硬币,成功投入一枚硬币<br>退款,退还硬币成功<br>转动曲柄,未付款，请先投入硬币<br>state:NO_QUARTER_STATEinventory:1</p></blockquote><blockquote><p>投入硬币,成功投入一枚硬币<br>转动曲柄<br>分发糖果,出货成功<br>糖果卖完了<br>退款,已售罄<br>state:NO_CANDY_STATEinventory:0</p></blockquote><blockquote><p>投入硬币,售罄<br>退款,已售罄<br>转动曲柄，已售罄<br>state:NO_CANDY_STATEinventory:0</p></blockquote><p>到目前为止好像都很顺利?</p><hr><p>然后，最讨厌的部分还是来了，<strong>改需求！?</strong></p><blockquote><p>现在，糖果机为了增加销量增加，有10%的几率会在转动曲柄的时候出来两颗糖果。</p></blockquote><p>这样糖果机会多出一个 <strong>'中奖’</strong> 状态</p><p>那么，此时就要修改原来写好的代码逻辑：</p><p>在insetQuarter、ejectQuarter、turnCrank（）、dispense（）等方法里，每个方法再加上一个if条件判断-&gt;是否为中奖状态。</p><p>而且turnCrank方法会变得特别复杂，因为这里就需要考虑是转变为<strong>中奖状态(winner_state)<strong>还是</strong>即将销售状态(Going_to_produce_state)</strong>。</p><p>存在的问题:</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/289823/1571416247293-a5fb488a-852c-46af-a9b8-3189bbfe809c.png" srcset="/img/loading.gif" alt="存在的问题"></p><p>这样的程序就更像是一般我们写C++的顺序的，或者说是过程化的编程范式，没有用到面向对象的设计思想，而且扩展性很差。</p><p>无独有偶，在《重构：改善既有代码的设计》一书中，提到一个概念：<br><strong>代码的坏味道(bad smell)：</strong></p><p>其中一种就是Long Method(过长的方法)</p><p>由此，状态模式就出场了⬇。</p><hr><h3 id="状态模式"><a class="header-anchor" href="#状态模式">⚡</a>状态模式</h3><ul><li><p>新的设计:</p><blockquote><p>将<strong>状态对象</strong>封装到各自类中，然后在动作发生时<strong>委托</strong>给当前状态。</p></blockquote></li><li><p>步骤：</p><ol><li><p>定义一个State<strong>接口</strong>。</p><p>糖果机的每个动作都有一个对应的<strong>方法</strong>,然后把所有动作封装好。</p></li><li><p>为机器中每个状态实现<strong>状态类</strong>。</p><p>这些具体状态类负责在对应状态下进行机器的行为。</p></li><li><p>将动作委托到状态类。</p></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/289823/1571416193267-d7c6251c-33f0-4a04-a6f0-13bec77ae5fc.png" srcset="/img/loading.gif" alt="类图"></p><ul><li><p>代码</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">turnGrank</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 没有硬币状态</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoQuarterState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span>()</span>&#123;NewGumball newGumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NoQuarterState</span><span class="hljs-params">(NewGumBall newGumBall)</span></span>&#123;<span class="hljs-keyword">this</span>.newGumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"成功投入一枚硬币"</span>);newGumBall.setState(newGumBall.getHasQuarterState());&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"没有硬币，退款失败"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"请先投入硬币再转动曲柄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"请先投入硬币"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"NoQuarterState"</span>);&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 没有糖果状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoCandyState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<span class="hljs-keyword">private</span> NewGumBall newgumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NoCandyState</span><span class="hljs-params">(NewGumBall newGumBall)</span> </span>&#123;<span class="hljs-keyword">this</span>.newgumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"NoCandyState"</span>;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 即将出货状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoingToBeProduceState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<span class="hljs-keyword">private</span> NewGumBall newGumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GoingToBeProduceState</span><span class="hljs-params">(NewGumBall newGumBall)</span> </span>&#123;<span class="hljs-keyword">this</span>.newGumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"正在出货，请勿重复投币"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;newGumBall.releaseCandy();<span class="hljs-keyword">if</span> (newGumBall.getCandyNumber() &gt; <span class="hljs-number">0</span>) &#123;newGumBall.setState(newGumBall.getNoQuarterState());&#125; <span class="hljs-keyword">else</span> &#123;System.out.println(<span class="hljs-string">"最后一个糖果已卖出"</span>);newGumBall.setState(newGumBall.getNoCandyState());&#125;System.out.println(<span class="hljs-string">"出货成功"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"退款失败，硬币已投入"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"正在出货，请勿转动曲柄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"GoingToBeProduceState"</span>;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 有硬币状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasQuarterState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<span class="hljs-keyword">private</span> NewGumBall newGumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HasQuarterState</span><span class="hljs-params">(NewGumBall newGumBall)</span> </span>&#123;<span class="hljs-keyword">this</span>.newGumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"已投入硬币，请勿重复投入"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"请转动曲柄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"退款成功"</span>);newGumBall.setState(newGumBall.getNoQuarterState()); &#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"转动曲柄，等待出货"</span>);newGumBall.setState(newGumBall.getGoingToBeProduceState());&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"HasQuarterState"</span>;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 全新的糖果机</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewGumBall</span> </span>&#123;<span class="hljs-keyword">private</span> State state;<span class="hljs-keyword">private</span> State goingToBeProduceState;<span class="hljs-keyword">private</span> State HasQuarterState;<span class="hljs-keyword">private</span> State NoCandyState;<span class="hljs-keyword">private</span> State NoQuarterState;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> candyNumber = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NewGumBall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> candyNumber)</span> </span>&#123;goingToBeProduceState = <span class="hljs-keyword">new</span> GoingToBeProduceState(<span class="hljs-keyword">this</span>);HasQuarterState = <span class="hljs-keyword">new</span> HasQuarterState(<span class="hljs-keyword">this</span>);NoCandyState = <span class="hljs-keyword">new</span> NoCandyState(<span class="hljs-keyword">this</span>);NoQuarterState = <span class="hljs-keyword">new</span> NoQuarterState(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">if</span> (candyNumber &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">this</span>.candyNumber = candyNumber;state = NoQuarterState;&#125; <span class="hljs-keyword">else</span> &#123;state = NoCandyState;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseCandy</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"糖果已出货"</span>);<span class="hljs-keyword">if</span> (candyNumber &gt; <span class="hljs-number">0</span>) &#123;candyNumber--;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;<span class="hljs-keyword">this</span>.state = state;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCandyNumber</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> candyNumber;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getGoingToBeProduceState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> goingToBeProduceState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getHasQuarterState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> HasQuarterState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getNoCandyState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> NoCandyState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getNoQuarterState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> NoQuarterState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;state.insertQuarter();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;state.turnCrank();state.dispense();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;state.ejectQuarter();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"state:"</span> + state + <span class="hljs-string">"\t inventory:"</span> + candyNumber;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;NewGumBall newGumBall = <span class="hljs-keyword">new</span> NewGumBall(<span class="hljs-number">2</span>);System.out.println(newGumBall.toString());<span class="hljs-comment">// 正常流程</span>newGumBall.insertQuarter();newGumBall.turnCrank();System.out.println(newGumBall.toString());<span class="hljs-comment">// 直接退款无效</span>newGumBall.ejectQuarter();System.out.println(newGumBall.toString());<span class="hljs-comment">// 投钱再取出,再转动曲柄，有效</span>newGumBall.insertQuarter();newGumBall.ejectQuarter();newGumBall.turnCrank();System.out.println(newGumBall.toString());<span class="hljs-comment">// 投钱再转动曲柄,再取出，无效</span>newGumBall.insertQuarter();newGumBall.turnCrank();newGumBall.ejectQuarter();System.out.println(newGumBall.toString());<span class="hljs-comment">// 没货了</span>newGumBall.insertQuarter();newGumBall.ejectQuarter();System.out.println(newGumBall.toString());&#125;&#125;</code></pre></div><p>输出：</p><blockquote><p>state:NoQuarterSate inventory:2</p></blockquote><blockquote><p>成功投入一枚硬币<br>转动曲柄，等待出货<br>糖果已出货<br>出货成功<br>state:NoQuarterSate inventory:1</p></blockquote><blockquote><p>没有硬币，退款失败<br>state:NoQuarterSate inventory:1</p></blockquote><blockquote><p>成功投入一枚硬币<br>退款成功<br>请先投入硬币再转动曲柄<br>请先投入硬币<br>state:NoQuarterSate inventory:1</p></blockquote><blockquote><p>成功投入一枚硬币<br>转动曲柄，等待出货<br>糖果已出货<br>最后一个糖果已卖出<br>出货成功<br>售罄<br>state:NoCandyState inventory:0</p></blockquote><blockquote><p>售罄<br>售罄<br>售罄<br>售罄<br>state:NoCandyState inventory:0</p></blockquote><ul><li><p>好处？</p><ol><li><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开。</p><p>局部化：将具有普适性的行为抽象出来，放到一个抽象对象中封装起来。</p><p>这样，当有新的状态加入时，我们可以通过定义新的状态类来实现接口/继承父类，来<strong>消除庞大的条件分支语句</strong>来判断状态。</p><p>原理:把逻辑分布到State子类之间，来减少相互间的依赖。</p></li><li><p>而且当从这个状态对象转化为另为一个状态对象时，封装起来的行为潜在的改变，但是用户对此毫不知情。</p></li></ol></li><li><p>缺点:</p><p>子类太多，不好管理。</p></li><li><p>适用情况:</p><ol><li><p>当一个对象有很多种状态，而且他的行为依赖于他的状态，并且在运行时可能动态改变。</p></li><li><p>一个对象中含有庞大的条件分支语句，并且这些分支依赖于该对象的状态。</p></li></ol></li></ul></li></ul><hr><h2 id="设计模式之外的部分"><a class="header-anchor" href="#设计模式之外的部分">⚡</a>设计模式之外的部分</h2><ol><li><p>多范式编程语言: 支持超过一种编程范型语言</p></li><li><p>编程范型: 一类典型编程风格，如:</p><blockquote><p>并发编程，约束编程，数据流编程，声明性编程，分布式的编程，函数式编程，泛型编程，命令式(指令式)编程，逻辑编程，元编程，面向对象编程</p></blockquote><p>过程式编成: 主要采取程序调用（procedure call）或函数调用（function call）的方式来进行流程控制。</p><p>编程范型提供并决定程序员对程序执行的看法</p><p>Scala是一门多范式的编程语言，集成面向对象和函数式编程的特性。</p><p>C++支持过程化，面向对象，范型编程</p></li><li><p>符合迪米特法则(得墨忒耳定律 Law of Demeter -&gt; LoD、最小知识原则)：</p><p>迪米特法则可以简单说成：talk only to your immediate friends。</p><p>一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p><ol><li><p>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；</p></li><li><p>每个单元只能和它的朋友交谈：不能和陌生单元交谈；</p></li><li><p>只和自己直接的朋友交谈。</p></li></ol><p>得墨忒耳定律使得软件更好的可维护性与适应性。</p><p>因为对象较少依赖其它对象的内部结构，可以改变对象容器（container）而不用改变它的调用者（caller）。</p><blockquote><p>一个简单例子是，人可以命令一条狗行走(walk)，但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p></blockquote></li><li><p>卫语句</p><p>如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为“卫语句”。</p><p>常用到的地方: if语句使用“卫语句 ”减少层级嵌套。</p></li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>拥有[短方法] (short methods)的对象会活得比较好、比较长。不熟悉面向对象技术的人，常常觉得对象程序中只有无穷无尽的delegation(委托)，根本没有进行任何计算。和此类程序共同生活数年之后，你才会知道，这些小小方法有多大价值。［间接层］所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型方法支持的。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring MVC 知识 -- 接收 Post 请求的几种方式</title>
    <link href="/2019/9/16/Spring-MVC-%E7%9F%A5%E8%AF%86-%E6%8E%A5%E6%94%B6-Post-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2019/9/16/Spring-MVC-%E7%9F%A5%E8%AF%86-%E6%8E%A5%E6%94%B6-Post-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Content-Type以application/x-www-form-urlencoded进行传输</p><p>此种传输方式是构造form表单的普通post请求的方式进行传输</p> <a id="more"></a><p>controller中需要有两个参数，同时这个两个参数不能加@RequestBody或者是加@RequestParam，参数会以字符串和数组的形式填充到参数里面</p></li><li><p>Content-Type以application/json的方式进行传输</p><p>此种方式需要传输一个json格式的字符串</p><p>controller中需要以一个字符串来进行接受这个json字符串</p><p>如果用注解的话需要添加@RequestBody</p><p>如果不用注解，需要从request域里面把body内容读取出来，然后将此字符串进行json反序列化成对象，如果想让他自动转化成对象，需要在SpringMVC的配置里面配置json序列化工具。</p><p>接收参数：多个单一属性的一个对象</p></li><li><p>以键值对方式发送请求</p><p>这样发送参数在请求头，即每个参数使用@RequestParam注解即可</p><p>接受参数：多个单一参数</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Spring MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器搭建手记(Ubuntu)</title>
    <link href="/2019/9/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%89%8B%E8%AE%B0(Ubuntu)/"/>
    <url>/2019/9/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%89%8B%E8%AE%B0(Ubuntu)/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="软件安装"><a class="header-anchor" href="#软件安装">⚡</a>软件安装</h2>  <a id="more"></a><ul><li><h3 id="mysql"><a class="header-anchor" href="#mysql">⚡</a>mysql</h3>  <div class="hljs"><pre><code class="hljs shell">sudo apt-get update<span class="hljs-meta">#</span><span class="bash"> 直接装老版本5.7</span>sudo apt-get install mysql-server</code></pre></div><ul><li><p>修改root用户密码</p><p>在debain系的Linux下，mysql是有默认的debian-sys-maint用户的</p><p>其密码在/etc/mysql/debain.cnf下</p>  <div class="hljs"><pre><code class="hljs shell">mysql -udebian-sys-maint -ppassword</code></pre></div>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">use</span> mysql;<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> authentication_string=<span class="hljs-keyword">password</span>(<span class="hljs-string">'root'</span>) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">'root'</span> <span class="hljs-keyword">and</span> Host=<span class="hljs-string">'localhost'</span>;<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">plugin</span>=<span class="hljs-string">"mysql_native_password"</span>;        <span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;quit;</code></pre></div></li><li><p>创建用户，授予权限</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment"># 创建用户</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">'guest'</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'密码'</span>;<span class="hljs-comment"># 授予databaseName数据库的所有权限</span>grants all privileges on databaseName.* to 'guest'@'%' with grant option;<span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;<span class="hljs-comment"># 或者授予mysql所有权限</span>grants all privileges on *.* to 'guest'@'%' with grant option;<span class="hljs-comment"># 查看权限</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">grants</span> <span class="hljs-keyword">for</span> guest;</code></pre></div></li><li><p>开启远程连接</p>  <div class="hljs"><pre><code class="hljs shell">cd /etc/mysql/mysql.conf.d/sudo vim mysqld.cnf</code></pre></div>  <div class="hljs"><pre><code class="hljs cnf"># 把下面这行注释掉bind-address &#x3D; 127.0.0.1</code></pre></div>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 重启</span>sudo systemctl restart mysql</code></pre></div></li></ul></li><li><p>JDK8(Oracle)</p><p>网上ppa源的办法已失效，只能手动去官网下载jdk8的tar.gz包</p><ol><li><p>在本地下载好scp传到服务器</p></li><li><p>在服务器端解压</p></li></ol></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>shellCommand</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux软链</title>
    <link href="/2019/9/1/Linux%E8%BD%AF%E9%93%BE/"/>
    <url>/2019/9/1/Linux%E8%BD%AF%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="写在前面"><a class="header-anchor" href="#写在前面">⚡</a>写在前面</h2><p>在Linux系统中，内核为每一个新创建的文件分配一个inode(索引结点)，每个文件有一个唯一的inode号。文件属性保存在inode里。</p>  <a id="more"></a><p>在访问文件时，inode被复制到内存里，从而实现文件的快速访问。</p></li><li><h2 id="链接是什么？"><a class="header-anchor" href="#链接是什么？">⚡</a>链接是什么？</h2><p>链接是一种共享文件和访问它的用户的若干目录项之间建立联系的一种方法。</p><p>在windows下，我们称为快捷方式。</p></li><li><h2 id="硬链接"><a class="header-anchor" href="#硬链接">⚡</a>硬链接</h2><p>如果一个inode对应多个文件名，则称这些文件为硬链接。</p><p>换言之，硬链接就是一个文件的多个别名。也可以认为是以inode作为文件指针。</p><ul><li><p>特性:</p><ul><li><p>文件inode相同</p></li><li><p>只能对已存在的文件进行创建</p></li><li><p>不能交叉文件系统进行硬链接的创建</p></li><li><p>不能对目录进行创建，只能对文件</p><p>但是可以通过*通配符进行文件夹中的文件统一创建</p></li><li><p>删除一个硬链接文件不影响其它相同inode文件，只是结点连接数减少。</p><p>只要结点连接数不是0，文件就一直存在。</p><p>而且此时就不再区分源文件和链接文件，只要任一文件被修改，所有文件都会同步修改。</p></li><li><p>只有超级用户才可以为目录创建硬链接。</p></li></ul></li><li><p>创建硬链接</p>  <div class="hljs"><pre><code class="hljs shell">link existingFile newFile</code></pre></div><p>这样当前目录下就出现了一个和existingFile一模一样的文件newFile</p></li></ul></li><li><h2 id="软链接，也成为符号链接"><a class="header-anchor" href="#软链接，也成为符号链接">⚡</a>软链接，也成为符号链接</h2><p>软链接就是一个普通文件，它有着自己的inode号。</p><p>软链接就是另一文件的指向。可以认为是以文件路径名作为文件指针。</p><ul><li><p>特性:</p><ul><li><p>有自己的文件属性和权限</p></li><li><p>可以对不存在的文件或目录创建</p></li><li><p>可以交叉文件系统</p></li><li><p>删除软链接并不影响原文件，但若原文件被删除，相关软链接则被称为死链接</p></li></ul></li><li><p>创建软链</p>  <div class="hljs"><pre><code class="hljs shell">link -s sourceFile newFile</code></pre></div></li><li><p>删除软链</p><p>注意软链接newFile后面不能加<code>/</code>，否则会删除原文件。</p>  <div class="hljs"><pre><code class="hljs shell">rm -rf newFile</code></pre></div></li><li><p>修改软链接</p>  <div class="hljs"><pre><code class="hljs shell">ln -snf sourceFile newFile</code></pre></div><p>这样就把newFile的指向指到了sourceFile的路径了。</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
      <tag>shellCommand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java重载和重写</title>
    <link href="/2019/8/30/Java%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99/"/>
    <url>/2019/8/30/Java%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99/</url>
    
    <content type="html"><![CDATA[<ul><li><p>重载</p><p>overload</p><p>在<strong>同一个类</strong>中，方法名字相同，参数不同。</p></li></ul><a id="more"></a><div class="hljs"><pre><code>和返回值没有关系。无法以返回值类型作为重载函数的区分标准。以类的多态性表现。</code></pre></div><ul><li><p>重写</p><p>override (覆盖)</p><p><strong>方法的名字和参数列表被称为方法签名</strong></p><p>如果子类中定义了一个与超类方法签名相同的方法，那么就实现了覆盖或者叫重写。</p><p>即是子类和父类之间的关系。</p><p>注意：</p><ol><li><p>在实现覆盖的时候，子类的方法<strong>不能低于</strong>超类方法的可见性。</p></li><li><p>重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其<strong>子类</strong>；</p></li><li><p>返回类型可以和超类不同，但是必须为超类返回值的<strong>子类</strong>。</p></li><li><p>超类的方法如果用final修饰，则子类不允许覆盖。</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bug记录 -- 前端传值 null</title>
    <link href="/2019/8/27/Bug%E8%AE%B0%E5%BD%95-%E5%89%8D%E7%AB%AF%E4%BC%A0%E5%80%BCnull/"/>
    <url>/2019/8/27/Bug%E8%AE%B0%E5%BD%95-%E5%89%8D%E7%AB%AF%E4%BC%A0%E5%80%BCnull/</url>
    
    <content type="html"><![CDATA[<p>在后台开发经常会遇到的一个需求：</p><p>用户输入id，我们就根据这个id去数据库里面找相应的数据。</p><!-- more --><p>但是，用户还可以选择在id的同时传入一段时间，（start和end）在这段时间内查找数据。</p><p>甚至，用户还可以选择第三个条件上传者uploader，需要我们同时根据id，时间，和上传者三个条件同时查找数据。</p><p>不过解决方法其实很简单，我们不需要在java程序里进行复杂的条件判断到底哪几个条件为空，在每个条件下单独写sql语句。</p><p>我们只需要在mybatis的mapper.xml里，进行if判断即可。</p><div class="hljs"><pre><code class="hljs xml">select *from tableNamewhere id = #&#123;id,jdbcType = INTEGER&#125;<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">"start!=null and start !='' and end !=null and end != ''"</span>&gt;</span>and date between #&#123;start,jdbcType=TIMESTAMP&#125; and #&#123;end,jdbcType=TIMESTAMP&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">uploader!</span>=<span class="hljs-string">null</span> <span class="hljs-attr">and</span> <span class="hljs-attr">uploader</span>!=<span class="hljs-string">''</span> "&gt;</span>and uploader = #&#123;uploader,jdbcType=VARCHAR&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></code></pre></div><p>这样，如果用户输入的某一个条件为空，那么就不会用于sql的条件判断里。</p><p>经过测试事实也的确是这样</p><p>当前端传了uploader=，后面没有值的时候，没有问题</p><div class="hljs"><pre><code class="hljs json">&#123;    id: 1    uploader:&#125;</code></pre></div><p>当前端不传uploader，也没有问题</p><div class="hljs"><pre><code class="hljs json">&#123;    id:1&#125;</code></pre></div><p><strong>但是！！！！</strong></p><p>当前端传的是</p><div class="hljs"><pre><code class="hljs json">&#123;    id:1    uploader:null&#125;</code></pre></div><p>这时传入的就是null这个<strong>字符串</strong>!!!</p><p>虽然前端返回的<strong>的的确确返回的就是<code>null(空)</code></strong>，但是后台在接收的时候就变成了**<code>null(字符串)</code>**</p><p>由此，我们可以大胆的把if判断改成如下格式</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">'uploader != "null" and uploader!=null and uploader!="" '</span>&gt;</span>and uploader = #&#123;uploader,jdbcType=VARCHAR&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></code></pre></div><p>注意单双引号有所改变</p><hr><p>还有一个很坑的点，后台时间参数是Date类型时，传入的必须是<code>2019/08/27 23:26:41</code>这样的时间格式</p><p>而传入参数为<code>2019-08-27 23:26:41</code>时，后台就必须为String类型的，否则会出现参数不匹配的错误(MisMatch)</p><p>而且，当参数是String时，无需担心和Date类型不匹配，直接传入String到mapper.xml里，不过记得jdbcType还是写TIMESTAM即可。可能mybatis框架会有优化吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2019/8/27/%E5%BC%82%E5%B8%B8/"/>
    <url>/2019/8/27/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>异常的几种类型:</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Chao-Yin-Github/PersonalResourcePlan/master/picture/TypeOfException.png" srcset="/img/loading.gif" alt="异常的几种类型"></p><p>以旅行实例说明异常的分类：</p><ul><li><p>武汉发生地震，属于不可抗因素，对应**<code>Error</code>**错误，这个我们根本想不到具体发生的原因。例如，突然没有权限往硬盘上写数据的能力了。这种就只能老老实实的把错误信息返回（如果有的话），程序无法处理。</p></li><li><p>堵车，或者航班延误，属于异常**<code>Exception</code><strong>，确切来说属于异常中的</strong><code>checked</code>**，即受检异常，对于这种异常，我们虽然可以预料，但是预料到了也无能为力，只有监测并关注。</p></li><li><p>没有带驾驶证，或者忘记机票，属于异常中的**<code>unchecked</code><strong>类型。具体则属于</strong>可预测的异常**这些完全可以预测并且返回相应的提示。</p></li><li><p>需捕捉异常，例如:汽车抛锚，我们就需要采取公共汽车作为解决的方式</p></li><li><p>检票机坏掉了，属于可透出异常，交由航空公司处理即可，我们无法处理。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bug 记录 -- Maven 错误记录合集</title>
    <link href="/2019/8/25/Bug%E8%AE%B0%E5%BD%95-Maven-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%E5%90%88%E9%9B%86/"/>
    <url>/2019/8/25/Bug%E8%AE%B0%E5%BD%95-Maven-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ul><li><p>运行mvn package提示-source 1.5，编译失败</p>  <!-- more --><p>设置maven中的Java版本为8</p>  <div class="hljs"><pre><code class="hljs shell">sudo vim /opt/maven/conf/setting.xml</code></pre></div><p>找到注释掉的example—profile，或者直接在最后添加</p>  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>JDK1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span></code></pre></div></li><li><p>java -jar maven打包后的jar文件，提示没有主清单程序</p><p>这是因为项目中有多个main函数入口，这样就必须在pom文件中指明主程序入口。</p>  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">transformers</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span> <span class="hljs-attr">implementation</span>=<span class="hljs-string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.example.project.mianApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">transformers</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>其中<code>com.example.project</code>是入口类所在的包名，即<code>groupId</code>和<code>artifactID</code>拼接而成的结果</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis使用</title>
    <link href="/2019/8/22/Mybatis%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/8/22/Mybatis%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="idea下使用Spring-Boot-搭建Mybatis框架"><a class="header-anchor" href="#idea下使用Spring-Boot-搭建Mybatis框架">⚡</a>idea下使用Spring Boot 搭建Mybatis框架</h2><a id="more"></a><ul><li><p>添加maven依赖</p></li><li><p>在application.properties文件中，添加Mybatis的配置：</p>  <div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">mybatis.config-location=classpath:mybatis-config.xml</span></code></pre></div></li><li><p>在resources下新建mybatis-config.xml，具体配置请见文件。</p></li><li><h2 id="parameter-和-parameter-的区别"><a class="header-anchor" href="#parameter-和-parameter-的区别">⚡</a>#{parameter} 和 ${parameter} 的区别</h2><p><strong>#是占位符号，$是拼接符号</strong></p><ol><li><p>参数预处理</p><ul><li><p><code>#</code> 将传入的数据当成一个字符串，会自动对传入数据<strong>加双引号</strong></p></li><li><p><code>$</code> 将传入的数据直接显示，而不处理</p></li></ul></li><li><p>sql注入</p><ul><li><p><code>$</code> 不能防止sql注入</p></li><li><p><code>#</code> 可以防止sql注入</p></li></ul></li><li><p><strong><code>$</code></strong> 一般用于传入<strong>数据库对象</strong>，例如表名、列名</p></li><li><p>尽量使用<code>#</code></p></li><li><p>order by动态参数需要用<code>$</code></p></li></ol></li><li><h2 id="trim"><a class="header-anchor" href="#trim">⚡</a>trim</h2></li></ul><table><thead><tr><th style="text-align:center">trim的几个属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">prefix</td><td style="text-align:center">当 trim 元素包含有内容时， 增加 prefix 所指定的前缀</td></tr><tr><td style="text-align:center">prefixOverrides</td><td style="text-align:center">当 trim 元素包含有内容时， 去除 prefixOverrides 指定的 前缀</td></tr><tr><td style="text-align:center">suffix</td><td style="text-align:center">当 trim 元素包含有内容时， 增加 suffix 所指定的后缀</td></tr><tr><td style="text-align:center">suffixOverrides</td><td style="text-align:center">当 trim 元素包含有内容时， 去除 suffixOverrides 指定的后缀</td></tr></tbody></table><p>下面的语句表示为：trim标签中有内容时，添加 where ，而当第一个为and 或者 or 时，会把 and 或者 or 去掉。而如果trim标签中没有内容，则不会添加where语句。(此语句和<where> 标签等价)</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"where"</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">"AND | OR"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre></div><p>同理，还有类似<set> 标签的trim</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"set"</span> <span class="hljs-attr">suffiexOverrides</span>=<span class="hljs-string">","</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre></div><p>当trim中有内容时，添加set，当最后一个为<code>,</code>时，去掉它。</p>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SwaggerUI</title>
    <link href="/2019/8/20/SwaggerUI/"/>
    <url>/2019/8/20/SwaggerUI/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="SwaggerUI简述"><a class="header-anchor" href="#SwaggerUI简述">⚡</a>SwaggerUI简述</h2><p>Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件</p>  <a id="more"></a><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>总体目标是使客户端和文件系统作为服务器以同样的速度来更新。</p><p>文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步</p></li><li><h2 id="Spring-Boot-Maven-依赖"><a class="header-anchor" href="#Spring-Boot-Maven-依赖">⚡</a>Spring Boot Maven 依赖</h2>  <div class="hljs"><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!--swagger2--&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><h2 id="配置"><a class="header-anchor" href="#配置">⚡</a>配置</h2><p>在configuration包下，新建SwaggerUIConfiguration</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*在类上加入注解*/</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-meta">@Configuration</span><span class="hljs-comment">/* 控制swagger是否开启，当application.properties设置中swagger.enable=true,即符合havingValue的期望值时配置生效 */</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"swagger"</span>, value = &#123;<span class="hljs-string">"enable"</span>&#125;, havingValue = <span class="hljs-string">"true"</span> )<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerUIConfiguration</span></span>&#123;<span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestfulApi</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)        .apiInfo(apiInfo())        .select()        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.example"</span>))        .paths(PathSelectors.any())        .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()        .titile(<span class="hljs-string">"title"</span>)        .description(<span class="hljs-string">"====================\n"</span>        +<span class="hljs-string">"项目名称:xxx\n"</span>        +<span class="hljs-string">"项目分支:xxx\n"</span>        +<span class="hljs-string">"项目成员:xxx\n"</span>            +<span class="hljs-string">"====================\n"</span>            +<span class="hljs-string">"项目简介:后端采用Spring Boot + Mybatis框架,使用Mysql数据库\n"</span>        +<span class="hljs-string">"====================\n"</span>        +<span class="hljs-string">"注意事项:\n"</span>        +<span class="hljs-string">"1. 后端服务端口号:xxx\n"</span>        +<span class="hljs-string">"2. develop分支为开发版本,master分支为稳定版本\n"</span>        +<span class="hljs-string">"3. 每次提交认真写git commit\n\n"</span>        +<span class="hljs-string">"====================\n"</span>)        .termsOfServiceUrl(<span class="hljs-string">""</span>)        .version(<span class="hljs-string">"1.0"</span>)        .build();    &#125;&#125;</code></pre></div></li><li><h2 id="注解介绍"><a class="header-anchor" href="#注解介绍">⚡</a>注解介绍</h2></li></ul><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">@Api</td><td style="text-align:center"></td><td style="text-align:center">用在Contoller控制器类上,标志这个类是Swagger的资源</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">value</td><td style="text-align:center">[没有效果]</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">tags</td><td style="text-align:center">控制器说明</td></tr><tr><td style="text-align:center">@ApiOperation</td><td style="text-align:center"></td><td style="text-align:center">用在接口方法上,描述方法的作用</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">value</td><td style="text-align:center">方法说明</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">note</td><td style="text-align:center">增加说明</td></tr><tr><td style="text-align:center">@APiImplicitParams</td><td style="text-align:center"></td><td style="text-align:center">用在接口方法上,包装器,用{}包含多个ApiImplicitParam</td></tr><tr><td style="text-align:center">@ApiImpicitParam</td><td style="text-align:center"></td><td style="text-align:center">定义在ApiImplicitParams内  ,描述单个参数的详细信息</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">ParamType</td><td style="text-align:center">获取参数的位置</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">header -&gt; @RequestHeader</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">query -&gt; @RequestParam</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">path -&gt; @PathVariable</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">body: 以流的形式提交,进支持post</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">form: 以form表单形式提交,仅支持post</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">name</td><td style="text-align:center">参数名</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">dataType</td><td style="text-align:center">参数的数据类型,有<strong>Long</strong> 和String，但是用Long会出现格式错误问题，所以数字统一也用String</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">required</td><td style="text-align:center">是否为必须参数true/false</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">value</td><td style="text-align:center">参数说明</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">defaultValue</td><td style="text-align:center">参数默认值</td></tr><tr><td style="text-align:center">@ApiResponses</td><td style="text-align:center"></td><td style="text-align:center">用在接口方看法上,用{}包含多个@ApiResonse</td></tr><tr><td style="text-align:center">@ApiResponse</td><td style="text-align:center"></td><td style="text-align:center">表示一个错误信息</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">code</td><td style="text-align:center">状态码[200、201、403、404、500等]</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">message</td><td style="text-align:center">状态信息</td></tr><tr><td style="text-align:center">@ApiModel</td><td style="text-align:center"></td><td style="text-align:center">用在类上,描述对象的作用</td></tr><tr><td style="text-align:center">@ApiModelProperty</td><td style="text-align:center"></td><td style="text-align:center">描述对象中字段的作用 ,一般用在请求对象或者返回结果对象</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 知识 -- 注解 -- @Resource 和 @Autowired</title>
    <link href="/2019/7/28/Spring-%E7%9F%A5%E8%AF%86-%E6%B3%A8%E8%A7%A3-@Resource-%E5%92%8C-@Autowired/"/>
    <url>/2019/7/28/Spring-%E7%9F%A5%E8%AF%86-%E6%B3%A8%E8%A7%A3-@Resource-%E5%92%8C-@Autowired/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="相同点："><a class="header-anchor" href="#相同点：">⚡</a>相同点：</h2><ol><li><p>都是bean注入时使用</p></li><li><p>二者都可以写在字段上用来消除Setter和Getter方法</p></li><li><p>也可以写在Setter方法上</p></li></ol></li></ul><a id="more"></a><ul><li><h2 id="不同点："><a class="header-anchor" href="#不同点：">⚡</a>不同点：</h2><ol><li><h3 id="包"><a class="header-anchor" href="#包">⚡</a>包</h3><p>@Resource 是属于Java EE的，在Javax包下</p><p>@Autowired 是属于Spring boot的</p></li><li><h3 id="自动装配的类型-Resource"><a class="header-anchor" href="#自动装配的类型-Resource">⚡</a>自动装配的类型-<code>@Resource</code></h3><p>@Resource 默认按照byName注入，但也可以用byType注入</p><p>spring将其注解的name属性解析为bean的名字，而type属性解析为bean的类型。</p><ol><li><p>若同时指定了name和type属性，则从spring上下文中找到唯一的匹配的bean进行装配，找不到则抛出异常。</p></li><li><p>如果指定了name，则从上下文中查找名称（id）匹配的bean，找不到同上。</p></li><li><p>如果指定了type，则从上下文中查找类似匹配的bean，找不到或者<strong>找到多个</strong>都会抛出异常。</p></li><li><p>如果既不指定name，也不指定type，这时将通过反射机制使用默认的byName，没有匹配则退为一个原始类型进行匹配。</p></li></ol></li><li><h3 id="自动装配的类型-Autowired"><a class="header-anchor" href="#自动装配的类型-Autowired">⚡</a>自动装配的类型-<code>@Autowired</code></h3><p>默认通过byType自动注入，如果 byType 找不到或者找到了多个，则通过属性的 byName 注入，如果 byName 也找不到，则报错。</p><p>默认情况下它要求依赖的对象必须存在，如果允许 null，则可以将它的 required 属性设置为 false。</p><p>如果想按照名字来自动装配，则需结合 <code>@Qulifier</code> 注解使用：</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-meta">@Qulifier</span>(<span class="hljs-string">"userDao"</span>)<span class="hljs-keyword">private</span> UserDao userDao;</code></pre></div></li></ol></li></ul><p>个人感觉用Autowired会更整齐，而且也方便。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok</title>
    <link href="/2019/7/27/Lombok/"/>
    <url>/2019/7/27/Lombok/</url>
    
    <content type="html"><![CDATA[<ul><li><p>@Setter、@Getter、@ToString、@NonNull</p></li><li><p>@NoArgsConstructor、@AllArgsConstructor</p>  <a id="more"></a><p>有final修饰的变量无法使用NoArgsConstructor</p></li><li><p>@RequiredConstructor</p><p>生成类中所有@NonNull注释或者是final修饰的变量的构造函数</p><p>三种注释都不能用在含有静态数据成员的类上</p></li><li><p>@Data</p><p>包含了以下注解：</p><p>@Setter、@Getter、@ToString、@equals、@hashCode</p></li><li><p>@value与@Data类似，只不过前者会把所有变量没，默认为pirvate final，并且不会生成setter方法(final不可修改)。</p></li><li><p>@SneakyThrows: 捕获异常。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Commit 规范</title>
    <link href="/2019/7/14/Git-Commit-%E8%A7%84%E8%8C%83/"/>
    <url>/2019/7/14/Git-Commit-%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="git-commit-规范"><a class="header-anchor" href="#git-commit-规范">⚡</a>git commit 规范</h2><ul><li><p>Header</p><p>type (scope) : subject</p>  <a id="more"></a><p>type的几种类型</p><ul><li><p>feat: 新功能</p></li><li><p>fix: 修补bug</p></li><li><p>docs: 文档</p></li><li><p>style: 格式</p></li><li><p>refactor: 重构</p></li><li><p>test: 测试</p></li><li><p>chore: 构建工程或者辅助工具的变动</p></li></ul><p>subject:</p><ul><li><p>以动词开头，使用<strong>第一人称现在时</strong></p></li><li><p>第一个字母小写</p></li><li><p>结尾不加符号</p></li></ul></li><li><p>Body</p></li><li><p>Footer</p><p>适用情况:</p><ul><li><p>不兼容变动</p><p>当前代码和上一个版本不兼容，则以<code>BREAKING CHANGE</code>开头</p></li><li><p>关闭issue</p><p>Closes #123</p><p>关闭123号issue</p></li><li><p>revert</p><p>撤销以前的commit，以<code>revert:</code>开头，后面紧跟着被撤销Commit的Header</p></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+Github Pages搭建博客指南</title>
    <link href="/2019/7/12/hexo-Github%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    <url>/2019/7/12/hexo-Github%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<ol><li><h2 id="hexo-ndoejs安装"><a class="header-anchor" href="#hexo-ndoejs安装">⚡</a>hexo+ndoejs安装</h2><p>hexo:</p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">具体说明请看官方文档</a></p><p>node + npm:</p> <div class="hljs"><pre><code class="hljs shell">sudo pacman -S nodejs npm</code></pre></div><p><a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">npm 权限问题</a></p></li><li><h2 id="主题配置"><a class="header-anchor" href="#主题配置">⚡</a>主题配置</h2><ol><li><p>选择一个主题克隆下来</p><p>例如：<a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">alpha-dust</a></p> <div class="hljs"><pre><code class="hljs shell">git clone https://github.com/klugjo/hexo-theme-alpha-dust themes/alpha-dustgit clone</code></pre></div></li><li><p>修改所需配置</p><ol><li><p>author，discription等等</p></li><li><p>修改favicon</p><ol><li><p><a href="http://www.faviconico.org/favicon" target="_blank" rel="noopener">在线生成ico</a></p></li><li><p>把生成的文件放到 blog/source目录下</p><p>并修改文件名为favicon.ico</p></li><li><p>(并没有效果) 修改blog/_config.yml</p> <div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 增加一行</span><span class="hljs-string">favicon:/favicon.ico</span></code></pre></div></li></ol></li></ol></li><li><p>使用hexo</p><ol><li><p>生成草稿或者新的markdown文件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 生成草稿</span>hexo new draft test<span class="hljs-meta">#</span><span class="bash"> 生成markdown文件</span>hexo new post blog</code></pre></div></li><li><p>将draft草稿发布</p> <div class="hljs"><pre><code class="hljs shell">hexo publish post test</code></pre></div></li><li><p>部到 git</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装插件</span>npm install hexo-deployer-git  --save</code></pre></div></li></ol></li><li><p>插件</p><ul><li><p>live2d</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo npm install hexo-helper-live2d --save</span><span class="hljs-meta">#</span><span class="bash"> shizaku是model的名字</span><span class="hljs-meta">$</span><span class="bash"> sudo npm install live2d-widget-model-shizuku --save</span></code></pre></div><p>_config.yml加入如下配置</p>  <div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># Live2D</span><span class="hljs-comment">## https://github.com/EYHN/hexo-helper-live2d</span><span class="hljs-attr">live2d:</span><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">jsdelivr</span> <span class="hljs-comment"># 默认</span><span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span> <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span> <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span> <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><span class="hljs-comment"># scriptFrom: jsdelivr # jsdelivr CDN</span><span class="hljs-comment"># scriptFrom: unpkg # unpkg CDN</span><span class="hljs-comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span><span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><span class="hljs-attr">model:</span><span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-shizuku</span> <span class="hljs-comment"># npm-module package name</span>    <span class="hljs-attr">scale:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">hHeadPos:</span> <span class="hljs-number">0.5</span>    <span class="hljs-attr">vHeadPos:</span> <span class="hljs-number">0.618</span><span class="hljs-attr">display:</span>    <span class="hljs-attr">superSample:</span> <span class="hljs-number">2</span>    <span class="hljs-attr">width:</span> <span class="hljs-number">125</span>    <span class="hljs-attr">height:</span> <span class="hljs-number">125</span>    <span class="hljs-attr">position:</span> <span class="hljs-string">left</span>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">30</span>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-20</span><span class="hljs-attr">mobile:</span>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">scale:</span> <span class="hljs-number">0.05</span><span class="hljs-attr">react:</span>    <span class="hljs-attr">opacityDefault:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">opacityOnHover:</span> <span class="hljs-number">0.2</span></code></pre></div><p>想要其他的model可以去<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">官方博客找</a></p></li><li><p>Browsersync 实时预览编辑</p>  <div class="hljs"><pre><code class="hljs shell">npm install hexo-browsersync --save</code></pre></div></li><li><p>hexo-deployer-shell 同步服务器</p>  <div class="hljs"><pre><code class="hljs shell">npm install hexo-deployer-shell --save</code></pre></div><p>修改 root 的 _config.yml</p>  <div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">shell</span>  <span class="hljs-attr">command:</span> <span class="hljs-string">&lt;your</span> <span class="hljs-string">deploy</span> <span class="hljs-string">command&gt;</span>  <span class="hljs-attr">options:</span>  <span class="hljs-attr">timeout:</span> <span class="hljs-number">2000</span></code></pre></div></li><li><p><a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">置顶</a></p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm uninstall hexo-generator-index --save</span><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-index-pin-top --save</span></code></pre></div><p>如果要置顶,就在文章首的 font-matter 里面添加:<br>top: True</p></li><li><p>markdown 脚注</p><p><a href="https://github.com/hexojs/hexo-renderer-markdown-it" target="_blank" rel="noopener">换新的引擎</a></p>  <div class="hljs"><pre><code class="hljs shell">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save</code></pre></div><p>可选的配置</p>  <div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">markdown:</span>    <span class="hljs-attr">render:</span>        <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span>        <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">linkify:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">typographer:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">quotes:</span> <span class="hljs-string">'“”‘’'</span>    <span class="hljs-attr">plugins:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-ins</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span>    <span class="hljs-attr">anchors:</span>    <span class="hljs-attr">level:</span> <span class="hljs-number">2</span>    <span class="hljs-attr">collisionSuffix:</span> <span class="hljs-string">'v'</span>    <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">permalinkClass:</span> <span class="hljs-string">'header-anchor'</span>    <span class="hljs-attr">permalinkSide:</span> <span class="hljs-string">'left'</span>    <span class="hljs-attr">permalinkSymbol:</span> <span class="hljs-string">'⚡'</span>    <span class="hljs-attr">case:</span> <span class="hljs-number">0</span>    <span class="hljs-attr">separator:</span> <span class="hljs-string">''</span></code></pre></div><p>换了引擎还要 clean 一下</p><p><a href="https://zhanghuimeng.github.io/post/add-footnote-plugin-for-hexo-blog/" target="_blank" rel="noopener">参考博客</a></p></li><li><p><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">RSS</a></p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-feed --save</span></code></pre></div><p>对于 fluid 主题,我们可以在关于页里面修改 icons 支持 rss,link 就写 <code>/atom.xml</code></p></li><li><p><a href="https://github.com/HCLonely/hexo-online-server" target="_blank" rel="noopener">hexo-online-server</a></p><p>在线编辑</p><p>坑(2020.4.17版本):</p><ol><li><p>展示的配置注释要删</p></li><li><p>配置里面的 secret 要随便输一些东西,否则会报错:</p><p>Error: secret option required for sessions</p></li></ol></li></ul></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用指令</title>
    <link href="/2019/7/11/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2019/7/11/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ol><li><p>从本地上传文件到服务器</p> <a id="more"></a> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> scp -r /home/yysir/dist java@ip:/tmp</span></code></pre></div><p>即可将本地dist文件夹上传到服务器的tmp文件夹下，</p><p>然后即可连接服务器将文件移动到相应文件夹中【因为目标文件夹可能没有写入权限，所以先放入具有全部权限的tmp文件夹下，再进行移动】</p></li><li><p>从服务器下载文件到另一服务器或者本机</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">注意：这是在服务器端，要求必须要有公网ip才能传到对应电脑，否则，只能先退出服务器，在本机然后再从服务器上下载文件。</span><span class="hljs-meta">$</span><span class="bash"> scp java@ip:/tmp/test.txt yysir@ip:/home/yysir/Download</span></code></pre></div></li><li><p>查看服务器图片</p><p>python3:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python -m http.server 8080</span></code></pre></div><p>python2:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python -m simpleHTTPServer 8080</span></code></pre></div><p>如果服务器8080端口防火墙打开了的话，在浏览器输入服务器的ip地址和端口，即可在本地查看服务器的图片。</p> <!-- more --></li><li><p>rar解压</p><p>linux没有直接解压rar的功能，先去<a href="https://www.rarlab.com/download.htm" target="_blank" rel="noopener">rarlab下载</a></p><p>解压到/opt目录下，进入rar文件夹，<code>sudo make</code>即可</p><p>语法：</p><p>unrar x [fileName] 解压</p><p>rar a [rarName.rar] fileName</p></li><li><p>ubuntu下开启防火墙端口</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo su</span><span class="hljs-meta">#</span><span class="bash">开启8080端口</span><span class="hljs-meta">$</span><span class="bash"> iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /etc/network/</span><span class="hljs-meta">#</span><span class="bash">目录下如果没有iptables.up.rules</span>iptables-save &gt;/etc/network/iptables.up.rules<span class="hljs-meta">$</span><span class="bash"> vim iptables.up.rules</span><span class="hljs-meta">#</span><span class="bash">把新加入的8080端口新加入的那一行移动到合适位置【其实直接将第一行命令加到这里相应位置就可以】</span><span class="hljs-meta">#</span><span class="bash"> accept一定要放到reject的前面!!</span><span class="hljs-meta">$</span><span class="bash"> iptables-apply</span><span class="hljs-meta">#</span><span class="bash">检查程序是否运行中，端口是否开启</span><span class="hljs-meta">#</span><span class="bash">特别的，在沸点的项目需要向学校申请开放端口</span></code></pre></div></li><li><p>命令行下查看wifi</p> <div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有wifi</span>$ nmcli device wifi list<span class="hljs-comment"># 连接wifi</span>$ nmcli device wifi connect <span class="hljs-string">'SSID'</span> password <span class="hljs-string">'password'</span><span class="hljs-comment"># 显示一个所有连接过网络的UUID列表</span>$ nmcli connection show<span class="hljs-comment"># 查看所有的网络设备和状态</span>$ nmcli device</code></pre></div></li><li><p>查看端口</p><ol><li><p>查看端口是否被占用：【注意<strong>root权限</strong>】</p><ul><li>netstat -anp |grep 8080</li><li>lsof -i:8080</li></ul></li><li><p>查看端口是否在防火墙放行</p><ul><li><p>netstat -ntpl【tcp类型端口】</p></li><li><p>netstat -nupl【udp类型端口】</p></li><li><p>/sbin/iptables -L -n</p></li><li><p>telnet ip【ip地址】 port【端口】</p></li><li><p>可以连接则显示</p>  <div class="hljs"><pre><code class="hljs bash">Trying ip ...Connected to ip...Escape character is <span class="hljs-string">'^]'</span>.</code></pre></div><p>输入’]'后，进入telnet,键入quit退出</p></li><li><p>不能连接则显示</p>  <div class="hljs"><pre><code class="hljs bash">Trying ip...telnet: connect to address ip: No route to host</code></pre></div></li></ul></li></ol></li><li><p>内网穿透</p><p>我如果连接外网时连接内网的主机,输入192.168.1.110这样的内网ip肯定是无法连接的,这样就需要内网穿透</p><ol><li><p>方案一:</p><p>用有公网ip的服务器,搭建ngrok进行内网穿透,这个就需要买服务器,然后自己搭ngrok了。我现在暂时还用不到服务器,就没有采取这个方案。</p></li><li><p>方案二:</p><p>用ngrok现成的，<a href="https://dashboard.ngrok.com/get-started" target="_blank" rel="noopener">官网</a> 注册一个帐号，下载zip文件，解压到opt</p> <div class="hljs"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /opt<span class="hljs-comment"># 安装screen使ngrok可以在后台运行</span>$ sudo pacman -S screen<span class="hljs-comment"># 启动screen,-S 后面的ngrok就是一个名字而已</span>$ screen -S ngrok<span class="hljs-comment"># 开启ssh默认的22端口</span>./ngrok tcp 22<span class="hljs-comment"># 记下端口和host</span><span class="hljs-comment"># 看到启动成功后，按下 ctl+A+D，使ngrok在后台运行</span><span class="hljs-comment"># 连接外网测试ssh</span>$ ssh -p prot yysir@0.tcp.ngrok.io</code></pre></div><hr><p>更新：</p><p>我必须在本机的命令行开一个命令行界面才能连上，否则有迷之网络连接失败</p></li></ol></li><li><p>在服务器上后台运行程序</p><blockquote><p>前些时候（大概四到五月份）做帐号中心的项目，才开始真正熟悉Linux的各种操作和Spring Boot的学习。具体踩过的坑一时半会都说不完。不过今天又发现了一些新的问题值得记录一下⬇</p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 之前仅仅是用 &gt;file 来重定向输出文件，还有 &amp; 来保持程序后台运行，具体命令如下：</span><span class="hljs-meta">$</span><span class="bash"> java -jar demo-SNAPSHOT.jar &gt;accountcenter.out &amp;</span></code></pre></div><p>可是最近发现每过一段时间(大概一个月左右)，程序就会自动停止，然后我就又不得不重新连服务器，把后台提起来。</p><p>今天上网查了查，找到一个可能的疏漏：要用nohup来保持程序后台运行<br>（具体不确定，站坑，等过一个月再来答）</p><p>(过了好久，终于填坑，果然是需要nohup)</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nohup java -jar demo-SNAPSHOT.jar &gt;accountcenter.out &amp;</span></code></pre></div></li><li><p>nginx</p><ol><li><p>安装：</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S nginx</span></code></pre></div></li><li><p>开启服务&amp;测试</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl status nginx</span><span class="hljs-meta">$</span><span class="bash"> sudo systemctl start nginx</span><span class="hljs-meta">$</span><span class="bash"> sudo nginx -t</span></code></pre></div><p>如果测试出现如下错误：</p><blockquote><p>nginx: [warn] could not build optimal types_hash, you should increase either types_hash_max_size: 2048 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size</p></blockquote><p>解决方案：</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/nginx/nginx.conf</span></code></pre></div><p>在http模块下，server子模块前，添加如下配置:</p><blockquote><p>types_hash_max_size 2048;<br>server_names_hash_max_size 2068;<br>types_hash_bucket_size 1024;</p></blockquote> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重启</span><span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart ngxin</span><span class="hljs-meta">#</span><span class="bash">测试</span><span class="hljs-meta">$</span><span class="bash"> sudo nginx -t</span><span class="hljs-meta">#</span><span class="bash">出现以下提示即可：</span><span class="hljs-meta">#</span><span class="bash">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><span class="hljs-meta">#</span><span class="bash">nginx: configuration file /etc/nginx/nginx.conf <span class="hljs-built_in">test</span> is successful</span></code></pre></div><p><a href="http://127.0.0.1" target="_blank" rel="noopener">本地nginx主页</a></p></li><li><p>配置反向代理</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/nginx/nginx.conf</span></code></pre></div><p>&lt;一、通过域名访问&gt;<br>添加如下配置</p> <div class="hljs"><pre><code class="hljs xml">server &#123;    listen 80;    server_name yinchao;    root /opt/BlogFile/.deploy_git    location /&#123;        index index.html;        try_files $uri $uri/ /index.html;    &#125;&#125;</code></pre></div><p>&lt;二、通过端口访问&gt;</p> <div class="hljs"><pre><code class="hljs xml">server &#123;    listen 8888;    server_name localhost;    root ~;    location / &#123;        index ~;        try_files $uri $uri/ ~;    &#125;&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs shell">sudo systemctl restart nginx</code></pre></div><p>即可通过http://yinchao/ 或localhost:8888访问。</p></li></ol><ul><li><p>前端部署的坑：</p><ul><li><p>如果是vue等可以用</p>   <div class="hljs"><pre><code class="hljs shell">npm run build</code></pre></div><p>命令打包为dis文件的，直接就可以了</p></li><li><p>如果是原生的html+css+javascript</p><p>就要把文件归类，html平行的就是css和js</p><p>而且nginx的配置文件要配置好</p><blockquote><p>从昨天22：30到夜里1点多，再从今天早上9：20到下午1点，终于把这个原生页面部署上去了😩</p></blockquote></li></ul></li></ul></li><li><p>查看文件编码</p><div class="hljs"><pre><code class="hljs shell">file fileName<span class="hljs-meta">#</span><span class="bash"> 还可以错略通过换行符判断Windows/Unix系统</span></code></pre></div></li><li><p>数据库备份和还原</p><p>备份：</p><div class="hljs"><pre><code class="hljs shell">mysqldump -uroot -proot databaseName &gt; databasesName.sql;</code></pre></div><p>还原的前提：必须先建立database，然后才能在其中添加数据,否则会报错</p><div class="hljs"><pre><code class="hljs shell">mysql -uroot -proot databaseName &lt; databaseName.sql;</code></pre></div></li><li><p>网络相关</p><ol><li><p>www和不加www域名的区别：</p><p>前者是后者的子域名</p><p>后者被称为裸域名,好处是简短容易记忆，常见于个人博客等。坏处是不能把裸域设定为另外域名的别名等<a href="https://www.zhihu.com/question/20414602" target="_blank" rel="noopener">详情见知乎</a>。</p></li></ol></li><li><p>ls命令</p><ul><li><p>按文件大小进行排序</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls -hlSa</span></code></pre></div><p>-a: --all</p><p><code>-h</code>:–human-readable，显示人类可读的文件大小</p><p><code>-S</code>:以文件大小降序方式排序</p><p><strong><code>-r</code></strong>:–reverse，反向排序</p></li><li><p>按文件时间顺序排序</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls -hlta</span></code></pre></div><p><code>-t</code>: sort by modification time,newest first，即按修改时间对文件进行<strong>降序</strong>排序</p></li></ul></li><li><p>命令记录</p><ul><li><p><code>ldd</code> [path]: 查看依赖库</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ldd /usr/bin/mysqld</span></code></pre></div><p>注意要写<strong>完整路径</strong>,如果写成<br>$ ldd mysql<br>会提示mysql NOT FOUND</p></li><li><p><code>LD_DEBUG=libs</code> [path]:</p><blockquote><p>LD_DEBUG 是 glibc 中的 loader 为了方便自身调试而设置的一个环境变量。<br>通过设置这个环境变量，可以方便的看到 loader 的加载过程,使用ldd命令可以知道程序依赖于哪些库。<br>在找不到这些库的时候，使用LD_DEBUG可以知道系统在哪些路径下进行了尝试</p></blockquote></li></ul></li><li><p>gitlab</p><p>昨天（2019.8.18）程时坤重启了 gitlab 500的错误，但是没办法用ssh克隆导致我晚上调了很久，最后发现是url不对!!!</p><p>应该是 <a href="http://xn--rcaaa.edu.cn" target="_blank" rel="noopener">×××.edu.cn</a>，结果现在的url为 <a href="http://xn--rcaaa.edu.cn.com" target="_blank" rel="noopener">×××.edu.cn.com</a>，然后用ssh克隆就一直提示需要使用密码。</p><p>解决办法：</p><div class="hljs"><pre><code class="hljs ssh"># 登上服务器,获取超级用户权限$ ssh feidian$ sudo su# 进入gitlab配置目录,进行相应配置$ cd &#x2F;etc&#x2F;gitlab$ vim gitlab.rb# 发现external_url是&#39;http:&#x2F;&#x2F;git.feidian.hzau.edu.cn.com&#39;# 修改,把最后的.com去掉即可# 更坑的来了,之前在网上找到的命令是 gitlab-ctl reconfigure,执行之发现刚刚修改的gitlab.rb的数据被重置了!!!# 尝试多次发现show-config才是正确的$ gitlab-ctl show-config# 成功</code></pre></div></li><li><p>banner</p><ul><li><p>生成banner</p></li><li><p>登录前banner:</p></li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/issue</span></code></pre></div><div class="hljs"><pre><code class="hljs properties"><span class="hljs-attr">Manjaro</span> <span class="hljs-string">Linux \r  </span><span class="hljs-attr">server</span> <span class="hljs-string">name: (\n) </span><span class="hljs-attr">user</span>: <span class="hljs-string">(\l)</span><span class="hljs-attr">version</span>: <span class="hljs-string">(\v)</span><span class="hljs-attr">OS</span> <span class="hljs-string">Name:(\s)</span><span class="hljs-attr">time</span>: <span class="hljs-string">(\t)</span><span class="hljs-attr">hard</span> <span class="hljs-string">ware level: (\m)</span></code></pre></div><ul><li>登录后banner</li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/motd</span></code></pre></div><div class="hljs"><pre><code class="hljs properties">  <span class="hljs-attr">___</span>    <span class="hljs-string">___  ___      ________           ________      ___  ___      ________      ________     </span> <span class="hljs-meta">|\ </span> <span class="hljs-string">\  /  /||\  \    |\   ___  \        |\   ____\    |\  \|\  \    |\   __  \    |\   __  \    </span> <span class="hljs-attr">\ \ </span> <span class="hljs-string">\/  / /\ \  \   \ \  \\ \  \       \ \  \___|    \ \  \\\  \   \ \  \|\  \   \ \  \|\  \   </span>  <span class="hljs-attr">\ \ </span>   <span class="hljs-string">/ /  \ \  \   \ \  \\ \  \       \ \  \        \ \   __  \   \ \   __  \   \ \  \\\  \  </span>   <span class="hljs-attr">\/</span>  <span class="hljs-string">/  /    \ \  \   \ \  \\ \  \       \ \  \____    \ \  \ \  \   \ \  \ \  \   \ \  \\\  \ </span> <span class="hljs-meta">__/</span>  <span class="hljs-string">/ /       \ \__\   \ \__\\ \__\       \ \_______\   \ \__\ \__\   \ \__\ \__\   \ \_______\</span><span class="hljs-meta">|\___/</span> <span class="hljs-string">/         \|__|    \|__| \|__|        \|_______|    \|__|\|__|    \|__|\|__|    \|_______|</span><span class="hljs-attr">\|___|/</span></code></pre></div></li><li><p>根据端口号直接杀死进程</p><div class="hljs"><pre><code class="hljs shell">fuser -k -n tcp 8099</code></pre></div></li><li><p>获取日志中一定范围的</p> <div class="hljs"><pre><code class="hljs java">cat 日志 | grep -E <span class="hljs-string">'2018:2[0-2]:[0-9][0-9]:[0-9][0-9]'</span></code></pre></div></li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>shellCommand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro安装手记</title>
    <link href="/2019/7/11/Manjaro%E5%AE%89%E8%A3%85%E6%89%8B%E8%AE%B0/"/>
    <url>/2019/7/11/Manjaro%E5%AE%89%E8%A3%85%E6%89%8B%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="安装-设置"><a class="header-anchor" href="#安装-设置">⚡</a>安装&amp;设置</h2></li></ul><ol><li><p>安装manjaro</p> <a id="more"></a><ol><li><p>在官网下载<strong>gnome</strong>版本.iso文件</p></li><li><p>用rufus刻录</p><p><strong>注意</strong>:在开始刻录是选择刻录方式为<strong>DD模式!</strong>,而不是一般的iso!</p></li><li><p>进入安装,在grub界面将</p><p><code>语言</code>为中文</p><p><code>Driver</code>设置<strong>no-free</strong></p><p>在<code>boot</code>那一行按<code>e</code> 确认nouveau.modeset=0来禁用开源nouveau驱动</p><p>如果进不去桌面,还要在quit 后面 加上</p> <div class="hljs"><pre><code class="hljs shell">acpi_osi=! acpi_osi='Windows 2009'</code></pre></div><p>否则无法驱动独立显卡</p></li><li><p>等待安装</p></li><li><p>安装完成,重启进入manjaro时注意也要在grub界面修改acpi</p></li><li><p>进入桌面</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">排列并选择软件源</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman-mirrors -i -c China -m rank</span><span class="hljs-meta">#</span><span class="bash">排列源</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman-mirrors -g</span><span class="hljs-meta">#</span><span class="bash"> 安装archlinuxcn-keyring</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S archlinuxcn-keyring</span><span class="hljs-meta">#</span><span class="bash">更新系统</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -Syu</span><span class="hljs-meta">#</span><span class="bash">安装vim</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S vim</span><span class="hljs-meta">#</span><span class="bash">修改grub</span><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/default/grub</span><span class="hljs-meta">#</span><span class="bash">修改为</span>GRUB_CMDLINE_LINUX_DEFAULT="quiet nouveau.modeset=0 systemd.show_status=1 acpi_osi=! acpi_osi='Windows 2009'"<span class="hljs-meta">#</span><span class="bash">查看驱动</span><span class="hljs-meta">$</span><span class="bash"> glxgears</span><span class="hljs-meta">$</span><span class="bash"> mhwd</span><span class="hljs-meta">$</span><span class="bash"> sudo optirun nvidia-settings -c :8</span></code></pre></div></li><li><p>grub rescure</p><p>这次可能是分区位置或者顺序或者方案不对,导致删掉之前预留的20G硬盘里存了manjaro的引导,在windows删除这个预留空间再进入linux显示没找到引导,以下是修复过程</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ls查看设备和磁盘分区</span><span class="hljs-meta">$</span><span class="bash"> ls</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span>查看路径和分区</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">set</span></span><span class="hljs-meta">#</span><span class="bash"> 接下来就是一个个用ls (hdx,gptx)试验,找到Manjaro的引导,这次运气很好,虽然都显示是unknown filesystem,而没有显示住文件夹,但是我没有放弃.我就先试着把root定在了hd2的gpt5下,结果一次就成功了</span><span class="hljs-meta">#</span><span class="bash"> root 指定启动系统分区</span><span class="hljs-meta">$</span><span class="bash"> root=(hd2,gpt5)</span><span class="hljs-meta">#</span><span class="bash"> prefix 设置grub启动路路径</span><span class="hljs-meta">$</span><span class="bash"> prefix=(hd2,gpt5)/boot/grub</span><span class="hljs-meta">#</span><span class="bash"> insmod加载制定模块</span><span class="hljs-meta">$</span><span class="bash"> insmoe normal</span><span class="hljs-meta">$</span><span class="bash"> normal</span><span class="hljs-meta">#</span><span class="bash"> 自动重启,之后就可以看到之前的grub界面了</span><span class="hljs-meta">#</span><span class="bash"> 当然,不能每次都这样吧,进入正常图形界面后,输入一下命令</span><span class="hljs-meta">$</span><span class="bash"> sudo update-grub</span><span class="hljs-meta">#</span><span class="bash"> 当然,这个nvme0n1p5应该是对应上面的gpt5,但是我也不知道到底对不对,好在这次运气真的好,猜的没错,重启之后就没有grub rescure了</span><span class="hljs-meta">$</span><span class="bash"> grub-install /dev/nvme0n1p5</span></code></pre></div></li></ol></li><li><p>解决连接有限网络连接失败问题<code>「玄学」</code></p><ol><li><p>安装以使用ifconfig</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 首先查看网线接口名称,若没有网线插口应该是网卡驱动问题</span><span class="hljs-meta">$</span><span class="bash"> ifconfig</span><span class="hljs-meta">#</span><span class="bash"> 连接网络失败可能是获取不到ip</span><span class="hljs-meta">$</span><span class="bash"> sudo dhclinet enp2s0f1</span></code></pre></div><p>不知道发生了什么就解决了? !</p></li><li><p>快捷键设置</p><ol><li><p>进入设置-&gt;设备-&gt;keyboard,最后添加快捷键</p></li><li><p>名称 terminal ,命令 gnome-terminal ,快捷键<code>Ctrl</code>+<code>Alt</code>+<code>T</code></p><p>名称文件管理器,命令nautilus,快捷键<code>win</code>+<code>e</code></p><p>找到隐藏所有选项,设置快捷键<code>win</code>+<code>D</code></p></li></ol></li><li><p>美化</p><ol><li><p><a href="https://www.gnome-look.org/p/1276072/" target="_blank" rel="noopener">grub主题1:Cyber Security theme</a></p><p>注意Manjaro的grub文件<strong>注释和配置写在一起</strong>,不要以为下面的都是注释!</p></li><li><p>将解压后的文件移动到/boot/grub/themes</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改grub文件</span><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/default/grub</span><span class="hljs-meta">#</span><span class="bash">这一行改为grub界面15秒的选择时间</span><span class="hljs-meta">$</span><span class="bash"> GRUB_TIMEOUT=15</span><span class="hljs-meta">#</span><span class="bash">主题文件路径</span><span class="hljs-meta">$</span><span class="bash"> GRUB_THEME=<span class="hljs-string">"/boot/grub/themes/Cyber-Security/theme.txt"</span></span>        <span class="hljs-meta">#</span><span class="bash">这个分辨率修改为1280x1024是因为作者说明这是最好的分辨率</span><span class="hljs-meta">$</span><span class="bash"> GRUB_GFXMODE=1280x1024</span>        <span class="hljs-meta">#</span><span class="bash">注释掉这一行，否则不会有图形界面</span><span class="hljs-meta">#</span><span class="bash">GRUB_TERMINAL_OUTPUT=<span class="hljs-string">"console"</span></span><span class="hljs-meta">#</span><span class="bash"> 更新grub</span><span class="hljs-meta">$</span><span class="bash"> grub-mkconfig -o /boot/grub/grub.cfg</span><span class="hljs-meta">#</span><span class="bash"> 或者</span><span class="hljs-meta">$</span><span class="bash"> sudo update-grub</span><span class="hljs-meta">#</span><span class="bash">注意如果是是grub2引导，用这个命令</span>grub2-mkconfig -o /boot/efi/EFI/Manjaro/grub.cfg<span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div><p><a href="https://www.opendesktop.org/p/1228974/" target="_blank" rel="noopener">grub主题2链接</a></p><p><a href="https://www.gnome-look.org/p/1220920/" target="_blank" rel="noopener">grub主题3链接</a></p></li><li><p><a href="https://www.gnome-look.org/p/1275087/" target="_blank" rel="noopener">shell: McMojave theme</a></p><p>下载解压到/usr/share/themes即可</p></li><li><p><a href="https://www.gnome-look.org/p/" target="_blank" rel="noopener">鼠标主题 Mac cursor theme</a></p><p>下载解压到/usr/share/icons</p></li><li><p><a href="https://www.gnome-look.org/s/Gnome/p/1305429" target="_blank" rel="noopener">Majave 图标主题</a></p></li></ol></li><li><p>修改中文文件夹名</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span>=en_US</span><span class="hljs-meta">$</span><span class="bash"> xdg-user-dirs-gtk-update</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> LANG=zh_CN.UTF-8</span><span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div></li><li><p>解决没声音问题</p><p><a href="https://blog.csdn.net/juncoder/article/details/39269595" target="_blank" rel="noopener">CSDN</a></p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试是否静音,以及声卡驱动,如果没有异常输出,则证明驱动没有问题</span><span class="hljs-meta">$</span><span class="bash"> amixer sset Master unmute</span><span class="hljs-meta">#</span><span class="bash"> 调整试一下</span><span class="hljs-meta">$</span><span class="bash"> alsamixer</span><span class="hljs-meta">#</span><span class="bash"> 测试有没有声音,能听到分别左右的两个声道的声音就是正常的</span><span class="hljs-meta">$</span><span class="bash"> speaker-test 1.1.3</span><span class="hljs-meta">#</span><span class="bash"> 查看设备,正常输出则驱动正常</span><span class="hljs-meta">$</span><span class="bash"> aplay -l</span><span class="hljs-meta">$</span><span class="bash"> amixer scontrols</span><span class="hljs-meta">#</span><span class="bash"> 如果上面输出没有<span class="hljs-string">"master"</span>,则没有配置</span><span class="hljs-meta">$</span><span class="bash"> amixer -c 0 scontrols</span><span class="hljs-meta">#</span><span class="bash"> 出现<span class="hljs-string">"Master"</span>则正确</span><span class="hljs-meta">$</span><span class="bash"> vim .asoundrc</span>pcm.!default &#123;    type hw    card 0&#125;ctl.!default &#123;    type hw    card 0&#125;<span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div></li><li><p>加入sysrq</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /etc/sysctl.d/</span><span class="hljs-meta">$</span><span class="bash"> sudo vim 99-sysctl.conf</span><span class="hljs-meta">#</span><span class="bash"> 加入内容为:</span><span class="hljs-meta">$</span><span class="bash"> kernel.sysrq = 1</span><span class="hljs-meta">#</span><span class="bash"> 保存重启后,即可用<span class="hljs-string">"busier"</span>命令强制重启</span></code></pre></div></li><li><p>配置默认编辑器</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 用ranger发现默认文本编辑器是nano,想修改为vim</span><span class="hljs-meta">$</span><span class="bash"> vim ~/.zshrc</span>export EDITOR=vim<span class="hljs-meta">#</span><span class="bash"> 重启即可</span></code></pre></div></li><li><p>解决windows双系统时间不一致问题</p><p>(占坑,具体不记得了,只记得点击设置一下就好)</p></li></ol></li></ol><ul><li><h2 id="软件"><a class="header-anchor" href="#软件">⚡</a>软件</h2></li></ul><ol><li><p>输入法:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">安装谷歌拼音</span>sudo pacman -S fcitx-im fcitx-configtool fcitx-googlepinyin<span class="hljs-meta">#</span><span class="bash">创建.xprofile文件</span>vim ~/.xprofile<span class="hljs-meta">#</span><span class="bash">复制加入以下内容</span>export LC_ALL=zh_CN.UTF-8export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx"<span class="hljs-meta">#</span><span class="bash"> 添加emoji表情</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ~/.config/fxitx/data</span><span class="hljs-meta">$</span><span class="bash"> curl -<span class="hljs-comment">#C - -O https://raw.githubusercontent.com/levinit/fcitx-emoji/master/QuickPhrase.mb &amp;&amp; cat ./QuickPhrase.mb &gt;&gt; ~/.config/fcitx/data/QuickPhrase.mb &amp;&amp; rm ./QuickPhrase.mb</span></span><span class="hljs-meta">#</span><span class="bash"> 添加颜文字</span><span class="hljs-meta">$</span><span class="bash"> wget https://raw.githubusercontent.com/rainlime/fcitx-quick-phrase-emoji/master/QuickPhrase.mb &amp;&amp; cat ./QuickPhrase.mb &gt;&gt; ~/.config/fcitx/data/QuickPhrase.mb &amp;&amp; rm ./QuickPhrase.mb</span><span class="hljs-meta">#</span><span class="bash"> 将下载的QuickPhrase.mb.1文件中的数据复制到QuickPhrase.mb，重启即可</span></code></pre></div><p><a href="https://blog.felixc.at/2012/05/kitty-for-fcitx-quickphrase/" target="_blank" rel="noopener">颜文字对照表</a></p></li><li><p>常用软件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S vim zsh ranger htop cmatrix yay oneko etronic-wechat typora netease-cloud-music tmux aria2 oneDriveLinux tree go rust ruby</span><span class="hljs-meta">#</span><span class="bash"> 图片查看器</span>nomacs</code></pre></div></li><li><p>解决.vimrc E488:多余的换行符问题:</p><p>不要用<code>#</code>写注释,而要用<code>&quot;</code></p></li><li><p>thefuck</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 没有pip先安装pip</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S python-pip</span><span class="hljs-meta">#</span><span class="bash"> 安装thefuck</span><span class="hljs-meta">$</span><span class="bash"> sudo pip install thefuck</span><span class="hljs-meta">#</span><span class="bash"> 配置</span><span class="hljs-meta">$</span><span class="bash"> fuck</span><span class="hljs-meta">#</span><span class="bash"> root用户安装</span><span class="hljs-meta">$</span><span class="bash"> sudo su</span><span class="hljs-meta">$</span><span class="bash"> pip insall thefuck</span><span class="hljs-meta">$</span><span class="bash"> fuck</span></code></pre></div></li><li><p>java</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看openjdk版本</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -Q |grep jdk</span><span class="hljs-meta">#</span><span class="bash"> 卸载openjdk</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -R jre*</span><span class="hljs-meta">#</span><span class="bash"> 查看是否删除</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -Q |grep jdk</span><span class="hljs-meta">$</span><span class="bash"> java -version</span><span class="hljs-meta">#</span><span class="bash"> 安装:去官网下载jdk8,解压到/opt</span><span class="hljs-meta">$</span><span class="bash"> sudo ln -s /opt/jdk-8u212-linux-x64/jdk1.8.0_212/bin/java /usr/bin/java</span><span class="hljs-meta">#</span><span class="bash"> 如果创建符号链接失败,则是之前的openjdk的影响,删除/usr/bin/java即可</span><span class="hljs-meta">$</span><span class="bash"> java -version</span></code></pre></div></li><li><p>软件安装</p><p>直接在软件搜索deepin.com.qq.office, idea, mysql安装</p></li><li><p>electron-ssr</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 从githb上下载pacman安装包到/opt下</span><span class="hljs-meta">#</span><span class="bash"> pacman本地安装</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -U electron-ssr-0.2.6.pacman</span></code></pre></div></li><li><p>codeblocks配置:</p><ol><li><p>下载完之后，cd ~/.config/codeblocks/ ，在官网复制主题代码，修改default.conf文件，保存。</p></li><li><p>进入/usr/include/bits文件夹下，sudo vim stdc++，将代码复制，保存。</p></li><li><p>在settings-&gt;environment-&gt;Gerneral settings-&gt;Terminal to launch console programs:-&gt;下拉单选择gnome-terminal -t $TITLE -x，变更控制台。</p></li><li><p>进行start和splash页面，utf-8，字体[monospace bold]等设置……</p></li></ol></li><li><p>mysql</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在软件直接搜mysql,安装</span><span class="hljs-meta">#</span><span class="bash"> 初始化</span><span class="hljs-meta">$</span><span class="bash"> sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><span class="hljs-meta">#</span><span class="bash">上面初始化失败,提示libicu63没找到:</span><span class="hljs-meta">$</span><span class="bash"> mysqld: error <span class="hljs-keyword">while</span> loading shared libraries: libicuuc.so.63: cannot open shared object file: No such file or directory</span><span class="hljs-meta">#</span><span class="bash"> 进入/usr/lib/icu,发现只有64版本</span><span class="hljs-meta">#</span><span class="bash"> 安装icu63</span><span class="hljs-meta">$</span><span class="bash"> yay -S icu63</span><span class="hljs-meta">#</span><span class="bash"> 等待缓慢的下载和安装</span><span class="hljs-meta">#</span><span class="bash"> 完成后再看/usr/lib/icu,发现已经有icu63了</span><span class="hljs-meta">#</span><span class="bash"> 再次初始化</span><span class="hljs-meta">$</span><span class="bash"> sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><span class="hljs-meta">#</span><span class="bash"> 记住临时密码登录,或者修改配置文件免密登录,后者修改/etc/mysql/my.cnf,在最后一行加上</span>skip-grant-tables<span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart mysqld</span><span class="hljs-meta">#</span><span class="bash"> 如果又出现初始化失败的问题,重装即可</span><span class="hljs-meta">$</span><span class="bash"> mysql -u root -p</span><span class="hljs-meta">#</span><span class="bash"> 不用密码[回车]即可</span></code></pre></div> <div class="hljs"><pre><code class="hljs mysql">use mysql;flush privileges ;alter user&#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;</code></pre></div><p><code>ctrl</code>+<code>d</code>退出mysql</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 如果是免密登录,删除加入的那行</span><span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart mysqld</span><span class="hljs-meta">#</span><span class="bash"> 输入root进入mysql</span>mysql -u root -p</code></pre></div><hr><p>二更:</p><p>重新装mysql时，没有出现上面的libicu63没找到，而是libevent_core-2.1.so.6没有找到……</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查找mysqld可能缺失的依赖库</span><span class="hljs-meta">$</span><span class="bash"> ldd /usr/bin/mysqld</span><span class="hljs-meta">#</span><span class="bash"> 结果显示，libevent_core-2.1.so.6 NOT FOUND</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/lib</span><span class="hljs-meta">#</span><span class="bash"> 发现只有.7的版本，没有.6,依赖库的版本太新了</span><span class="hljs-meta">$</span><span class="bash"> cp libevent_core-2.1.so.7 libevent_core-2.1.so.6</span><span class="hljs-meta">#</span><span class="bash"> 直接复制.7为.6</span><span class="hljs-meta">#</span><span class="bash"> 接下来就和上面的一样，重新初始化，再进行下面的步骤即可。</span></code></pre></div></li><li><p>解决tim无法使用中文输入法:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /opt/deepinwine/apps/Deepin-TIM</span><span class="hljs-meta">$</span><span class="bash"> sudo vim run.sh</span><span class="hljs-meta">#</span><span class="bash"> 添加三行:</span>export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=”@im=fcitx”<span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div></li><li><p>命令行使用代理</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改 ~/.zshrc</span>vim .zshrc<span class="hljs-meta">#</span><span class="bash"> 最下面加入两行</span>export http_proxy="http://127.0.0.1:12333"export https_proxy="http://127.0.0.1:12333"</code></pre></div></li><li><p>jetbrains全软件代理</p><p>在Settings-&gt;Apperance -&gt;System Settings-&gt;HTTP Proxy</p><p>设置Manual proxy,选择HTTP,Host name:127.0.0.1,Port number:<strong>12333</strong></p><blockquote><p>注意：</p></blockquote><p>如果electron-ssr设置了局域网内代理（默认1080端口），则端口号改为1080</p><p>还有：使用idea的同步功能时，确保File-&gt;Settings-&gt;System settings-&gt;Passwords-&gt;In KeePass勾选上</p><p>否则账户同步功能会报错</p></li><li><p>安装vscode</p><p>在软件包里安装bin文件,然后</p> <div class="hljs"><pre><code class="hljs shell">yaourt -S visual-studio-code-bin</code></pre></div><p>解决安装完成后打开文件夹自动打开vscode问题:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 首先查看默认文件管理器</span><span class="hljs-meta">$</span><span class="bash"> xdg-mime query default inode/directory</span><span class="hljs-meta">#</span><span class="bash"> 不出意外的话,会输出visual-studio-code.desktop</span><span class="hljs-meta">#</span><span class="bash"> 修改默认文件管理器</span><span class="hljs-meta">$</span><span class="bash"> xdg-mime default org.gnome.Nautilus.desktop inode/directory</span><span class="hljs-meta">#</span><span class="bash"> 再执行query命令</span>xdg-mime query default inode/directory<span class="hljs-meta">#</span><span class="bash"> 显示org.gnome.Nautilus.desktop即正确</span></code></pre></div><p>解决vscode格式化失败:libtinfo.so.5:cannot open</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 先检查有没有</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/lib</span><span class="hljs-meta">#</span><span class="bash"> 不完全打出全称,看看有哪些是以libtinfo开头的</span><span class="hljs-meta">$</span><span class="bash"> vim libtinfo. [+`tab`]</span><span class="hljs-meta">#</span><span class="bash"> 此时我看到了libtinfo.so libtinfo.so.6,的确缺少libtinfo.so.5</span><span class="hljs-meta">#</span><span class="bash"> 安装之即可</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S libtinfo5</span></code></pre></div><p><strong>注意：<strong>不要打开设置中的</strong>Auto Guess Encoding</strong>!!!</p></li><li><p>配置ranger</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ranger --copy-config=all</span><span class="hljs-meta">#</span><span class="bash"> 此命令将ranger的配置生成到 ~/.config/ranger文件夹下</span><span class="hljs-meta">#</span><span class="bash"> rc.config:选项设置和快捷键</span><span class="hljs-meta">#</span><span class="bash"> rifle.conf:指定文件的默认打开程序</span><span class="hljs-meta">#</span><span class="bash"> command.py:设置通过<span class="hljs-string">":"</span>执行的命令</span><span class="hljs-meta">$</span><span class="bash"> vim rc.conf</span>set show_hidden trueset colorscheme solarizedset draw_borders bothset line_numbers true</code></pre></div><p>vscode 插件</p> <div class="hljs"><pre><code class="hljs json">daily reminder,coding tracker,leetcode,netease music,power mode</code></pre></div></li><li><p>安装redis</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S redis</span><span class="hljs-meta">#</span><span class="bash"> 安装完成后检查能否运行</span>redis-serverredis-cli<span class="hljs-meta">#</span><span class="bash"> 修改配置使其能在后台运行</span>sudo vim /etc/redis.conf<span class="hljs-meta">#</span><span class="bash"> 把daemonize no改为yes</span>deamonize yes<span class="hljs-meta">#</span><span class="bash"> 以刚刚的配置文件运行</span><span class="hljs-meta">$</span><span class="bash"> redis-server /etc/redis.conf</span><span class="hljs-meta">#</span><span class="bash"> 这次的输出应该和前次的不一样</span><span class="hljs-meta">#</span><span class="bash"> 启动</span><span class="hljs-meta">$</span><span class="bash"> redis-cli</span></code></pre></div></li><li><p>安装mycli</p> <div class="hljs"><pre><code class="hljs shell">pip install mycli</code></pre></div></li><li><p>idea生成javadoc文档</p><p>Tools-&gt;Generate JavaDoc(快捷键可以设置为<code>CTL</code>+<code>ALT</code>+<code>D</code>)</p><p>选择OutPut_directroy</p><p>选择package</p><p>Local制定 zh_CN</p><p>Other command line arguments:</p> <div class="hljs"><pre><code class="hljs shell">-encoding utf-8 -charset utf-8 -version -windowtitle "JShell" -tag Date:a:"Date"</code></pre></div><p>在生成的文件夹中点击index.html即可。</p></li><li><p>WPS 默认英文设置</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装中文语言包</span>sudo pacman -S wps-office-mui-zh-cn</code></pre></div><p>进入 WPS 文字,点击右上方的 <code>A</code> 符号,选择中文,推出软件,重进即可</p></li><li><p>截图工具 flameshot</p> <div class="hljs"><pre><code class="hljs shell">sudo pacman -S flameshot</code></pre></div><p>打开设置-&gt;键盘快捷键,设置名称,快捷键 <code>ctrl+alt+A</code>,命令是 <code>flameshot gui</code></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2019/7/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/7/11/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>算法思想:</p><ol><li>将数组中的数据建立成所有根结点大于其左右子树的<em>完全二叉树</em>，即<strong>大根堆</strong></li></ol> <a id="more"></a><ol start="2"><li>然后将第一个堆顶结点，即root结点，也是当前未排序的最大数据，和最后未排序的数据的位置交换，结果类似冒泡排序排好了一个数据，那么现在那个最后未排序的位置就是当前的最大的数据，也就排好了一个数据</li><li>但是因为交换数据，现在的root结点的数据不一定就是最大的，那么就还需要调整堆，使其满足大根堆条件。</li><li>重复上述过程，就可以得到升序序列;反之，建立小根堆可以得到降序序列。</li></ol> <!-- more --></li><li><p>代码：</p> <div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//k 是要调整的结点在数组中的下标，在createHeap中传入的值是从最后一个非叶子结点的下标依次递减到0,表现为从中点处依次向上调整堆</span><span class="hljs-comment">//但是在HeapSort循环中，根据上述算法，每次调整的都是堆顶的root结点，即第一个结点，k=0。</span><span class="hljs-comment">//n 是还要排序n个数，第n个数也要排序，所以while循环里的条件，注意判断j等于n的情况</span><span class="hljs-comment">//j 是i的左子树结点,为2*k+1的原因是数组下标从0开始，经过试验规律得到i的左子树下标为2*k+1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = k, temp;<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>;<span class="hljs-comment">//如果j的值已经大于要排序的最后一个值的下标，说明i不存在左子树，根据完全二叉树的定义，肯定没有右子树，那么这个i结点一定是满足大根堆的，无需调整。</span><span class="hljs-keyword">while</span> (j &lt;= n)&#123;<span class="hljs-comment">//如果j+1的值小于等于要排序的最后一个值的下标，那么i不仅有左子树，还有右子树，那么就要比较右子树的数据是否大于左子树，如果是的话，j++，使j的值为i的最大子树的下标。</span><span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= n &amp;&amp; <span class="hljs-built_in">array</span>[j] &lt; <span class="hljs-built_in">array</span>[j + <span class="hljs-number">1</span>])j++;<span class="hljs-comment">//如果从i向下检查时，满足这个条件，就说明从这个结点开始往下的子树一定满足大根堆条件，就可以不用再检查，可以直接结束循环了。</span><span class="hljs-comment">//[当然，原因分两种情况。第一：是在创建堆时，i是最后一个非叶子结点，其后一定的都是叶子结点，一定满足大根堆，而i以前的非叶子结点进行判断时，因为后面一定已经调整好了，也一定满足大根堆。第二：在HeapSort循环里调整的话，和上面其实一样，每次交换可能只破坏了一个局部的大根堆，当把这个局部的调整回来时，其后面的结点就和之前一样，不受影响了。]</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &gt;= <span class="hljs-built_in">array</span>[j])<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果当前根结点i的值不是其左右字数中最大的，那么就和那个最大的数交换，使其满足大根堆条件</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &lt; <span class="hljs-built_in">array</span>[j])&#123;temp = <span class="hljs-built_in">array</span>[i];<span class="hljs-built_in">array</span>[i] = <span class="hljs-built_in">array</span>[j];<span class="hljs-built_in">array</span>[j] = temp;<span class="hljs-comment">//因为交换了值，可能破坏大根堆的条件，那么就要循环向下判断大根堆条件是否满足</span><span class="hljs-comment">//这里还有技巧，只需要检查与i交换的j往下的子结点即可，不用检查那个没有发生交换的结点。</span>i = j;j = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//从当前的最后一个非叶子结点开始,从后往前[以数组的形式看]，从下到上[以二叉树的形式看]创建堆</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)adjustHeap(<span class="hljs-built_in">array</span>, i, n);   &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">   </span>&#123;<span class="hljs-keyword">int</span> temp;createHeap(<span class="hljs-built_in">array</span>, n);<span class="hljs-comment">//创建好大根堆后，先把最大的数据(n-1)换到最后面，再将被破坏的大根堆调整，使其满足大根堆条件。</span><span class="hljs-comment">//再重复上述步骤</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123;temp = <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = <span class="hljs-built_in">array</span>[i];<span class="hljs-built_in">array</span>[i] = temp;adjustHeap(<span class="hljs-built_in">array</span>, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);&#125;&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
