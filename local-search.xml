<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>并发知识- (杂谈) 高并发高可用 VS 多线程正确性</title>
    <link href="/2020/4/23/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%20(%E6%9D%82%E8%B0%88)%20%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8-VS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A3%E7%A1%AE%E6%80%A7/"/>
    <url>/2020/4/23/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%20(%E6%9D%82%E8%B0%88)%20%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8-VS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A3%E7%A1%AE%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="header-anchor" href="#写在前面">⚡</a>写在前面</h2><p>文章是学习并发编程的时候,觉得并发编程难学,想到什么情况下需要用到并发编程,然后想到了一些情况,故记录之</p><a id="more"></a><p>我认为最主要的两个场景应该是:</p><ol><li><p>使用的人变多了,被迫需要高并发高可用</p></li><li><p>其次就是要将大任务进行一个拆分,需要使用多线程提高速度和效率</p></li></ol><h2 id="正文"><a class="header-anchor" href="#正文">⚡</a>正文</h2><p>假设我们现在有两个业务场景,一个是支付宝转账,一个是淘宝秒杀(抢火车票另说)</p><p>现在我们想想,哪个场景高可用高并发是要完全保证的,哪个场景是正确性优先的</p><p>这个时候你又会问了,为什么要有优先呢?不能两个都保证吗?</p><p>这里不讲原因,先摆事实:</p><p>你去支付宝还花呗或者微信提现的时候,是不是一般都会提示你,<code>业务正在审核/处理,两个小时内完成/到帐</code>,这个就是个铁证:</p><p>因为设计到转账,必须保证金额的正确性,加少了减少了谁负责?而对于并发量没有很高的要求(一不要求实时到账,二也没有那么多人会对同一个账户进行转账操作)</p><p>所以这些操作一般都是有一个最低时效,在时效内部,实际上是不保证操作的正确性的,例如:账也转了,钱也扣了,但是对方可能根本就没有收到,后台程序实际上还在处理后半部分的业务,这样就没有保证高可用(立刻响应,立刻处理完成),而完成了后面的业务处理之后,对方收到了款,才是一个真正的转账,最后才保证了正确性</p><hr><p>然后就是淘宝秒杀,对于这个场景,高可用则肯定是需要完全保证的</p><p>你可能又会问了,那是不是就可以不保证正确性了呢?</p><p>那也不是,这里说的正确性是,不能多卖,说白了,库存100件,你也要保证最多只卖100件,不能多卖了</p><p>但是!</p><p>这样也不是说同时满足了高并发和完全正确性,只能说是部分的正确性,或者说对于原则行问题保证正确性(当然的,因为不能把程序写的有问题是写程序的起码要求),非原则问题在<strong>一定程度上</strong>牺牲正确性来实现高可用</p><p>什么叫一定程度上?</p><p>例如秒杀的时候,你可能会去用一个锁把查看库存,付款,扣库存这三个操作给锁住,保证多线程同步</p><p>那么如果是并发量不太大可能可以,但是并发量很大,那么很多付款就会一直阻塞,用户看不到付款的结果,体验很差,而且,服务器产生很多线程阻塞,可能 CPU 飙高乃至当机</p><p>一个可以的解决方法就是,设置会一个超时的锁,如果线程在设定好的时间范围内没有获取到锁,那么就直接返回,告诉用户付款超时,稍后再试</p><p>这样就是保证了服务器提供的服务是高可用的,因为不会产生大量线程阻塞,导致服务没有办法响应或者处理速度很慢,一定时间内没有拿到锁就返回失败结果,如果拿到锁,立刻处理完成就成功,说白了就是立刻响应,立刻处理</p><p>但是,实际上,服务器立刻响应,返回失败结果的时候,不是说库存卖完了,有可能库存还有,仅仅只是你没有获取到锁(买东西的资格),跟库存多少其实根本没关系,这个就是上面我理解的在一定范围内,牺牲非原则性正确性来保证服务的高可用</p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识-- ReentrantLock</title>
    <link href="/2020/4/21/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-ReentrantLock/"/>
    <url>/2020/4/21/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h2 id="ReentrantLock-初步设计思想"><a class="header-anchor" href="#ReentrantLock-初步设计思想">⚡</a>ReentrantLock 初步设计思想</h2><p>new 一个 ReentrantLock 之后,调用 lock 方法,改变锁的状态码,从0变为1,主线程获取到锁,然后继续执行</p><p>如果此时同一个线程多次调用则进行多次重入,状态码增加</p><p>如果是线程交替执行,即并发度不是很高,那么就不存在锁的竞争,可以依次获取锁,然后依次释放,循环往复,保证高性能高可用</p><p>但是如果并发度很大,那么就一定存在线程之前对锁的竞争,这时,如果是公平锁,那么先获取锁的线程先处理,后获取锁的排在一个等待队列,然后这个线程就 <code>park</code> 暂停,然后等待锁释放和通知,<code>unpark</code> 后,再去获取锁</p><p>(注意:此处的 park 和 unpark 只是一种抽象概念,不一定指 LockSupport 里面的方法,也可以是 interrupt 中断)</p><p>但是,这里虽然想的很容易理解,但是要实现却不是那么容易,且看我如下分析</p><h2 id="ReentrantLock-类数据结构"><a class="header-anchor" href="#ReentrantLock-类数据结构">⚡</a>ReentrantLock 类数据结构</h2><h3 id="ReentrantLock-抽象内部类-Sync-锁"><a class="header-anchor" href="#ReentrantLock-抽象内部类-Sync-锁">⚡</a>ReentrantLock 抽象内部类 Sync 锁</h3><p>图 ReentrantLockSyncAndExtend:</p><p><img src="/img/ReentrantLockSyncAndExtend.png" srcset="/img/loading.gif" alt="ReentrantLockSyncAndExtend"></p><p>图 ReentrantLockSyncAndExtend1:<br><img src="/img/ReentrantLockSyncAndExtend1.png" srcset="/img/loading.gif" alt="ReentrantLockSyncAndExtend1"></p><p>从源码和上图可知, Sync 只有第一个 <code>lock()</code> 方法是抽象的,有一个默认的非公平的 <code>nonFairTryAcquired(int)</code> 方法,这个方法是<strong>尝试</strong>获取锁的,并且是一种非公平的方式</p><h2 id="Sync-的公平锁具体实现"><a class="header-anchor" href="#Sync-的公平锁具体实现">⚡</a>Sync 的<strong>公平锁</strong>具体实现</h2><p>图 AQSAbstractTryAcquire:</p><p><img src="/img/ReentrantLockFairSync.jpg" srcset="/img/loading.gif" alt="ReentrantLockFairSync"></p><p>一个 lock 方法,一个 tryAcquire 方法</p><p>lock 方法是 Sync 的具体实现,而 tryAcquire 则是<strong>重写</strong>了 Sync 的父类 AQS 的方法</p><p><span id="ReentrantLockFairSync1">图 ReentrantLockFairSync1</span><br><img src="/img/ReentrantLockFairSync1.jpg" srcset="/img/loading.gif" alt="ReentrantLockFairSync1"></p><h2 id="ReentrantLock-加锁过程-公平锁"><a class="header-anchor" href="#ReentrantLock-加锁过程-公平锁">⚡</a>ReentrantLock 加锁过程 (公平锁)</h2><h3 id="第一次加锁"><a class="header-anchor" href="#第一次加锁">⚡</a>第一次加锁</h3><ol><li><p>new 是默认非公平锁(这里分析公平锁)</p> <div class="hljs"><pre><code class="hljs java">sync = <span class="hljs-keyword">new</span> FairSync();</code></pre></div></li><li><p>当程序中调用 <code>reentrantLock.lock()</code> 方法时</p><p>lock() 方法就会调用 <code>sync.lock()</code> 方法</p><p>(sync 锁具体实现 lock 方法的 非公平的锁和公平锁不同)</p><p>由上面两张图可知,在 <code>lock()</code> 方法里面直接调用的是 <strong>AQS</strong> 的 <code>acquire(int)</code> 方法, 并且参数为1</p></li><li><p>那我们再去看 AQS</p><p><span id="AQSAcquire"><img src="/img/AQSAcquire.jpg" srcset="/img/loading.gif" alt="AQSAcquire"></span></p><p>我们可以看到首先会调用 <code>tryAcquire(int)</code> 方法,这也是 AQS 中的一个方法,我们可以根据名称猜测这个方法是用来<em>尝试获取锁</em>的</p><p>点进去,发现:</p><p><img src="/img/AQSAbstractTryAcquire.png" srcset="/img/loading.gif" alt="AQSAbstractTryAcquire"></p><p>仅仅抛一个异常?!</p><p>这当然不可能,因为这样没有任何意义</p><p>再按住 <code>ctrl</code>和<code>alt</code>,鼠标点击 <code>tryAcquire</code>,出现如下具体实现:</p><p><img src="/img/AQSAbstractTryAcquire1.jpg" srcset="/img/loading.gif" alt="AQSAbstractTryAcquire2"></p><p>我们点击第一个,发现回到了 ReentrantLock 里面的 FairSync 静态内部类的 <code>tryAcquire(int)</code> 方法, <a href="#ReentrantLockFairSync1">见图 ReentrantLockFairSync1</a></p><p>这说明,内部的公平锁自己重写了 AQS 的方法但是没有加 <strong><code>@Override</code></strong> 注释!</p></li><li><p>再回到 ReentrantLock 看这个公平锁的 <code>tryAcquired(int)</code> 方法(和<a href="#ReentrantLockFairSync1">图ReentrantLockFairSync1 一样,只是把代码贴出来了</a>)</p><p>具体分析见<span id="ReentrantLockFairSyncTryAcquire">注释:</span></p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;    <span class="hljs-comment">// 拿到当前线程</span>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();    <span class="hljs-comment">// 拿到 AQS 的内部 volatile 变量 state</span>    <span class="hljs-keyword">int</span> c = getState();    <span class="hljs-comment">// 如果 state =0 说明此时没有线程拿到锁</span>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 第一个 hasQueuedPredecessors() 是 AQS 的内部方法,是用来判断村不存在队列或者需不需要排队</span>        <span class="hljs-comment">// 返回 false 在表示队列不存在或者队列中没有前驱(即队列中没有已经拿到锁的线程)</span>        <span class="hljs-comment">// 那么这个线程就不需要排队</span>        <span class="hljs-comment">// 为什么需要排队呢,最前面将思想的时候其实已经说了:</span>        <span class="hljs-comment">// 想想如果存在多线程竞争,而且又是公平锁,那么就需要排队等待,直到前面那个线程处理完了,后面的线程才能拿到锁,再去处理</span>        <span class="hljs-comment">// todo 这里理解排队要看之后的线程竞争或者其他特殊情况,我们这里假设的是第一个线程来拿锁,暂时不考虑,因为从开始到现在根本没有初始化队列(new FairSync 也没有初始化 Sync 父类的 AQS 队列)</span>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;                <span class="hljs-comment">// 下面调用 AQS 的 CAS 方法,原子操作,改变的是 AQS 内部的 state 变量</span>                <span class="hljs-comment">// CAS 尝试加锁</span>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;            <span class="hljs-comment">// 如果前面的条件成立,说明: 1. 自己不需要排队 2. 自己成功拿到锁了</span>            <span class="hljs-comment">// 此时就可以将锁设置为当前线程</span>            <span class="hljs-comment">// 注意,这个方法是 `AQS` 继承 `AOS` 这个抽象类自己内部的方法,表示是一个排他锁</span>            <span class="hljs-comment">// 关于 AOS 具体看下面相应的地方,这里就不多做解释,现在就认为是一个排他锁</span>            setExclusiveOwnerThread(current);             <span class="hljs-comment">// 返回 true,表示成功加上了排他锁</span>            <span class="hljs-comment">// 第一个线程到这里返回</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    <span class="hljs-comment">// 又有一个线程来了,如果锁状态不为0,说明已经加锁,并且该线程就是之前加锁的第一个线程,此时会重入,state +1,并返回 true,代表重入锁加锁成功</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;        <span class="hljs-comment">// 可能在这里会想,c 是最前面 getState() 方法得到的,为什么这里不用 CAS 来保证原子操作呢?</span>        <span class="hljs-comment">// 因为其它的线程如果来了,会首先排队,不会改变第一个线程的状态值</span>        <span class="hljs-comment">// 但是如果第一个线程此时刚好释放所了,岂不是重入错了?</span>        <span class="hljs-comment">// 这里就要看上面的 else-if 判断了,如果是同一线程重入,然后释放,然后再加锁是不可能的,一个线程怎么可能同时加锁和解锁呢!</span>        <span class="hljs-comment">// 上面是目前我的分析,如果加上锁自动释放(超时释放)的功能 tryLock 可能会有问题?</span>        <span class="hljs-comment">// 解答: tryLock 是在指定时间内获取锁,而不是在指定时间内释放拿到的锁,拿到锁释放必须由这个线程显式调用 unLock 方法,所以根本不会存在自动释放锁这个逻辑</span>        <span class="hljs-comment">// 超时释放指的是超过时间没有拿到就放弃抢锁,不是超时了就释放锁</span>        <span class="hljs-keyword">int</span> nextc = c + acquires;        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);        setState(nextc);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 如果锁状态不为0,并且是另一个线程来加锁,会返回 false</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p>关于 <code>hasQueuedPredecessors() </code> 方法,放到 AQS 章节再讲,这些 AQS 内部方法也有很多需要分析</p></li><li><p>方法 <code>tryAcquire(int)</code> 返回 true,回到<a href="#AQSAcquire">前面 AQS 的 acquire</a></p><p>此时 if 条件不成立,直接返回了,然后递归返回,就没有什么,结束程序中的 <code>reentrantLock.lock()</code> 方法,加锁成功,主程序继续执行</p></li></ol><h3 id="如果此时第一个线程又来加锁-重入"><a class="header-anchor" href="#如果此时第一个线程又来加锁-重入">⚡</a>如果此时第一个线程又来加锁(重入)</h3><p>此时在 <code>ReentrantLock</code> 中的 <code>FairSync</code> 的 <code>tryAcquire(int)</code> 方法里面,进入 else 判断,<a href="#ReentrantLockFairSyncTryAcquire">请看代码注释 else-if 部分</a></p><p><code>tryAcquire(int)</code> 返回 true, 然后也是和第一次拿到锁一样,调用递归返回,主程序继续执行</p><p>不过需要注意,<code>FairSync</code> 公平锁的父类 AQS 的内部状态 volatile 变量 state 每次都要加一,而每次释放锁的时候,state 才会减一,最后一定要变为0才释放了所有锁</p><h3 id="如果是第二个线程来了-也开始加锁-并且此时第一个线程还没有释放锁"><a class="header-anchor" href="#如果是第二个线程来了-也开始加锁-并且此时第一个线程还没有释放锁">⚡</a>如果是第二个线程来了,也开始加锁,并且此时第一个线程还没有释放锁</h3><ol><li><p>同上面两种情况,会调用 <code>sync.lock()</code> 方法,然后 <code>acquire(1)</code>,再然后 <code>tryAcquire(1)</code></p><p>但是此时 if 和 else 条件都不满足,会返回 false</p></li><li><p><a href="#AQSAcquire">此时AQS 的</a> <code>acquire(1)</code> 方法中 if 的第一个 <code>tryAcquire(1)</code> 取反,值为 true,进入 <code>acquiredQueue(addWaiter(Node.Exclusive,1))</code> 两个方法</p><p>这两个方法就不在这里分析了,因为这是属于 AQS 内部实现,而且很复杂,需要单独说</p><p>我们现在就只需要知道,这里第二个线程就会去在 AQS 内部排队等待</p><p>再然后,会调用 <code>selfInterrupt()</code> 方法,这个 AQS 方法比较简单,就把代码截出来了</p><p><img src="/img/AQSSelfInterrupt.png" srcset="/img/loading.gif" alt="AQSSelfInterrupt"></p><p>把当前线程中断,来让出 CPU 等待 AQS 的唤醒</p></li></ol><h2 id="ReentrantLock-加锁过程-非公平锁"><a class="header-anchor" href="#ReentrantLock-加锁过程-非公平锁">⚡</a>ReentrantLock 加锁过程 (非公平锁)</h2><p><span id="ReentrantLockNonFairSync">如图 ReentrantLockNonFairSync:</span></p><p><img src="/img/ReentrantLockNonFairSync.png" srcset="/img/loading.gif" alt="ReentrantLockNonFairSync"></p><h3 id="第一次加锁-v2"><a class="header-anchor" href="#第一次加锁-v2">⚡</a>第一次加锁</h3><ol><li><p>有源码和上图知,调用 <code>ReentrantLock.lock()</code> 方法时,会调用上图中非公平锁 NonFairSync 的方法</p><ol><li><p>首先会 CAS 直接尝试抢占锁,如果抢到了就直接上锁,程序正常返回</p><p>就是比公平锁少了一个判断方法 <code>!hasQueuedPredecessors()</code> 来判断需不需要排队</p><p>非公平锁当然不需要排队啦~</p></li><li><p>如果没有没有直接抢到,那么其实还是要排队,调用 AQS 的 <code>acquire()</code> 方法</p><p>注意,这个时候就不要认为之后的逻辑和公平锁一模一样,因为锁在继承 <code>AQS</code> 的实现的时候,都重写了 <code>AQS</code> 的 <code>tryAcquire()</code> 方法</p><p>对于非公平锁来说,它默认使用的是 <code>ReentrantLock</code> 类中 <code>Sync</code> 父类里面的 <code>nonFairTryAcquire()</code> 方法</p><ol><li><p>nonFairTryAcquire()</p><p><img src="/img/ReentrantLockNonFairTryAcquire.png" srcset="/img/loading.gif" alt="ReentrantLockNonFairTryAcquire"></p><p>和公平锁的实现没有太大差别,仅仅只是少了 <code>hasQueuedPredecessor()</code> 这个重要的查看队列的方法,会上来就去尝试获取锁,而不考虑是否存在等待队列</p></li></ol></li></ol></li></ol><h3 id="重入情况则和公平锁一致"><a class="header-anchor" href="#重入情况则和公平锁一致">⚡</a>重入情况则和公平锁一致</h3><p><a href="#ReentrantLockFairSyncTryAcquire">同上的 else-if</a></p><h3 id="第二个线程来加锁了"><a class="header-anchor" href="#第二个线程来加锁了">⚡</a>第二个线程来加锁了</h3><p>假设存在线程竞争,那么根据 <a href="#ReentrantLockNonFairSync">图</a>,和公平锁一样,还是会进入上图的 <code>nonFairTryAcquire()</code>,然后返回 false,然后调用 AQS 的 <code>addWaiter()</code> 和 <code>acquireQueued()</code> 加入到等待队列中,<code>selfInterrupt()</code>方法自我中断</p><h2 id="ReentrantLock-解锁过程"><a class="header-anchor" href="#ReentrantLock-解锁过程">⚡</a>ReentrantLock 解锁过程</h2><h3 id="线程调用了-unLock"><a class="header-anchor" href="#线程调用了-unLock">⚡</a>线程调用了 unLock</h3><p><img src="/img/ReentrantLockSyncUnLock.png" srcset="/img/loading.gif" alt="ReentrantLockSyncUnLock"></p><p>然而这个 <code>release(1)</code> 方法又是 AQS 内部的方法:</p><p><img src="/img/AQSRelease.png" srcset="/img/loading.gif" alt="AQSRelease"></p><p>从上面可以看到,这里首先调用了一个 <code>tryRelease(1)</code> 方法</p><p><img src="/img/ReentrantLockTryRelease.png" srcset="/img/loading.gif" alt="ReentrantLockTryRelease"></p><ol><li><p><code>tryRelease()</code> 方法</p><p>这个是 <code>ReentrantLock</code> 内部 <code>Sync</code> 自己实现的默认方法,并且公平锁和非公平锁调用一致</p><p>由于锁可以重入,所以这里 <code>getState()</code> 获取到的状态值可能大于1,所以此处要减去参数 release (=1) 拿到预期值</p><p>然后进行判断,如果不是锁持有的线程拿到锁会抛出异常(一般不会出现)</p><p>如果上面预期的状态值等于0,则说明锁可以释放,此时就把共享锁设为空;反之,不进行该操作</p><p>(注意:锁为空并不代表锁已经释放,因为锁的状态是由 state 字段标识的,此时并没有改锁的状态)</p><p>然后改变锁的状态 <code>setState()</code>,并且返回释放锁的结果</p><p>想想这里改变状态为什么不用 CAS 操作?原因其实上面提到一些</p><p>因为此时线程又不可能重入(这个线程正在释放,怎么可能会重入),如果是别的线程,在 <code>setState()</code> 操作之前,锁还没有释放又不可能来抢锁,所以这里就可以安安心心的进行锁的状态改变了</p></li><li><p>tryRelease() 方法返回了,之后就是 AQS 的内部实现和状态判断了</p><p>老规律还是把这个实现留在讲 AQS 的文章里面集中分析吧</p><p>我们只需要知道此时锁已经释放,并且把 AQS 的内部状态 state 重置成 0,并且锁头已经置为空就行了</p></li></ol><h2 id="写在后面"><a class="header-anchor" href="#写在后面">⚡</a>写在后面</h2><p>AQS 和 ReentrantLock 代码,首先看子路老师的视频和马士兵的视频,然后对着源码一点点分析,做笔记,再结合博客看</p><p>自己再把 AQS 和 ReentrantLock 的类图先理清楚,有哪些内部类,哪些方法,哪些是抽象的,哪些是具体实现,分别做了什么,一层层理清楚</p><p>这篇文章仅仅分析了 ReentrantLock, 很多更重要的代码其实在 AQS 里面,具体分析就暂时等待 AQS 的文章吧</p><p>要不然,ReentrantLock 用到了 AQS 的一部分 api,我们就去看 AQS, 看了 AQS 又不知道像 <code>tryAcquire()</code> 和 <code>acquire()</code> 到底分别在什么情况下使用,又要回到 ReentrantLock 去看 api 的应用,让人云里雾里,非常头疼</p><p>其实也没有分析很多,<s>这么一想其实 ReentrantLock 还挺简单的</s></p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- ICP 优化</title>
    <link href="/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-ICP-%E4%BC%98%E5%8C%96/"/>
    <url>/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-ICP-%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Index Condition Pushdown (ICP)</p><ul><li><p>目的: 在取出索引的同时,提前判断 where 条件,从而提前过滤一部分不符合条件的记录</p>  <a id="more"></a></li><li><p>适用条件: range,ref,eq_ref,ref_or_null, 可以看到 using index condition</p></li><li><p>好处: 减少上层 SQL 层对记录的索取,从而提升数据库的整体性能</p></li><li><p>工作方式:</p><p>如果没有 ICP,在进行索引查询时,首先会根据索引查找记录,然后再根据 where 条件来过滤</p><p>而使用 ICP 之后,存储引擎在取出索引的同时,会判断是否可以进行 where 条件过滤,也就是<strong>将 where 部分过滤操作放到了存储引擎层</strong>,在某些查询下,可以大大减少上层 SQL 层对记录的索取,从而提高数据库的整体性能</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- MRR 优化</title>
    <link href="/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-MRR%20%E4%BC%98%E5%8C%96/"/>
    <url>/2020/4/16/MySQL-%E7%9F%A5%E8%AF%86-MRR%20%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Multi-Range Read (MRR)</p><ul><li><p>目的:减少磁盘随机访问</p>  <a id="more"></a></li><li><p>适用条件: range,ref,eq_ref类型的查询,会显示 using MRR</p></li><li><p>好处:</p><ol><li><p>MRR使数据访问变得较为顺序</p><p>在辅助索引中,首先根据得到的查询结果按照主键升序排序,再去查找</p></li><li><p>减少缓冲池中页被替换的次数</p></li><li><p>批量处理对键值的查询操作</p></li><li><p>此外,MRR 还可以将某些范围查询,拆分为键值对,以此来进行批量数据查询</p><p>好处是在拆分过程中,直接过滤一些不符合查询条件的数据,保证取出的都是有效的数据,而不会直接先根据一个条件取数据,然后再根据第二个条件进一步过滤</p></li><li><p>将读入替换缓冲池的行为降为最低</p><p>如果存储引擎的缓冲池不是足够大,即不能存放下一张表的所有数据,此时频繁的随机读还会导致缓存的页被替换出缓冲池,然后又不断读入缓冲池.这时使用 MRR 可以按照主键顺序访问,则可以将这个</p></li></ol></li><li><p>工作方式(InnoDB 和 MyISAM):</p><ol><li><p>将得到的辅助索引键值存放到一个缓存中,这时数据是根据辅助键值排序的</p></li><li><p>将缓存中的值根据 RowID 进行排序</p></li><li><p>根据 RowID 的顺序访问实际的数据文件</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识-- InnoDB 和 MyISAM</title>
    <link href="/2020/4/15/MySQL-%E7%9F%A5%E8%AF%86-InnoDB-%E5%92%8C-MyISAM/"/>
    <url>/2020/4/15/MySQL-%E7%9F%A5%E8%AF%86-InnoDB-%E5%92%8C-MyISAM/</url>
    
    <content type="html"><![CDATA[<h2 id="区别"><a class="header-anchor" href="#区别">⚡</a>区别</h2><ol><li><p>InnoDB 支持事务,MyISAM 不支持事务</p> <a id="more"></a></li><li><p>InnoDB 支持外键,MyISAM 不支持外键</p></li><li><p>InnoDB 是聚簇索引,MyISAM 是非聚簇索引</p><p>InnoDB 是聚簇索引,聚簇索引文件放在主键索引的叶子节点上,但是辅助索引需要两次查询:先查到主键,然后根据主键回表查到数据</p><p>对于 InnoDB 的聚集索引,就是<strong>表本身</strong></p><p>InnoDB 的聚集索引中,有主键列,事务 id,回滚指针,非主键列</p><p>MyISAM 是非聚簇索引,数据文件是分离的,索引保留的是数据文件的指针,主键索引和辅助索引是独立的</p></li><li><p>InnoDB 不保存表的行数,MyISAM 保留了表的行数,<code>count(*)</code> 很快</p></li><li><p>InnoDB 锁的最小粒度是行锁,MyISAM 最小粒度是表锁</p><p>MyISAM 在更新一行数据时会锁住整个表,限制并发量,这是 MySQL 5.2 将默认的 MyISAM 换成 InnoDB 的主要原因</p><p>不过 InnoDB 的行锁仅在 where 的主键是有效时成立,否则还是表锁</p></li><li><p>InnoDB 可以在崩溃后安全恢复,MyISAM 不行</p></li><li><p>InnoDB 键值一起保存，索引与数据一起载入InnoDB缓冲池;MyISAM键值分离，索引载入内存(key_buffer_size),数据缓存依赖操作系统</p></li><li><p>InnoDB 全文索引支持模糊搜索,MyISAM 不支持</p></li></ol><h2 id="相同"><a class="header-anchor" href="#相同">⚡</a>相同</h2><p>索引都是 B+ 树结构</p>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识--索引</title>
    <link href="/2020/4/14/MySQL-%E7%9F%A5%E8%AF%86-%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/4/14/MySQL-%E7%9F%A5%E8%AF%86-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="几种索引"><a class="header-anchor" href="#几种索引">⚡</a>几种索引</h2><h3 id="聚集索引-聚簇索引-cluster-index-主键索引"><a class="header-anchor" href="#聚集索引-聚簇索引-cluster-index-主键索引">⚡</a>聚集索引 (聚簇索引 cluster index)(主键索引)</h3><p>聚集索引数据行的<strong>物理顺序</strong>与列值(一般是主键列)的逻辑顺序相同</p><a id="more"></a><p>注意,这里有一个很容易误解的点:</p><blockquote><p>这里说的是物理顺序,而不是物理上<strong>连续</strong></p><p>一是因为页之间是通过循环双向链表连接的,可能都没有物理上的首尾结点的说法</p><p>二是正是由于是循环双向链表,而且会有页分裂时候的复制过程,那么在物理地址上,就同样不是顺序的了</p></blockquote><p>聚簇表示数据行和相邻的键值(逻辑上)紧凑地存储在一起</p><p>因为无法同时把数据数据行存放在两个不同的地方,所以一个表中只能拥有<strong>一个聚集索引</strong></p><p>即对于 InnoDB 的聚集索引,就是表本身</p><ul><li><p>优点:</p><ol><li><p>把相关数据保存在一起,顺序读取,减少磁盘 IO</p></li><li><p>数据访问更快</p></li><li><p>覆盖索引扫描查询可以直接使用页节点的主键值</p></li></ol></li><li><p>缺点:</p><ol><li><p>虽然极大提高了 IO 密集应用的性能,但是如果数据全部放到内存中,访问顺序就没那么重要了</p></li><li><p>如果不是按照主键的顺序对表进行插入会非常慢(为了保持索引的物理顺序一致,可能在数据页中进行重排)</p></li></ol></li></ul><ol><li><p>更新索引列的代价很高,因为会强制将每个被更新的行移动到新的位置</p><ol><li><p>插入是可能面行页分裂问题,导致表占用更多的磁盘空间</p></li><li><p>可能导致全表扫描比较慢,尤其是行比较稀疏或者由于页分页导致数据存储不连续的时候</p></li><li><p>非聚簇索引可能要比想象的大,因为包含了所有引用行的主键列</p></li><li><p>回表成本</p></li></ol></li></ol><h3 id="非聚集索引-非聚簇索引-non-cluster-index-二级索引-辅助索引"><a class="header-anchor" href="#非聚集索引-非聚簇索引-non-cluster-index-二级索引-辅助索引">⚡</a>非聚集索引 (非聚簇索引 non cluster index)(二级索引,辅助索引)</h3><p>辅助索引是相对主键索引而言的,其实就是非聚集索引</p><p>聚集索引实际上不是一种单独的索引,而是一种数据存储方式</p><p>网上说:</p><blockquote><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的逻辑排列顺序是否一致</p></blockquote><p>实际上不对,我认为应该是:</p><p>聚集索引和非聚集索引的根本区别是聚集索引在叶子节点存储行,而非聚集索引则是存储指针</p><p>非聚集索引的叶子节点记录数据页的<strong>指针</strong>或者<strong>主键</strong>而不是数据,虽然不同引擎的非聚集索引都是指针,但是不同的引擎不同的指针类型不一样</p><p>MyISAM 引擎都是非聚集索引,而且索引的叶子节点存储的都是数据文件的指针</p><p>InnoDB 引擎的主键索引是聚集索引,主键索引叶子节点都是存一行记录,辅助索引是存储主键的值</p><p>在 InnoDB 里面主键索引是存储了<strong>一行的值</strong>,但是辅助索引(非聚集索引)仅仅存储<strong>主键</strong>,如果没有主键,则会自动选择一个可以唯一标识的字段,如果也没有,则存储默认隐含的 row id</p><p>如果用到了辅助索引,但是所选取的属性又没有存储,那么就会进行<strong>回表</strong>:先拿到主键,然后根据主键在主键索引上再进行查找,解决办法则可以用下面写到的覆盖索引</p><h3 id="覆盖索引-covering-index"><a class="header-anchor" href="#覆盖索引-covering-index">⚡</a>覆盖索引 (covering index)</h3><p>指查询语句的执行只用从索引中就能够获得,不必从表中读取,也可以称之为索引覆盖</p><p>一般多是联合索引</p><p>如果一个索引包含了(或覆盖了)查询语句中的字段和条件的数据就叫覆盖索引</p><p>索引覆盖成立时,SQL 只需要通过索引就可以返回查询的数据,避免了回表操作</p><p>覆盖索引使用 InnoDB 比 MyISAM 好,因为 InnoDB 使用聚集索引组织数据,如果二级索引中包含查询所需的数据,就不需要在聚集索引中查找了</p><p>explain 的 extra 中有 using index 表示用到了覆盖索引</p><p>(如果同时有 using index 和 using where 说明索引不仅仅用来读取数据,还被用来查找)</p><p>注意:</p><ol><li><p>覆盖索引一般不可 select *,而一般是索引中的,并且是所需要用到的列</p></li><li><p>不一定所有存储引擎都支持覆盖索引,并且不同的引擎实现方式都可能不同</p></li><li><p>Hash 索引和全文索引(FULL-Text)不存储值</p></li><li><p>最左匹配原则</p></li></ol><p>覆盖索引的优点:</p><ol><li><p>索引项一般比较小,可以访问更少的记录</p></li><li><p>索引按照值的大小记录,减少随机IO</p></li></ol><h3 id="全文索引-full-text-index"><a class="header-anchor" href="#全文索引-full-text-index">⚡</a>全文索引 (full text index)</h3><p>InnoDB 和 MyISAM 在 5.6 以后都支持全文索引</p><p>对于字符数量比较少的情况下,<code>like</code> 或者 <code>%</code> 都是常规解决方案,但是对于大量的文本数据检索，<code>like</code> 或者 <code>%</code> 是不可想象的</p><p>全文索引在大量的数据面前，能比 <code>like</code> 或者 <code>%</code> 快得多，速度不是一个数量级，但是全文索引可能存在精度问题</p><ul><li><p>倒排索引(inverted index): 它在辅助表中存储了单词和单词自身在一个或者多个文档中的位置映射,具体有两种表现形式:</p><ol><li><p>inverted file index,表现为 {单词,单词所在文档ID}</p></li><li><p>full inverted index,表现为 {单词,(单词所在文档ID,在文档中的具体位置)}</p></li></ol></li><li><p>InnoDB 采用 full inverted index 方式,将 (documentID,position)视为一个 ilist,单词视为 word,并且在 word 上建立索引</p><p>(word,ilist)就是两列,建立的表被称为 Auxiliary Table (辅助表),并且为了提升性能,一共有6张 Auxiliary Table</p><p>并且,由于有 position,所以可以进行模糊搜索</p></li><li><p>FTS Index Cache (全文检索索引缓存)</p><p>它是一个红黑树,根据(word,ilist)排序</p><p>所以可能写入数据的表已经更新,但是全文索引的更新数据还在 FTS 中,Auxiliary Table 还没有更新</p><p>InnoDB 会批量对 Auxiliary Table 进行批量更新,而不是一个个更新</p><p>这样当查询时,会首先将在 TFS 中对应的 word 字段合并到 Auxiliary Table 中,在进行查询</p><p>这种操作类似 Insert Buffer,不同的是 Insert Buffer 是持久对象,还是 B+ 树结构</p></li></ul><h3 id="其它索引"><a class="header-anchor" href="#其它索引">⚡</a>其它索引</h3><ul><li><p>外键索引: 对外键建立的索引,方便外键的级联</p></li><li><p>唯一索引: 索引值唯一</p></li><li><p>哈系索引: 基于哈系表实现,缺点是必须精确匹配索引所有的列的查询才有效,不支持范围查询,也不支持任何范围查询</p></li></ul><h2 id="索引优化–建立高性能索引"><a class="header-anchor" href="#索引优化–建立高性能索引">⚡</a>索引优化–建立高性能索引</h2><ol><li><p>独立的列</p><p>SQL 语句的索引列不能是表达式的一部分,也不能是函数的参数 -&gt; 化简</p></li><li><p>前缀索引</p><p>如果索引是很长的字符列,使索引变得很大并且很慢,则可以在适当范围内降低索引的选择性,只对字符序列的前面几位建立索引</p><p>索引的选择性是指,不重复的索引值和记录总数的比值,选择性越高查询效率越高</p><p>缺点: 无法使用前缀索引做 order by 和 group by,也无法做覆盖扫描</p><p>如果有的列选择性都很低,例如 url 前面都是 www,那么我们可以尝试使用后缀索引,例如将 url 倒过来存 (类似的有爬虫中的倒排文档),再建立前缀索引</p></li><li><p>多列索引</p><p>MySQL 5.0 以后,其实查询可以同时使用多个单列索引进行扫描,并将结果合并 (explain 中 extra 的 <strong>index_merge</strong>)</p><p>虽然 MySQL 可以这样,但是实际上更多说明了表上的索引建的很糟糕:</p><blockquote><p>通常有多个 AND 条件,则一般需要包含所有相关列的多列索引,而不是多个独立的索引</p><p>通常有多个 OR 条件,则一般需要耗费大量 CPU 和内存资源在算法的缓存,排序和合并操作上,特别是索引的选择性不高,返回大量数据的时候</p><p>更重要的是,优化器不会把这些计算计算到查询成本中,优化器只关心随机读取</p><p>这样做不但更加消耗资源,还可能会影响查询的并发性</p></blockquote><p>在这种情况下,尽量建立多列索引甚至实现覆盖索引</p></li><li><p>选择合适的索引列顺序</p><blockquote><p>经验法则: 将选择性最高的索引放到最前列</p></blockquote><p>然而,这是不考虑排序和分组的情况下,只优化 where 条件的查找</p><p>如果可以的话,还是要考虑特殊的记录,例如,有一些特殊的记录,未登录的游客的session的记录查找就可能很庞大,这就需要我们在程序代码里面区分游客和普通用户了</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--JVM 和 JMM</title>
    <link href="/2020/4/14/JVM-%E7%9F%A5%E8%AF%86-JVM-%E5%92%8C-JMM/"/>
    <url>/2020/4/14/JVM-%E7%9F%A5%E8%AF%86-JVM-%E5%92%8C-JMM/</url>
    
    <content type="html"><![CDATA[<h2 id="JMM-解释"><a class="header-anchor" href="#JMM-解释">⚡</a>JMM 解释</h2><p>JMM (Java Memory Model) 定义了 Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM 是整个计算机虚拟模型，所以 JMM 隶属于 JVM</p><a id="more"></a><p>Java 虚拟机规范中试图定义一种 <code>Java 内存模型</code>,来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>,以实现 Java 程序在各种平台下都能达到一致的内存访问效果</p><p>JMM 主要目标就是定义程序中各个变量的访问规则,即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</p><p>JMM 决定一个线程对共享变量的写入何时对另一个线程可见</p><p>JMM 即 Java 线程之间的通信是采用共享内存模型</p><p>Java 内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步</p><p>这里的内存模型是指,在特定的操作协议下,对特定的内存或高速缓存进行读写访问的过程抽象</p><h2 id="JMM-问题和目标"><a class="header-anchor" href="#JMM-问题和目标">⚡</a>JMM 问题和目标</h2><p>当对象和变量可以存储在计算机中不同的内存区域时,会出现两个主要问题:</p><ol><li><p>线程更新(写)到共享变量的可见性</p></li><li><p>读取,检查和写入共享变量时的竞争条件</p></li></ol><p>JMM 是围绕并发过程中如何处理可见性,原子性和有序性这3个特征建立起来的</p><ol><li><p>可见性: volatile,synchronized,final</p></li><li><p>原子性: 一个操作或多个操作,要么全部执行不被打断,要么都不执行</p></li><li><p>有序性: 计算机在执行程序时,为了提高性能,会进行指令重排(包括: 编译器优化重排,指令并行重排,内存系统重排)</p><ol><li><p>as-if-serial: 即在指令重排时,无论怎么优化,单线程程序执行程序的结果不会改变</p></li><li><p>happens-before</p><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系</p><ol><li><p>程序顺序规则: 一个线程中的每个操作,happens-before 于线程中的任意后续操作</p></li><li><p>监视器锁规则: 一个锁的解锁,happens-before 于随后对这个锁的加锁</p></li><li><p>volatile 规则: 对一个 volatile 域的写,happens-before 于任意后续对这个 volatile 域的读</p></li><li><p>传递性: 如果 A happens-before B,且 B happens-before C,那么 A happens-before C</p></li></ol><blockquote><p>特别注意:</p><p>两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！</p><p>happens-before 仅仅要求前一个操作执行的结果对后一个操作<strong>可见</strong>,且前一个操作按顺序排在第二个操作之前</p></blockquote><p>最后一句话的意思是,前一个结果出来之后,后一个操作才能结束,前一个操作也可以比后一个操作后执行,但是一定是前一个操作先出结果</p></li></ol><p>这三个特征底层实现都是通过内存屏障实现的</p></li></ol><h2 id="JMM-结构"><a class="header-anchor" href="#JMM-结构">⚡</a>JMM 结构</h2><p><img src="/img/JMM.png" srcset="/img/loading.gif" alt="JMM"></p><p>(再看看和 CPU 的结构像不像)</p><p>当线程修改私有数据时,直接在工作空间修改</p><p>当线程1 和线程2 修改他俩共享的数据时,需要先从内存将数据复制到工作空间中,修改完成后,需要再刷入内存中</p><p>工作空间是 JMM 的一个抽象概念,并不真是存在,它包括了 cache, 寄存器等</p><ul><li><p>这样设计的好处是:</p><p>保证数据的<strong>隔离性</strong>,如果没有工作空间,一个线程读一个线程写,或者多个同时写入,就更容易混乱</p><p>而有了工作空间,<strong>读写分离</strong>,你修改你的变量,我读取甚至修改我的变量,相安无事</p></li><li><p>带来的缺点:</p><p>线程访问共享变量时,线程不安全</p><p>一个线程已经写完但是还没来得及刷入到内存中,但是另一个线程已经读入了,会导致脏数据</p></li></ul><h2 id="JMM-和-JVM-的区别和联系"><a class="header-anchor" href="#JMM-和-JVM-的区别和联系">⚡</a>JMM 和 JVM 的区别和联系</h2><ul><li><p>联系:</p><p>JVM 就是按照 JMM 来去划分的,而 JMM 又是</p><p>虚拟机栈和程序计数器就是工作空间</p></li><li><p>区别:</p><p>JVM 是将Java 虚拟机管理的内存空间的别名,是实际存在的存储空间</p><p>JMM 是规范,是抽象模型,并不真实存在</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 常用指令</title>
    <link href="/2020/4/11/MySQL-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/4/11/MySQL-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><p>修改字段 video 为 utf8mb4 编码</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> slaughter_sheepinfo <span class="hljs-keyword">change</span> video video <span class="hljs-built_in">varchar</span>(<span class="hljs-number">250</span>) <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4</code></pre></div>  <a id="more"></a></li><li><p>查看表和字段 DDL 信息</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> slaughter_sheepinfo</code></pre></div></li><li><p>修改数据库默认字符集编码</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> Sheep <span class="hljs-keyword">default</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4;</code></pre></div></li><li><p>查看数据库 DDL 信息</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> sheep</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>shellCommand</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识--连接join</title>
    <link href="/2020/4/11/MySQL-%E7%9F%A5%E8%AF%86-%E8%BF%9E%E6%8E%A5join/"/>
    <url>/2020/4/11/MySQL-%E7%9F%A5%E8%AF%86-%E8%BF%9E%E6%8E%A5join/</url>
    
    <content type="html"><![CDATA[<ul><li><p>最笨拙的join就是多个表的for循环,以幂次增长</p>  <a id="more"></a><p>例如</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> t2 <span class="hljs-keyword">on</span> t1.a = t2.a;<span class="hljs-comment"># 等价的是:</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t1,t2 <span class="hljs-keyword">where</span> t1.a = t2.a;</code></pre></div><p>这时会以一个表作为<strong>驱动表</strong>,然后拿到一行记录就做为新的条件去另一个表过滤数据</p><p>类似</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(tt1 in t1)&#123;    <span class="hljs-keyword">if</span>(tt1 is <span class="hljs-keyword">true</span>)&#123;        <span class="hljs-keyword">for</span>(tt2 in t2)&#123;            <span class="hljs-keyword">if</span>(tt2 is <span class="hljs-keyword">true</span> <span class="hljs-keyword">for</span> condition)&#123;                <span class="hljs-keyword">return</span>            &#125;        &#125;    &#125;&#125;</code></pre></div></li><li><p>MySQL 就使用 <code>join buffer</code> 优化:</p>  <!-- 因为如果是表比较小还好,如果表很大,那么一次性可能不能从磁盘全部把驱动表加载进内存,那么读到一定程度就需要把前面读到的从内存中删掉,然后再从磁盘继续读,这样驱动表就会被读取很多遍,有很大的 IO 开销 --><p>上面这样效率肯定很低,因为当驱动表得到一条数据之后,就会在被驱动表里面找符合条件的数据,而被驱动表需要从磁盘加载到<strong>内存</strong>才能进行条件匹配</p><p>而每次访问被驱动表,都要进行一次IO,并且在内存中的每一条记录只会和驱动表结果集的一条记录做匹配,之后就会被从内存中清除掉,然后再从驱动表结果集中拿出另一条记录,再一次把被驱动表的记录加载到内存中一遍</p><p>周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了</p><p>MySQL 使用 join buffer 就是这么做的</p><p>它不再是每次从驱动表取出一条数据就在另一个表里面找,而是取出一定大小之后,再一起在另一张表里找,这样就提高了效率</p><blockquote><p>join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 join buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的多条驱动表记录做匹配，，所以这样可以显著减少被驱动表的 I/O 代价</p><p>最好的情况是 join buffer 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。这种加入了 join buffer 的嵌套循环连接算法称之为<strong>基于块的嵌套连接</strong>(Block Nested-Loop Join)算法</p><p>另外需要注意的是，驱动表的记录并不是所有列都会被放到join buffer中，只有查询列表中的列和过滤条件中的列才会被放到join buffer中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样可以在join buffer中放置更多的记录</p></blockquote><p>join buffer 只有当我们的 join 类型为 ALL,index,rang 或者是index_merge 的时候才能够使用</p><p>注意: join buffer 只是通过先查驱动表,在一起放到另一个表的条件里面,如果驱动表还是很多,应该还是会有多次读取驱动表的情况</p></li><li><p>消除外联接</p><blockquote><p>内连接的驱动表和被驱动表的位置可以相互转换，而左连接和右连接的驱动表和被驱动表是固定的。这就导致内连接可能通过优化表的连接顺序来降低整体的查询成本，而外连接却无法优化表的连接顺序</p></blockquote><blockquote><p>外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用子句中的过滤条件的记录，NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--对象</title>
    <link href="/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>对象布局 =  对象头(12个byte=96bit) + 实例数据 + 对齐填充 (变成8的倍数)</p><a id="more"></a><p>对象头 = mark word(64bit) + klass pointer(32bit)</p><p>klass pointer 指针指向元空间中保存类的模板信息的地址</p><blockquote><p>object header</p><p>Common structure at the beginning of every GC-managed heap object. (Every oop points to an object header.) Includes fundamental information about the heap object’s layout, type(类型), GC state (垃圾回收状态), synchronization state (同步状态), and identity hash code (hash code). Consists of two words(字长)(字长和机器有关,64位机字长就是64位). In arrays it is immediately followed by a length field. Note that both Java objects and VM-internal objects have a common object header format.</p></blockquote><p><img src="https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt="1"></p><div class="hljs"><pre><code class="hljs plain">|--------------------------------------------------------------------------------------------------------------||                                              Object Header (128 bits)                                        ||--------------------------------------------------------------------------------------------------------------||                        Mark Word (64 bits)                                    |      Klass Word (64 bits)    |       |--------------------------------------------------------------------------------------------------------------||  unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |     OOP to metadata object   |  无锁 01|----------------------------------------------------------------------|--------|------------------------------||  thread:54 |         epoch:2      | unused:1 | age:4 | biased_lock:1 | lock:2 |     OOP to metadata object   |  偏向锁 01|----------------------------------------------------------------------|--------|------------------------------||                     ptr_to_lock_record:62                            | lock:2 |     OOP to metadata object   |  轻量锁 00|----------------------------------------------------------------------|--------|------------------------------||                     ptr_to_heavyweight_monitor:62                    | lock:2 |     OOP to metadata object   |  重量锁 10|----------------------------------------------------------------------|--------|------------------------------||                                                                      | lock:2 |     OOP to metadata object   |    GC 11|--------------------------------------------------------------------------------------------------------------|</code></pre></div><p>可以使用 jol 打印对象信息,不过注意,JVM默认是大端存储,所以注意顺序是锁标志位在输出的第一个八位数据的最后两位 <code>例如:00000101 是打印的第一个字节,其中最后的101表示偏向锁</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--内存溢出和内存泄漏</title>
    <link href="/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2020/4/11/JVM-%E7%9F%A5%E8%AF%86-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>内存溢出(MemoryOverflow)就是你要求分配的内存超出了系统给你的,导致系统无法再给你提供内存资源（内存资源耗尽）</p><a id="more"></a><p>内存泄漏(MemoryLeak)就是申请到了内存空间,但是没有及时清理内存垃圾,或者用到了不属于自己的内存,于是产生泄漏</p><p>例子:</p><ol><li><p>内存溢出则是一个时间点,即申请内存但是申请不到,没有多余的内存分配了</p><p>例如死循环 new 对象,但是又不用 (MemoryLeak),仅仅加入到 list 里面,最后还在继续申请但是已经没有内存空间了,结果发生 OOM (MemoryOverflow)</p></li><li><p>内存泄漏是指一个过程,或者说一段时间</p><p>泄漏是说<strong>程序逻辑问题</strong>,造成申请的内存无法正确释放,或者是你用到了不属于你的内存 (例如数组越界)</p><p>例如:堆栈调用过多,会导致超出虚拟机栈深度,StackOverFlowError,实际上也是一种内存泄漏</p><p>内存溢出是申请的内存空间没有被正确释放,导致后续程序里这块内存被永远占用（<strong>可达但无用</strong>）,这样会造成程序能使用的内存越来越少,内存空间就这么一点点被蚕食,再去申请就会没有多余的内存,会使程序抛出 OOM 异常,导致内存溢出</p><p>溢出是代码编写问题,这样无论多少内存,早晚都会被占用光的</p><p>比喻就是：比如有10张纸，本来一人一张，画完自己擦了还回去，别人可以继续画，现在有个坏蛋要了纸不擦不还，然后还跑了找不到人了，如此就只剩下9张纸给别人用了(泄漏)，这样的人多起来后，最后大家一张纸都没有了。(最终溢出)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--OOM的几种情况</title>
    <link href="/2020/3/31/JVM-%E7%9F%A5%E8%AF%86-OOM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <url>/2020/3/31/JVM-%E7%9F%A5%E8%AF%86-OOM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<ul><li><p>堆</p><ol><li><p>内存<strong>溢出</strong> (MemoryOverflow)</p> <a id="more"></a><p>程序中的确需要很多对象,但是没有多余的空间再放入一个新的对象了</p></li><li><p>内存<strong>泄漏</strong> (Memory Leak)</p><p>大量无用的对象产生导致没有空间了</p><p>使用工具查看泄漏对象到 GC Roots 的引用链,从而定位泄漏代码的位置</p></li></ol></li><li><p>栈</p><ol><li>栈扩容时没有办法申请到足够大的空间 (只有允许动态扩展栈容量的虚拟机上才会发生,HotSpot 不可以)</li></ol><ul><li><p>HotSpot 只有在多线程下,才会出现 OOM,而在单线程下,实际上是 StackOverFlowError</p><p>常见的 StackOverFlowError 是请求的栈深度大于实际的栈空间大小,并且发生错误会有明确的堆栈打印</p><p>而在多线程下,操作系统 os 分配给每个进程的内存是有限制的.对于 JVM,主要把这个内存分配给堆和栈</p><p>而如果在多线程下,栈越大,所占用的内存越多,越容易发生 OOM</p><p>如果是产生了过多的线程而导致 OOM 的异常的,且不能减少线程数或者更换64位虚拟机的情况下,就只能通过减少最大堆和减少栈容量来换取更多的线程</p></li></ul></li><li><p>方法区</p><ol><li><p>大量类信息,造成内存溢出</p></li><li><p>其实还包括运行时常量池的内存溢出</p></li></ol></li><li><p>程序计数器是 JVM 唯一没有定义 OOM 的地方</p></li><li><p>直接内存</p><ol><li><p>直接或间接用到了直接内存的地方 (间接用到常见的有 NIO)</p><p>一个明显的特征是 Heap Dump 文件中不会看见明显的异常</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--垃圾收集器</title>
    <link href="/2020/3/30/JVM-%E7%9F%A5%E8%AF%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2020/3/30/JVM-%E7%9F%A5%E8%AF%86-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>基于分代收集理论</h1><a id="more"></a><h2 id="新生代收集器-Minor-GC"><a class="header-anchor" href="#新生代收集器-Minor-GC">⚡</a>新生代收集器 (Minor GC)</h2><h3 id="Serial"><a class="header-anchor" href="#Serial">⚡</a>Serial</h3><ol><li><p>标记-复制算法</p></li><li><p>单线程: 不仅仅是只有一条收集线程,更是进行垃圾收集时必须暂停其他工作线程的工作</p></li><li><p>有 “STOP THE WORLD”,降低用户体验</p></li><li><p>优点是: 简单高效,仍然是 HotSpot 虚拟机客户端模式下的默认新生代收集器</p><p>因为它是所有收集器里额外内存消耗最小的,适用于内存资源受限的场景</p><p>由于没用线程交互的开销,可以获得最高的单线程收集效率</p></li><li><p>推荐搭配 Serial Old 使用</p></li></ol><h3 id="ParNew"><a class="header-anchor" href="#ParNew">⚡</a>ParNew</h3><ol><li><p>标记-复制算法</p></li><li><p>ParNew 实质上是 Serial 收集器的多线程版本</p></li><li><p>ParNew 是 HotSpot 虚拟机服务端模式下的默认新生代收集器</p></li><li><p>ParNew 在单线程的环境下绝对不会有比 Serial 收集器更好的效果</p></li><li><p>ParNew 最先退出历史舞台,只能和 CMS 一起使用</p></li></ol><h3 id="Parallel-Scavenge"><a class="header-anchor" href="#Parallel-Scavenge">⚡</a>Parallel Scavenge</h3><ol><li><p>标记-复制算法</p></li><li><p>多线程,能够并行收集</p></li><li><p>特点是保证一个可控的吞吐量<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>,而 CMS 保证的是一个缩短用户线程的停顿时间</p></li><li><p>也被成为&quot;吞吐量优先收集器&quot;</p></li></ol><h2 id="老年代收集器-Major-GC"><a class="header-anchor" href="#老年代收集器-Major-GC">⚡</a>老年代收集器 (Major GC)</h2><h3 id="Serial-Old"><a class="header-anchor" href="#Serial-Old">⚡</a>Serial Old</h3><ol><li><p>标记-<strong>整理</strong>算法</p></li><li><p>单线程</p></li><li><p>默认是 HotSpot 虚拟机客户端模式下默认的老年代收集器</p></li><li><p>如果在服务端下,有两种用途:</p><ol><li><p>JDK 5 以前,与 Parallel Scavenge 搭配使用</p></li><li><p>另一种就是作为 CMS 收集器发生失败时的后备预案,在并发收集时发生 Concurrent Mode Failure 时使用</p></li></ol></li></ol><h3 id="Parallel-Old"><a class="header-anchor" href="#Parallel-Old">⚡</a>Parallel Old</h3><ol><li><p>Parallel Scavenge 的老年代版本</p></li><li><p>标记-整理算法</p></li><li><p>多线程</p></li></ol><h3 id="CMS-Concurrent-Mark-Sweep"><a class="header-anchor" href="#CMS-Concurrent-Mark-Sweep">⚡</a>CMS (<strong>Concurrent Mark Sweep</strong>)</h3><ol><li><p>Old GC, CMS 独有</p></li><li><p>标记-<strong>清除</strong>算法</p></li><li><p>以获取最短回收停顿时间为目标</p></li><li><p>运作过程更复杂</p><ol><li><p>初始标记</p><p>仅仅标记 GC Roots 能够关联到的对象,速度快</p></li><li><p>并发标记</p><p>从 GC Roots 的直接关联对象开始遍历整个对象图,耗时长但是不用停顿用户线程</p></li><li><p>重新标记</p><p>修正并发标记期间,因用户线程继续运作而导致标记变动的一部分对象的标记记录,停顿时间比初始标记时间稍长</p></li><li><p>并发清除</p><p>清理删除掉已经标记死亡的对象</p></li></ol><p>初始标记和重新标记两个过程仍然需要 “Stop The World”</p></li><li><p>缺点:</p><ol><li><p>面向并发的程序对处理器资源比较敏感</p><p>虽然并发阶段不会导致用户线程停顿,但是由于占用了一部分资源,会导致应用程序变慢,降低总吞吐量</p></li><li><p>无法处理&quot;浮动垃圾&quot;</p><p>浮动垃圾是由于在并发标记和并发清除阶段,用户线程继续产生的垃圾对象,而此次垃圾收集不能回收他们,只能等到下一次再清除</p><p>而且需要留足够的内存空间提供给用户线程使用,因此 CMS 收集器不能像其他收集器那样,等老年代几乎完全满了再进行收集</p><p>如果预留内存无法满足程序分配新对象的需要,有可能出现 “Concurrent Mode Failure” 失败,此时虚拟机就会启动预备方案,临时启用 Serial Old 收集器执行 GC,但这样停顿时间就很长了</p></li><li><p>标记-清除产生的大量空间碎片</p><p>无法找到足够大的连续空间分配大对象,而不得不产生另一次完全 “Stop the World” 的 Full GC</p></li></ol></li></ol><!-- # 不分代垃圾收集 --><h2 id="其他"><a class="header-anchor" href="#其他">⚡</a>其他</h2><h3 id="G1-Garbage-First"><a class="header-anchor" href="#G1-Garbage-First">⚡</a>G1 (Garbage First)</h3><ol><li><p>Mixed GC</p></li><li><p>被 Oracle 称为&quot;全功能的垃圾收集器&quot;</p></li><li><p>不再分代收集,而是面向整个堆的任何部分组成回收集 Set 进行回收,同时也是面向局部收集</p><p>注意,收集范围还是整个堆,但将堆划分为每一个 Region 看做是一个局部,每个 Region 代表不同的代,具体是哪个代是动态的,而不是像以前那样的要么是新生代,要么是老年代,要么是整个堆</p><p>即以前都是什么区域决定什么对象,现在是<strong>对象决定区域</strong></p></li><li><p>是否回收衡量标准不是代数,而是哪块内存的多少,是回收的经验时间,即回收的收益大小</p><p>通过维护这样一个优先级列表,每次回收价值更大的对象</p></li><li><p>每一个 Region 可以扮演, Eden, Survivor, Major 或者 Humongous 区域</p></li><li><p>运作过程</p><ol><li><p>初始标记</p><p>仅仅标记 GC Roots 能直接关联的对象,暂停用户线程,但耗时较短</p></li><li><p>并发标记</p><p>唯一不用暂停用户线程的阶段</p><p>从 GC Roots 开始对堆中的对象进行可达性分析,递归扫描整个对象的对象图</p></li><li><p>最终标记</p><p>短暂暂停用户线程,用于处理并发标记时有引用变动的对象</p></li><li><p>筛选回收</p><p>更新 Region 的统计数据,对各个 Region 的回收价值和成本进行排序</p><p>根据用户期望的停顿时间来制定回收计划,可以把一部分 Region 的存活对象复制到空的 Region 当中,再清理旧 Region</p><p>并且,由于是按照 Region 清理,G1 不会产生内存碎片!</p></li></ol></li><li><p>里程碑:通过追求能够应付应用的内存分配速率</p><p>不追求一次把整个 Java 堆全部清理干净,而只要保证收集的速度能跟得上对象分配的速度就能工作的很完美</p></li><li><p>特点总结:</p><ol><li><p>不分代</p></li><li><p>建立可预测的时间停顿模型,可以指定最大停顿时间</p></li><li><p>分 Region 的布局,不会产生空间碎片</p></li><li><p>按照收益回收的红利</p></li></ol></li><li><p>缺点:</p><ol><li><p>内存占用大</p><p>和 CMS 一样,使用卡表来处理跨区指针,但是比 CMS 更加复杂,占用堆的20%空间甚至更多</p></li><li><p>执行负载</p><p>G1 除了使用写屏障来更新卡表之外,还为了实现原始快照搜索(STAB)算法,用写屏障来跟踪并发时的指针变化情况,导致用户线程在执行阶段有额外的负担</p></li></ol></li></ol><h2 id="低延迟垃圾收集器"><a class="header-anchor" href="#低延迟垃圾收集器">⚡</a>低延迟垃圾收集器</h2><p>几乎整个工作过程都是并发的,只有在初始标记,最终标记阶段有短暂的停顿,且停顿时间基本固定</p><h3 id="Shenandoah"><a class="header-anchor" href="#Shenandoah">⚡</a>Shenandoah</h3><ol><li><p>和 G1 有很多相似的地方</p><p>内存布局 初始标记,并发标记的思路 …</p></li><li><p>G1 就是由于合并了 Shenandoah 的代码才能获得多线程 Full GC 的支持</p><p>G1 修改的代码也会反映到 Shenandoah 上面</p></li><li><p>相比 G1 的改进</p><ol><li><p>G1 的筛选回收阶段是多线程并行但不是并发的,而 Shenandoah 可以</p></li><li><p>默认不使用分代收集</p></li><li><p>G1 中的记忆集变成了连接矩阵的全局数据结构 —— 二维表,减少维护消耗</p></li></ol></li><li><p>运作过程</p><ol><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记</p></li><li><p><strong>并发清理</strong></p><p>清理那些整个 Region 连一个存活对象都没有的</p></li><li><p><strong>并发回收</strong> (核心)</p><p>先把回收集里面的存活对象复制到未被使用的 Region</p><p>但是这个复制对象的过程是在并发时完成的, 就可能会出现一边复制,一边读的问题</p><p>而它是通过读屏障和被称为 Brooks Pointers 的转发指针来解决的</p></li><li><p>初始引用更新</p><p>把所有指向旧对象的引用修正到复制到的新地址</p><p>只是建议一个线程集合点,会产生短暂的暂停</p></li><li><p><strong>并发引用更新</strong></p><p>真正开始引用更新,不再需要沿着对象图进行搜索,只需要按照内存物理地址的顺序,顺序搜索出引用类型</p></li><li><p>最终引用更新</p><p>修正 GC Roots 中的引用</p></li><li><p>并发清理</p><p>经过并发回收和引用更新之后,整个回收集中所有的 Region 已再无存活对象, 最后再调用一次并发清理过程回收 Region 的空间</p></li></ol><ul><li><p>关于 Brooks Pointers</p><p>其实原来的解决方案是设置自陷陷阱,主动触发异常,再进入预设好的异常处理器中,再由代码逻辑吧访问转发到复制后的对象上.但是如果没有操作系统的支持,会导致用户态频繁转到内核态,代价很大</p><p>而在原有对象布局结构的最前面统一增加一个新的引用字段,在不处于并发移动的i情况下,该引用指向自己</p><p>这样,当对象有了一份新的副本时,只需要就对象指针的值,指向新对象.只要就对象的内存依然存在,虚拟机内存中所有通过旧引用地址访问代码便仍然可用,都会被转发到新对象上继续工作</p><ul><li><p>但是请注意,这个设计导致了必然会出现多线程竞争问题</p><p>例如当复制对象完成后,用户修改了旧对象,收集器线程才刚刚更新指针</p><p>所以,对指针转发的操作必须采用同步措施,在统一时间内只能让用户线程或者收集器线程其中之一访问</p></li><li><p>还有一点是执行频率问题</p><p>在面向对象编程的语言中,对象访问是非常重要的,非常频繁的,而 Shenandoah 同时设置读,写屏障,带来了数量庞大的性能开销</p></li></ul></li></ul></li></ol><h3 id="ZGC"><a class="header-anchor" href="#ZGC">⚡</a>ZGC</h3><ol><li><p>染色指针技术,将指针的高四位提取出来存储四个标志信息</p></li><li><p>运作过程</p><p>ZGC 的四个大阶段都是可以并发执行的,仅仅两个阶段中间会有短暂的停顿用户线程</p><ol><li><p>并发标记</p><p>和 G1, Shenandoah 类似,只不过标记是在指针上而不是在对象上进行的</p></li><li><p>并发预备重分配</p><p>根据特定的查询条件统计要清理的 Region, 将这些 Region 重新组成分配集,准备复制到其他的 Region 中</p></li><li><p>并发重分配 (核心)</p><p>把重分配集中的存活对象复制到新的 Region 上,并为重分配集中的每个 Region 维护一个转发表,记录从旧对象到新对象的转发关系</p><p>如果用户线程此时访问了位于重分配集中的对象,这次访问将会被预置的内存屏障所截获,然后立即根据 Region 上的转发表记录,将访问转发到新复制的对象,这种行为成为指针的 “自愈”</p><p>相比 Shenandoah 的转发指针,每次都会有转发的固定开销,ZGC 运行时的负载比 Shenandoah 要低一些</p></li><li><p>并发重映射</p><p>修正整个堆中只想重分配集中旧对象的所有引用,类似 Shenandoah 的并发引用更新</p><p>但是 ZGC 这个任务并不是那么迫切的,因为即使是旧引用,也是可以自愈的,也不过是一次转发和修正</p><p>因此,ZGC 把这个阶段的工作合并到了下一次垃圾收集的并发标记阶段,节省了一次遍历所有对象图的开销</p></li></ol></li></ol><ul><li><p>优点</p><p>由于 ZGC 完全没有记忆集,甚至没有分代,所以给用户线程的运行负担小很多</p></li><li><p>缺点</p><ol><li><p>ZGC 对整个堆回收的速度较慢,但是由于对象的分配速率很高,并且很多朝生夕灭,但是在此时又被当作是存活对象,没有标记回收,导致产生了很多浮动垃圾</p><p>因为较长的回收时间,和高速产生的对象,并且这个过程如果持续维持的话,堆中能够用于腾挪的空间会越来越小</p><p>目前解决办法是尽可能的增加堆的大小,但是要本质上解决,还是必须引入分代收集理论,将对象都在一个专门的区域创建,然后专门对这个区域进行更快,更频繁的收集</p></li></ol></li></ul><h3 id="Epsilon"><a class="header-anchor" href="#Epsilon">⚡</a>Epsilon</h3><p>不能够进行垃圾收集</p><h1>垃圾收集器的范围</h1><ul><li><h2 id="Partial-GC"><a class="header-anchor" href="#Partial-GC">⚡</a>Partial GC</h2><ul><li><h3 id="Minor-GC-Young-GC"><a class="header-anchor" href="#Minor-GC-Young-GC">⚡</a>Minor GC / Young GC</h3><p>仅仅是收集新生代</p></li><li><h3 id="Old-GC-CMS-独有模式"><a class="header-anchor" href="#Old-GC-CMS-独有模式">⚡</a>Old GC (CMS 独有模式)</h3><p>收集老年代</p></li><li><h3 id="Major-GC"><a class="header-anchor" href="#Major-GC">⚡</a>Major GC</h3><p>同 Old GC,收集老年代</p></li><li><h3 id="Mixed-GC-G1-独有模式"><a class="header-anchor" href="#Mixed-GC-G1-独有模式">⚡</a>Mixed GC (G1 独有模式)</h3><p>目标是收集整个新生代和老年代</p></li></ul></li><li><h2 id="Full-GC-Major-GC"><a class="header-anchor" href="#Full-GC-Major-GC">⚡</a>Full GC / Major GC</h2><p>收集整个 Java 堆和方法区</p></li></ul><p>注意:</p><blockquote><p>Major GC 有不同语义,要弄清楚到底是指与 Full GC 同样的整个堆和方法区的收集,还是值与 Old GC 类似的仅仅老年代堆的收集</p></blockquote><h1>并发和并行</h1><ol><li><p>并行 (Parallel): 多条垃圾收集器线程之间的关系,说明同一时间有多条这样的线程在协同工作,通常默认用户线程此时处于等待状态</p></li><li><p>并发 (Concurrent): 描述的是垃圾收集器线程和用户线程之间的关系,说明同一时间垃圾收集器线程和用户线程都在运行,但由于垃圾收集器线程占用了一部分系统资源,应用程序虽然还行响应,但是吞吐量会受到一定影响</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>吞吐量=(运行用户代码时间)/(运行用户代码+_垃圾收集的时间) <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发知识-硬件内存架构</title>
    <link href="/2020/3/29/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/3/29/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86-%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="CPU-工作机制"><a class="header-anchor" href="#CPU-工作机制">⚡</a>CPU 工作机制</h2><p>CPU 速度快,但是数据存放到内存中,而内存相对较慢,所以 CPU 中间加上 cache 多级高速缓存来提升数据读取速度</p><a id="more"></a><p><img src="/img/CPU.png" srcset="/img/loading.gif" alt="CPU"></p><h3 id="cache-缓存工作机制"><a class="header-anchor" href="#cache-缓存工作机制">⚡</a>cache 缓存工作机制</h3><ol><li><p>当 CPU 要去读取一个数据时,会先去缓存中查找,找不到再去内存中找</p></li><li><p>在内存中找到了,同时把这个数据所在的数据快调入缓存中</p><p>即把临近的共64 byte 的数据一同载入,因为临近的数据可能被访问的几率更大,下次就可以直接在缓存中查找数据,这样就增加了缓存的<strong>命中率</strong>(cache hit)了</p></li></ol><h3 id="CPU-缓存一致性问题"><a class="header-anchor" href="#CPU-缓存一致性问题">⚡</a>CPU 缓存一致性问题:</h3><p>如上图所示,cache 之和特定的 CPU 进行通信,多核 CPU 就会出现并发问题: 一个线程在读,另一个在写,导致数据不一致问题</p><ul><li>解决方案:<ol><li><p>总线锁</p><p>使用 CPU 提供的一个 LOCK# 信号,当一个处理器在总线上输入此信号,其他处理器的请求将被阻塞,那么该处理器就可以独占共享锁</p> <span class="label label-danger">todo为什么是共享锁?</span><p>粒度比较大,会降低 CPU 的吞吐量 [1]</p></li><li><p>缓存锁(缓存一致加锁)</p><p>控制锁的粒度,核心是缓存一致协议,不同的 CPU 厂商有不同的实现方式,例如 MESI: 当修改变量时,如果数据是共享变量,会将 cache line 置为无效,所以其他的 CPU 就从内存中读数据,不会再去 cache 中读取数据</p> <!-- <span class="label label-danger">todo解决了可见性,但是无法保证同步?</span> --></li></ol></li></ul><h3 id="线程和硬件架构"><a class="header-anchor" href="#线程和硬件架构">⚡</a>线程和硬件架构</h3><p>进程 -&gt; 线程 -&gt; os 内核线程 -&gt; CPU 线程</p>]]></content>
    
    
    
    <tags>
      
      <tag>concurrent</tag>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 知识--JVM 内存区域</title>
    <link href="/2020/3/29/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <url>/2020/3/29/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-内存区域"><a class="header-anchor" href="#Java-内存区域">⚡</a>Java 内存区域</h2><ol><li>Java 虚拟机在执行 Java 程序的过程中将它所管理的内存区域分成若干个不同的数据区域,称为 Java 内存区域.(<strong>即运行时数据区</strong>)</li></ol><a id="more"></a><ol><li><p>分为五个部分:</p><p><code>程序计数器</code>,<code>虚拟机栈</code>,<code>本地方法栈</code>,<code>Java 堆</code>,<code>方法区</code></p><p>其中前三个是线程隔离的,后两个是线程共享的</p><p>其实还有<code>直接内存</code>是线程共享的,不过直接内存不属于 Java 运行时的内存区域</p></li><li><p>特别的,在 JDK 1.8 之后,原本也被称为永久代的方法区,就不要再称呼为永久代了,因为已经由一个叫做元空间的东西来实现了.</p></li></ol><h3 id="具体的每一个部分"><a class="header-anchor" href="#具体的每一个部分">⚡</a>具体的每一个部分:</h3><ol><li><p>程序计数器</p><p>它占用一小块内存空间,可以看作是当前线程所执行的字节码的行号指示器</p><p>Java 虚拟机的多线程是通过线程轮流切换,分配处理器执行时间的方式来实现的,因此,为了让每条线程切换后都能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,让各个线程的执行不相互影响</p><p><code>字节码解释器</code> 工作时就是通过改变这个计数器来选取下一条需要执行的字节码指令</p><p>JVM 内存区域中唯一一个没有定义 OOM 的区域</p></li><li><p>方法区:</p><ul><li><p>存储: 类信息,常量,static 变量, JIT (Java 即时编译)</p></li><li><p>JIT 即时编译</p><p>对象被拆散为标量类型间接地在栈上分配内存</p></li><li><p>JDK 7 以前还叫 永久代, JDK 8 之后就是元空间,其实都是对方法区的实现</p><p>但是注意,元空间实际上不属于虚拟机内存,而是本地内存</p><ol><li><p>为什么改变:</p><ol><li><p>首先是 JDK 8 是 HotSpot 为了融合 JRocket 虚拟机,后者没有永久代</p></li><li><p>永久代经常用空间不够而发生内存溢出(MemoryOverflow),更换成永久代之后,元空间大小之取决于本地内存大小,减少 OOM 的发生</p></li></ol></li></ol></li></ul></li><li><p>Java 堆 (别名 GC 堆)</p><ul><li><p>存储:实例对象</p></li><li><p>具体还可分为:</p><ol><li><p>Eden</p></li><li><p>from survivor</p></li><li><p>to survivor</p><p>GC 发生前, to survivor 区一定是清空的</p><p>GC 时,首先把 Eden 区的对象 复制到 to survivor,对于 from survivor 要进行判断是否达到年龄阈值,如果达到了,就直接复制到老年代,没有则还是复制到 to survivor 区,并且此时对象年龄加一</p><p>如果 to survivor 区满了,那么直接把剩余的对象放入到老年代中</p><p>复制阶段完成后,可以视为 Eden 区 和 from survivor 区全部是死对象,最后 from 和 to 区会调换名字,在下次 GC 时, to 会变成 from</p></li><li><p>old</p></li></ol></li><li><p>对象分配规则</p><ol><li><p>对象优先分配在新生代 Eden 区，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC</p></li><li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）</p><p>这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>长期存活的对象进入老年代</p><p>虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加1，知道达到阀值对象进入老年区。</p><p>注意: JDK 7 可以设置年龄超过15,JDK 8 不可以,暂时不知道原因</p><p>不可以超过15很好理解:</p><p>对象头的 mark word 只设置了4个位来存储年龄信息,2^5-1=15,最多把一个字节用完也只能存到15</p></li><li><p>动态判断对象的年龄</p><p>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p></li><li><p>空间分配担保机制</p><p>每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC，如果小于检查 HandlePromotionFailure 设置，如果 true 则只进行 Minor GC ,如果false则进行Full GC。</p></li></ol></li></ul></li><li><p>虚拟机栈区 (内存模型)</p><p>是 Java <strong>方法</strong> 的运行时 <strong>内存模型</strong> Java Memory Model</p><p>因为线程之间的通信是通过 JMM 控制的</p><p>每一个栈帧对应一个方法,每一个方法的调用到执行完成就对应着一个栈帧在虚拟机从入栈到出栈的过程</p><p>栈帧中有: 局部变量表,操作数栈,动态连接,方法出口</p><p>局部变量表包括: <strong>基本数据类型,对象引用(可以是对象起始地址的引用指针,也可能是代表对象的句柄)</strong></p><p>局部变量表所需的内存在<strong>编译期间</strong>完成分配,分配多大空间是完全确定的,运行期间不会改变局部变量表的大小</p><p>注意:</p><blockquote><p>这里我之前不理解为什么是不会在运行时改变局部变量表的大小的,例如在 while- true 的循环里面,一直 new 对象,这个不就是动态增加的吗,数量是不确定的</p><p>然后我发现,new 对象是要显式赋值给一个引用对象的,或者加入到 list 里面,前者对象引用就在局部变量表里面,后者的引用则通过 list 的起始地址或者数组下标可以找到每个对象,实际上还是在局部变量表里面,没有区别</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 源码之 Spring @Bean 和 @Component</title>
    <link href="/2020/3/21/Spring-%E6%BA%90%E7%A0%81%E4%B9%8B-Spring-Bean-%E5%92%8C-Component/"/>
    <url>/2020/3/21/Spring-%E6%BA%90%E7%A0%81%E4%B9%8B-Spring-Bean-%E5%92%8C-Component/</url>
    
    <content type="html"><![CDATA[<h2 id="我的理解"><a class="header-anchor" href="#我的理解">⚡</a>我的理解</h2><p>当学习 Spring 框架的时候,我们会使用 Java configuration + annotation 的方法配置依赖,例如使用 @Component 注解在 Service,dao,mapper 等类, 这样来注册给 IoC 容器,让它来管理这个 Bean 并且自动装配所需要的依赖</p><a id="more"></a><p>但是有个问题,@Component 也是用于 Bean 上,那么 @Bean 注解又是什么呢?</p><p>首先我们要知道 @Bean 在什么情况下会用到:</p><p>对于我们自己手动写的类,可能直接在类上加入 @Component 注解就可以直接让 Spring IoC 容器来管理对象的产生了</p><p>但是,对于需要用到的第三方的组件,这种情况下,除非将它的开源的代码重新整合到项目里面,否则我没有办法在它的 jar 包中的 class 文件反编译后的 Java 文件的类上加入 @Component 注解,但是这种整合源码的方法肯定是不可能的</p><p>而如果不加入 @Component ,我们自己去 new 这个对象也可以,这个时候就需要我们自己去管理这个对象,相当于做了一部分 IoC 容器做到事情,这样还是不太好</p><p>而且,如果这个对象还需要一些依赖,有些依赖甚至还需要从 Spring IoC 容器管理的依赖去取,自己管理的方法就不行了</p><p>也就是说,我们需要自己完成这个第三方对象的创建,但是,虽然创建我只需要 new Class() 就可以了,但是我还需要把这个创建好的对象交给 Spring IoC 容器来管理</p><p>此时,我们就可以在配置类上加上 @Configuration 注解,然后在创建对象的方法上面加上 <code>@Bean</code> 注解 (并且这个方法返回这个对象),这样就把我们手动生成的对象交给 Spring 的 IoC 容器进行管理了,如果这个类还需要依赖,只要你把所需要的依赖作为参数声明到方法上, Spring IoC 容器就可以将依赖自动传给这个方法,进而把依赖注入给这个类</p><hr><h2 id="官方文档"><a class="header-anchor" href="#官方文档">⚡</a>官方文档</h2><blockquote><p>The central artifacts in Spring’s new Java-configuration support are @Configuration-annotated classes and @Bean-annotated methods.</p><p>Spring 的新 Java Configuration支持中的主要构件是 @Configuration 注释的类和 @Bean 注释的方法。</p></blockquote><p>这句话意思是,@Configuration 和 @Bean 是 Spring 的 Java Configuration 编码方式中提供支持的</p><blockquote><p>The @Bean annotation is used to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring’s <beans/> XML configuration, the @Bean annotation plays the same role as the <bean/> element. You can use @Bean-annotated methods with any Spring @Component. However, they are most often used with @Configuration beans.</p><p>@Bean批注用于指示方法实例化，配置和初始化要由Spring IoC容器管理的新对象。对于那些熟悉Spring的<beans /> XML配置的人来说，@ Bean注释与<bean />元素具有相同的作用。您可以将@Bean注释的方法与任何Spring @Component一起使用。但是，它们最常与@Configuration bean一起使用。</p></blockquote><p>这段话是说,@Bean 可以等同于使用 Spring schema 编码方式中的 xml 中的 <code>&lt;bean&gt;</code></p><blockquote><p>Annotating a class with @Configuration indicates that its primary purpose is as a source of bean definitions. Furthermore, @Configuration classes let inter-bean dependencies be defined by calling other @Bean methods in the same class.</p><p>用@Configuration注释类表示该类的主要目的是作为Bean定义的来源。此外，@Configuration类允许通过调用同一类中的其他@Bean方法来定义Bean间的依赖关系。</p></blockquote><h3 id="Full-Configuration-vs-“lite”-Bean-mode"><a class="header-anchor" href="#Full-Configuration-vs-“lite”-Bean-mode">⚡</a>Full @Configuration vs “lite” @Bean mode?</h3><blockquote><p>When @Bean methods are declared within classes that are not annotated with @Configuration, they are referred to as being processed in a “lite” mode. Bean methods declared in a @Component or even in a plain old class are considered to be “lite”, with a different primary purpose of the containing class and a @Bean method being a sort of bonus there. For example, service components may expose management views to the container through an additional @Bean method on each applicable component class. In such scenarios, @Bean methods are a general-purpose factory method mechanism.</p><p>如果在未使用@Configuration注释的类中声明@Bean方法，则将它们称为以“精简”模式进行处理。在@Component或甚至在 POJO 中声明的Bean方法被认为是“精简版”，其中包含类具有不同的主要用途，而@Bean方法在那里具有一定的优势。例如，Service 组件中可以通过每个适用组件类上的其他@Bean方法将管理视图公开给容器。在这种情况下，@ Bean方法是一种通用的<strong>工厂方法</strong>机制。</p></blockquote><blockquote><p>Unlike full @Configuration, lite @Bean methods cannot declare inter-bean dependencies. Instead, they operate on their containing component’s internal state and, optionally, on arguments that they may declare. Such a @Bean method should therefore not invoke other @Bean methods. Each such method is literally only a factory method for a particular bean reference, without any special runtime semantics. The positive side-effect here is that no CGLIB subclassing has to be applied at runtime, so there are no limitations in terms of class design (that is, the containing class may be final and so forth).</p><p>与完整的@Configuration不同，lite @Bean方法无法声明Bean之间的依赖关系。取而代之的是，它们在其包含组件的内部状态上进行操作，并且还可以根据可能声明的自变量进行操作。因此，一个@Bean方法不应调用其他@Bean方法。每个此类方法实际上只是针对特定bean引用的工厂方法，而没有任何特殊的运行时语义。这里的积极副作用是，不必在运行时应用CGLIB子类，因此在类设计方面没有任何限制（即，包含类可以是最终类，依此类推）。</p></blockquote><blockquote><p>In common scenarios, @Bean methods are to be declared within @Configuration classes, ensuring that “full” mode is always used and that cross-method references therefore get redirected to the container’s lifecycle management. This prevents the same @Bean method from accidentally being invoked through a regular Java call, which helps to reduce subtle bugs that can be hard to track down when operating in “lite” mode.</p><p>在常见情况下，@ Bean方法将在@Configuration类中声明，以确保始终使用“完全”模式，因此跨方法引用将重定向到容器的生命周期管理。这样可以防止通过常规Java调用意外地调用同一@Bean方法，这有助于减少在“精简”模式下运行时难以跟踪的细微错误。</p></blockquote><h2 id="Bean-使用"><a class="header-anchor" href="#Bean-使用">⚡</a>@Bean 使用</h2><blockquote><p>You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.</p><p>你可以在 <strong><code>@Configuration</code></strong> 注释的类或 <strong><code>@Component</code></strong> 注释的类中使用@Bean注释。</p></blockquote><p>例如</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferServiceImpl <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();    &#125;&#125;</code></pre></div><blockquote><p>However, this limits the visibility for advance type prediction to the specified interface type (TransferService). Then, with the full type (TransferServiceImpl) known to the container only once, the affected singleton bean has been instantiated. Non-lazy singleton beans get instantiated according to their declaration order, so you may see different type matching results depending on when another component tries to match by a non-declared type (such as @Autowired TransferServiceImpl, which resolves only once the transferService bean has been instantiated).</p><p>但是，这将高级类型推断的功能的可见性限制为指定的接口类型（TransferService）。然后，仅使容器明白完整类型（TransferServiceImpl）一次，就可以实例化受影响的单例bean。非懒惰单例bean根据其声明顺序实例化，<strong>因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试通过未声明的类型进行匹配</strong>（例如@Autowired TransferServiceImpl，仅当transferService bean具有被实例化）。</p></blockquote><blockquote><p>If you consistently refer to your types by a declared service interface, your @Bean return types may safely join that design decision. However, for components that implement several interfaces or for components potentially referred to by their implementation type, it is safer to declare the most specific return type possible (at least as specific as required by the injection points that refer to your bean).</p><p>如果您通过声明的服务接口一致地引用同一类型，则@Bean返回类型可以安全地加入该设计决策。但是，<strong>对于实现多个接口的组件</strong>或由其实现类型潜在引用的组件，声明可能的<strong>最具体的返回类型</strong>（至少与引用您的bean的注入点所要求的具体类型一样）更为安全。</p></blockquote><blockquote><p>A @Bean-annotated method can have an arbitrary number of parameters that describe the dependencies required to build that bean. For instance, if our TransferService requires an AccountRepository, we can materialize that dependency with a method parameter, as the following example shows:</p><p>@Bean注释的方法可以具有任意数量的参数，这些参数描述构建该bean所需的依赖关系。例如，如果我们的TransferService需要一个AccountRepository，则可以使用方法参数来实现该依赖关系，如以下示例所示：</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">(AccountRepository accountRepository)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(accountRepository);    &#125;&#125;</code></pre></div><h2 id="Configuration-的使用"><a class="header-anchor" href="#Configuration-的使用">⚡</a>@Configuration 的使用</h2><blockquote><p>@Configuration is a class-level annotation indicating that an object is a source of bean definitions. @Configuration classes declare beans through public @Bean annotated methods. Calls to @Bean methods on @Configuration classes can also be used to define inter-bean dependencies.</p><p>@Configuration是类级别的注释，指示对象是Bean定义的源。@Configuration类通过公共@Bean注释方法声明bean。对@Configuration类的@Bean方法的调用也可以用于定义Bean之间的依赖关系。</p></blockquote><blockquote><p>This method of declaring inter-bean dependencies works only when the @Bean method is declared within a @Configuration class. You cannot declare inter-bean dependencies by using plain @Component classes.</p><p>仅当在@Configuration类中声明@Bean方法时，此声明bean间依赖性的方法才有效。您不能使用普通的@Component类声明Bean间的依赖关系。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据源和数据连接池</title>
    <link href="/2020/3/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/2020/3/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="数据源"><a class="header-anchor" href="#数据源">⚡</a>数据源:</h2><a id="more"></a><p>简单理解为数据源头，提供了应用程序所需要数据的位置。它是连接到实际数据库的一条路径而已，数据源中并无真正的数据，它仅仅记录的是你连接到哪个数据库，以及如何连接的</p><p>数据源保证了应用程序与目标数据之间交互的规范和协议，目标数据的存储可以是数据库，文件系统等等。</p><p>数据源定义了位置信息，用户验证信息和交互时所需的一些特性的配置，同时它封装了如何建立与数据源的连接，向外暴露获取连接的接口。</p><p>应用程序连接数据库无需关注其底层是如何如何建立的，也就是说应用业务逻辑与连接数据库操作是松耦合的。</p><p>数据源大致分为2种：不提供数据连接池和提供数据连接池管理。</p><h2 id="数据连接池"><a class="header-anchor" href="#数据连接池">⚡</a>数据连接池</h2><ul><li><p>JDBC操作的步骤：</p><ol><li><p>加载驱动程序</p></li><li><p>连接数据库</p></li><li><p>操作数据库</p></li><li><p>关闭数据库，释放连接</p></li></ol><p>但是当与数据库交互频繁时，这种模式会严重影响程序的性能。时间和空间消耗大多数消耗在连接和销毁中，而非数据库处理。</p><p>Spring 默认的 <code>Spring-jdbc</code> 的 DriverManagerDataSource 就是不提供连接池的,该数据源对于应用程序的每一个连接请求都建立新的连接，当应用程序使用完毕后，再执行销毁操作。</p></li><li><p>使用数据库连接池</p><p>数据库连接是负责分配、管理和释放数据库连接。数据库连接池里专门保存着全部的数据库连接，以后用户用数据库操作的时候不用再重新加载驱动、连接数据库之类的，而直接从此空间中取走连接，关闭的时候直接把连接放回到此空间之中。</p><p>Spring Boot 是采用 HikariCP 来作为默认的数据源。</p></li></ul><h2 id="Spring-中的常用数据访问技术"><a class="header-anchor" href="#Spring-中的常用数据访问技术">⚡</a>Spring 中的常用数据访问技术</h2><ol><li><p>JDBC</p><p>Java数据库连接，（Java Database Connectivity，简称 JDBC ）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序<strong>接口</strong>，用于在 Java 语言编程中与数据库连接的 API</p><p>也就是说,JDBC是一个规范，它提供了一整套接口( 是 API 而不是 interface ,但是只是低级 API 或者叫底层 API,因为它直接调用 SQL 命令 ,其他有各自封装好 JDBC 的高级 API, 例如 JDBI)，允许以一种可移植的访问底层数据库 API。使用 JDBC 驱动程序来访问数据库，并用于存储数据到数据库中.</p></li><li><p>Spring Data JPA</p><p>Spring Data JPA 基于 Hibernate，而 Hibernate 是一个让人又爱又恨的技术。</p><p>同原生 JDBC 相比，Hibernate 极大地简化了开发工作量；但另一方面，因为 Dirty Check、延迟加载、各种如 ManyToOne 等映射规则，又让 Hibernate 成为了一个复杂技术。而这些复杂性，平时很少直接用到，但是却增加了 Hibernate 的开发和调试难度。</p></li><li><p>Spring Data JDBC</p><p>Spring Data JDBC 的目的是为了给基于 JDBC 的数据库应用提供 Repository 封装。</p><blockquote><p>简单说，就是为了让大家用到类似于 Spring Data JPA 中 JpaRepository 的功能，但是不引入任何ORM框架。</p></blockquote><p>也就是我们经常在代码里看到 JDBCTemplate 这个辅助类进行开发</p></li><li><p>MyBatis</p><p>和 Hibernate 一样是第三方 ORM 数据库框架。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。</p><p>注意:</p><blockquote><p>Hibernate是全自动ORM框架，而Mybatis是半自动的。hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 开发规范</title>
    <link href="/2020/3/18/Java-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <url>/2020/3/18/Java-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<ol><li>重写构造方法的时候一定要重写默认的空构造方法</li></ol><a id="more"></a>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 源码之-Spring IOC 的应用</title>
    <link href="/2020/3/17/Spring-%E6%BA%90%E7%A0%81%E4%B9%8B-Spring-IOC-%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/3/17/Spring-%E6%BA%90%E7%A0%81%E4%B9%8B-Spring-IOC-%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Spring 实现IoC的思路和方法</p> <a id="more"></a><ol><li><p>Spring 实现 IoC 是通过配置信息来描述类与类之间的配置关系,然后由去解析这些配置信息</p><p>具体步骤:</p><ol><li><p>应用程序中提供类和依赖对象</p></li><li><p>通过配置,把所有需要用到的类交给容器 (schema,annotation,Java configuration)</p></li><li><p>再描述一遍类和依赖对象的关系</p></li></ol></li></ol></li><li><p>Spring IoC 使用例子:</p><ol><li><p>方式一: schema</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 声明类 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexDaoImpl"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 声明类 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"service"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexService"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 声明依赖对象 --&gt;</span>        <span class="hljs-comment">&lt;!-- 方法一: 基于 setter 方法,** name 和属性名无关,只和 setter 方法名有关** --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dao"</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- 方法二: 基于构造函数 --&gt;</span>        <span class="hljs-comment">&lt;!-- &lt;constructor-arg ref="dao"/&gt;--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>但是请注意,这里有一个很坑的点,或者说我基础不扎实的地方:</p><blockquote><p>当使用方法一的时候,不要写任何构造器,因为如果不写还好,JVM 可以自动给你生成默认的空构造方法</p><p>但是如果写了带依赖参数的构造器,那么 JVM 将不会为你生成默认的空构造方法,这样使用 setter 注入会报错 <code>No default constructor found</code></p><p>所以要么就不写带参数的构造方法(不和 <code>构造函数注入</code> 混用),要么,就再写上无参构造函数</p></blockquote> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 在主函数里面使用 ClassPathXmlApplicationContext 传入这个 xml 配置文件</span>ClassPathXmlApplicationContext classPathXmlApplicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:spring.xml"</span>);<span class="hljs-comment">// getBean 的参数是 service,和类名其实无关,之和 xml 的 id 有关</span>Service Service = (IndexService) classPathXmlApplicationContext.getBean(<span class="hljs-string">"service"</span>);service.test();</code></pre></div></li><li><p>方式二: annotation ( 与 schema 或者 Java Configuration 集成)</p><ol><li><p>方法一:annotation + schema</p><ol><li><p>首先需要开启 Spring 对注解的支持:</p><p>在 xml 里面写上 <code>&lt;context:component-scan base-package=&quot;ind.yinchao.ioc.test1&quot;/&gt;</code></p><p>这样离不开 xml,不太好</p></li></ol></li><li><p>方法二:annotation + Java Configuration 更改主函数的 Context (已经体现 <strong><code>自动装配</code></strong>)</p><p>新建 Java 配置文件</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// @configuration 就是生命这是代替 xml 的配置文件</span><span class="hljs-meta">@Configuration</span>()<span class="hljs-comment">// @componentScan 开启扫描</span><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"ind.yinchao.ioc.test2"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span></span>&#123;&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs java">AnnotationConfigApplicationContext annotationConfigApplicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SpringConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre></div></li></ol><p>然后就可以使用注解了</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//声明类</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-comment">// 声明依赖关系</span>    <span class="hljs-meta">@Autowired</span>    Dao dao;&#125;&lt;!-- 声明类 --&gt;<span class="hljs-meta">@Component</span>(<span class="hljs-string">"dao"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DaoImpl</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"daoImpl1);</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;</span></code></pre></div></li><li><p>方式三: schema + annotation + Java Configuration 混合使用</p><p>在 Java Configuration + annotation 的基础上,在 Java 配置文件类 SpringConfiguration 中加上 <code>@ImportResource(&quot;SpringConfiguration.xml&quot;)</code> 以启用 schema</p></li><li><p>使用 <strong>schema</strong> 的问题:</p><p>如果我们类与类之间有了依赖关系,那么为什么还要在声明类的配置中来再描述一遍依赖对象呢?这样不就冗余了吗</p><p>解决:</p><p>使用 Spring 的 <strong>自动装配</strong> 完成上面的第三步,不需要在第二步完成类的描述之后再去进行冗余的类与依赖对象的描述</p><p>在 xml 配置文件的头部最后加上 <code>default-autowired = &quot;no|byType|byName|construct&quot;</code>,分别对应:</p><ol><li><p>no|default: 不自动装配</p></li><li><p>byType: 自动属性注入</p><p>需要 set 方法</p><p>type: 依赖属性的类型</p></li><li><p>byName 自动名字注入:</p><p>需要 set 方法</p><p>name: set方法按一定规律的名字</p><p>例如 setTest ,那么 xml 中对应的依赖类 id 就为 test</p></li><li><p>自动通过构造方法注入:需要带参构造方法</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在主程序的配置入口处配置 最后加上 default-autowired="byType"--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexDaoImpl"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"service"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ind.yinchao.ioc.test1.IndexService"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dao"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li></ol></li><li><p>使用 annotation + Java Configuration 的问题 (schema 也类似,就不再举例)</p><p>实现类有两个:</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"dao2.1"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexDaoImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IndexDao</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"impl2.1"</span>);    &#125;&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"dao2.2"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexDaoImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IndexDao</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"impl2.2"</span>);    &#125;&#125;</code></pre></div><p>这时如果在 Service 类里面继续写依赖就会报错</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-meta">@Autowired</span>    IndexDao dao&#125;</code></pre></div><blockquote><p>No qualifying bean of type ‘test2.IndexDao’ available: expected single matching bean but found 2: dao2.1,dao2.2</p></blockquote><p>因为 @Autowired 默认是根据 byType 查找,这里出现了两个 IndexDao 的实现,那么就有两个相同的类型,就会出错</p><p>解决:</p><ol><li><p>方法一: @Autowired 是先根据 byType 如果没有找到,会使用 byName</p><p>这样,那我们只需要修改 Service 里面的依赖变量名 dao -&gt; indexDaoImpl1,这样就可以找到 IndexDaoImpl1 这个类了</p><p>注意,和 setter 方法无关</p></li><li><p>使用 @Resource 是根据 byName 查找的,解决方式同上</p></li><li><p>虽然还是使用 @Resource ,这里我们还可以使用 @Qualifier 指定 Bean 的名字</p></li></ol></li><li><p>作用域 Scope</p><p>一个很坑的点: singleton bean 需要 prototype bean 的时候, 被依赖的 prototype bean 可能只会初始化一次,那么 prototype 就失效了</p><p>解决</p><ol><li><p>implement ApplicationContextAware</p><p>需要用到 Spring 的 API 侵入性很强</p></li><li><p>通过 @Lookup(“indexDaoImpl1”)注解</p><p>@Lookup 写在一个 abstract 方法上,并返回依赖</p><p>再将这个类设置为 abstract</p><p>这个类就不需要 @Autowired 或者 @Resource 注解了,直接在外部调用 Service 的方法里面再调用那个 abstract 方法即可</p><p>@Lookup(“indexDaoImpl1”),可以通过指定 bean 来防止有多个同类型的 type</p><p>@Lookup() 实际上是<strong>依赖查找 DL</strong>!</p></li></ol></li><li><p>Bean 生命周期的<strong>回调</strong> (lifecycle callback)</p><p>创建 Bean 时的回调 (销毁时同理)</p><ol><li><p>方式一: 实现 InitializingBean 接口,重写 afterPropertiesSet 方法</p></li><li><p>方法二: 对于基于 xml 的情况,可以在 bean 标签里加上</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">default-init-method</span>=<span class="hljs-string">"init"</span>&gt;</span></code></pre></div><p>并指定方法名</p></li><li><p>方法三: 在方法上写一个注解 @PostConstruct</p></li></ol></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK(8和9) 源码搭建</title>
    <link href="/2020/3/11/JDK(8%E5%92%8C9)%20%E6%BA%90%E7%A0%81%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/3/11/JDK(8%E5%92%8C9)%20%E6%BA%90%E7%A0%81%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="方法一"><a class="header-anchor" href="#方法一">⚡</a>方法一:</h2><p><a href="https://blog.csdn.net/getyouwant/article/details/50428753" target="_blank" rel="noopener">能够用的方法,这样直接修改了源文件,感觉不太好</a></p><a id="more"></a><h2 id="方法二"><a class="header-anchor" href="#方法二">⚡</a>方法二:</h2><ol><li><p>首先去官网下载对应系统版本的 JDK7 和 JDK8</p><p>(因为 JDK 不同版本的实现可能不一样,例如 HashMap 的底层实现由链表改成红黑树,所以下两个版本更保险)</p><p><strong>注意一个很坑的地方:</strong></p><blockquote><p>不要下 Open JDK,之前下载了 OpenJDK7的源码,编译一直报错,但是去官网下载的 OracleJDK8 则没有问题!</p></blockquote></li><li><p>下好后解压,源文件路径在</p><blockquote><p>JDK 根目录(例如:/opt/jdk-8u212-linux-x64/jdk1.8.0_212/src.zip) 的 src.zip 解压后的文件</p></blockquote></li><li><p>IDEA 下创建 maven 项目</p><ol><li><p>创建好项目后,再创建两个 module: jdk7 和 jdk8,分别对应 jdk 的两个版本,对应的 language level 分别设定7和8</p><p>注意:</p><p>新建 module 的父 module 不能为空,一定要是原来的项目 module</p></li><li><p>把下好的源码包完整复制到对应 module 的src文件中,并且在 project structure 里面标记 src 文件夹为 source</p></li></ol></li><li><p>整合依赖</p><ol><li><p>打开 project structure, 找到最左边的 Libraries, 点击 + ,添加一个 新的 Project Library, 找到 jdk7 这个 module 的 src 文件夹,添加</p><p>jdk8 module 同理</p></li><li><p>Modules 侧边栏中， 选择 jdk7 module 上方的 dependencies, 在点击右侧的 + 号,添加 module dependency 可以看到之前添加的 Libraries jdk7,点击添加</p><p>jdk8 module 同理</p></li><li><p><strong>第二坑的环节是这个:</strong> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>上一步 Libraries 添加好对应的 module 后,还必须将后添加的 Library 的顺序排到原来 module JDK 的前面,否则点击对应的类,还是使用 JDK 的字节码反编译后的文件</p></li><li><p>要注意版本,要在每个 module的 pom.xml 文件里面指定 Java 版本(complier version 和 target version)</p><p>例如:</p> <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre></div><p>运行时的环境要比较低,用1.7即可,而 各自 module 的版本可以自由设置更高一些的版本</p></li><li><p>各自的模块编译一段时间没有报错后,就可以愉快的查看对应类的 .java 文件,而非字节码反编译的只读文件,还可以直接在源码上写注释啦!</p></li><li><p>最后,如果想要测试,就可以直接在对应 JDK 的版本的 module 中写测试样例</p></li></ol></li></ol><hr><p>开源项目:</p><ol><li><p>(<a href="https://github.com/kangjianwei/LearningJDK#start-of-content" target="_blank" rel="noopener">https://github.com/kangjianwei/LearningJDK#start-of-content</a>)</p></li><li><p>(<a href="https://github.com/raysonfang/jdk1.8-source-analysis" target="_blank" rel="noopener">https://github.com/raysonfang/jdk1.8-source-analysis</a>)</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/klordy_123/article/details/82915450" target="_blank" rel="noopener">参考博客</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC、DIP、DI</title>
    <link href="/2020/3/10/IOC%E3%80%81DIP%E3%80%81DI/"/>
    <url>/2020/3/10/IOC%E3%80%81DIP%E3%80%81DI/</url>
    
    <content type="html"><![CDATA[<h2 id="控制反转-IOC-Inversion-of-Control"><a class="header-anchor" href="#控制反转-IOC-Inversion-of-Control">⚡</a>控制反转 IOC (Inversion of Control )</h2><ol><li><p><span id="IOC">IoC </span>是面向对象编程中的一种<strong>设计思想</strong>,用于降低代码的耦合度,可以说是一种目的,一个目标</p></li><li><p>IoC 是原则和目标,而具体<strong>实现的方式</strong>有多种,其中最常见的就是依赖注入 (DI) (dependency Injection),其他的方式还有依赖查找 (DP) ( dependency Lookup)和依赖拖拽等</p> <a id="more"></a></li><li><p>实现 IoC 的地方,我们可以称为 IoC 容器</p></li><li><p><span id="dependency">什么是依赖?</span></p><p>依赖是面向对象编程中的一个概念,因为是面向对象编程,一个类 A 可能要用到其它的类 B 的属性或者方法,那么就说 A 依赖 B</p></li><li><p>什么是控制反转?</p><p>如果 A 依赖 B,那么一般来说,我们要么需要在类 A 中显式使用 new 关键字来创建类 B 的对象</p><p>而使用 IoC,我们只需要声明一下我们需要用到哪些对象,不需要显式的通过 new 来生成依赖对象,反而把对象的创建交给一个 IoC 容器处理和<strong>管理</strong></p><ul><li><p>其控制就是指:创建依赖对象</p></li><li><p>反转就是指: 类 A 需要创建依赖对象 B,但是在类 A 里面不显式创建,而是把创建过程交给第三方,第三方创建好之后,在自动传给我(依赖注入,DI),或者我自己去找(依赖查找,dependency lookup,DL),即<strong>反转创建依赖对象这个过程</strong></p></li></ul></li><li><p>为什么要使用 IoC</p><ol><li><p>最主要原因:面向对象编程时,需要频繁的创建对象,而手动创建管理对象可能会出现问题</p><p>例如:ServiceA 依赖 ServiceB,ServiceB 依赖 ServiceC,而 ServiceC 则同时依赖 ServiceA 和 ServiceB</p><ol><li><p>考虑循环依赖的问题(Spring 解决循环依赖的方案是三级缓存)</p><p>如果我们考虑可能的循环依赖的问题直接new 对象可能会出问题,因为 ServiceB 依赖的对象 ServiceC 没有创建,这样我们就没法直接在 ServiceA 里面写 <code>new ServiceB()</code>,当然 new 其他 Service 同理,这样程序肯定会报错</p><p>那么如果我们不再类内部创建对象,而是通过<strong>构造函数</strong>,<strong>接口</strong>或者 <strong>setter 方法</strong>传入依赖对象,这样的可以在一定程度上避免在内部创建依赖对象的问题,把这三个对象的创建由其他用于管理的类执行,这样可能可行,但是非常麻烦,因为每一个对象我们都需要来手动管理,然后自己控制赋给相应的对象</p><p>并且,更重要的是,如果你这么做了,<strong>实际上就是实现了 IoC</strong>,而且是使用 DI 的方式:把依赖的创建权交给了第三方的类,而这个第三方的实现类就是 IoC 容器</p><p>不过,这个是你自己手动实现的,而 Spring 的 IoC 容器已经为我们实现了这个,那么我们直接使用即可</p></li><li><p>就算不考虑循环依赖,但是如果创建类之后有一些通用性的配置,每次要自己实现很麻烦</p><p>比如我想要在 Service 里实现事务,那么我就要在里面的每个方法里面自己实现,而业务代码里面充斥着这种模板性的代码就很不好,可读性和维护性都很差</p><p>而如果交给 IoC 容器,你可以通过一些标识(例如注解 @Transactional)告诉容器,容器在创建每一个对象的时候,就可以自己进行相关控制,有的需要加上事务或者是其他的配置,它就可以自动的加上</p></li></ol></li></ol></li><li><p>总结 IoC 的好处(统一管理,体现了<strong>自动装配</strong>)</p><ol><li><p>最重要的就是可以不用程序员手动创建对象,而是把对象的创建和相关管理交给 IoC 容器,IoC 容器自动给你组装好,使程序员可以专注于业务逻辑</p><p>上层无需知道下层的创建过程,将创建细节隐藏,降低了对象之间的耦合度,程序员不需要知道依赖对象如何创建的,将多余的创建对象的责任交给容器,增加了灵活性</p></li><li><p>将一些通用性的配置代码交给 IoC 容器统一配置,程序员不需要考虑与业务无关的东西,简化开发,IOC 容器自动给你配置好</p></li><li><p>IoC 容器容易控制实现单例模式,节省空间,效率高</p></li><li><p>方便单元测试 mock</p></li><li><p>…</p></li></ol></li></ol><h2 id="依赖倒置原则-DIP-Dependence-Inversion-Principle"><a class="header-anchor" href="#依赖倒置原则-DIP-Dependence-Inversion-Principle">⚡</a>依赖倒置原则 DIP (Dependence Inversion Principle)</h2><ol><li><p>依赖可能产生的问题</p><p>如果类 A 里面有一个属性是类 B,这样 A 直接依赖 B 会因为耦合过高产生一些问题,比如扩展性不好,牵一发而动全身等等</p><ol><li><p>例子</p><p>例如我之前用 Java 写过的一个 <a href="https://github.com/Chao-Yin-Github/JShell" target="_blank" rel="noopener">JShell Demo</a>,最开始我在主函数里面对用户输入的指令进行一个个 if-else 判断,再去创建对应的类来调用函数来实现相应的功能</p> <div class="hljs"><pre><code class="hljs java">...<span class="hljs-keyword">if</span>(<span class="hljs-string">"cd"</span>.equals(str))&#123;    Cd.apply(input);    <span class="hljs-comment">// 对于依赖是非静态的方法或者属性</span>    Cd cd = <span class="hljs-keyword">new</span> Cd(string);    cd.apply(input);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"exit"</span>.equals(str))&#123;    Exit.apply(input);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ...</code></pre></div><p>这样的代码耦合度就很大,因为功能的实现完全依赖其他的实现类,而主函数就需要对那些依赖类进行创建和管理</p><p>如果要增加新的指令,那么就必须修改主函数增加对命令的 if-else 判断,以此创建新的类,这样非常麻烦,扩展性不好</p></li></ol></li><li><p><span id="DIP">DIP: 是设计模式的一个原则,体现的是<strong>面向接口编程的思想</strong></span></p><ol><li><p>例子</p><p>第二次改良我就写了一个接口,所有不同具体的功能类就得去实现这个接口,需要根据字符串生成不同的类不是通过 if-else 判断,而是通过反射实例化对象</p><p>而这样的好处是,我在主函数里面调用接口的方法即可,不需要关心到底是哪一个具体实现类实现了这个接口,因为无论是哪个具体实现类,我们都是要调用那个接口的方法,这样就在主函数里面消除了冗余的 if-else 语句,同时使代码变得更有扩展性,也更加能够维护.</p><p>这样,主函数<strong>不依赖具体实现</strong>而是<strong>依赖接口</strong>,而具体实现类又通过自己的具体实现去<strong>依赖抽象接口</strong>,这样就实现了<strong>依赖倒置原则 DIP</strong></p></li></ol></li></ol><p>下面这段话摘自 Wikipedia: <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><blockquote><p>With the addition of an abstract layer, both high- and lower-level layers reduce the traditional dependencies from top to bottom<br>Nevertheless, the “inversion” concept does not mean that lower-level layers depend on higher-level layers<br>Both layers should depend on abstractions that draw the behavior needed by higher-level layers.</p><p>通过添加抽象层，高层和较低层都从上到下减少了传统的依赖关系。<br>但是，“反转”概念并不意味着较低层依赖于较高层。<br>这两层都应<strong>依赖于抽象</strong>，这些抽象描述出更高层所需要的行为</p></blockquote><ol><li><p>IoC 和 DIP 的关系</p><p>IoC 和 DIP 有关，但与之不同，后者涉及通过共享抽象来解耦高层和低层之间的依赖关系。</p><p>IoC 体现的是</p><ol><li><p>类及其依赖的<strong>产生</strong>通过容器统一管理并分发,是为了简化开发,实现 IoC 是通过 DI 或者 DL 之类的技术</p></li><li><p>而 DIP 是一种经验,体现面向抽象(接口)编程的一种思想</p><p>说白了,我认为,虽然 IoC 只关心类的生命周期,但是实现比较难,而且不用 IoC 框架就得自己实现,来解决类与类之前的关系</p><p>DIP 则不同,不实现 DIP 程序也能使用,但是扩展性和维护性很差,而实现了 DIP,程序可能就很优雅,增强了扩展性和可维护性</p></li></ol></li></ol><h2 id="依赖注入-DI-Dependence-Injection"><a class="header-anchor" href="#依赖注入-DI-Dependence-Injection">⚡</a>依赖注入 DI ( Dependence Injection)</h2><ol><li><p>在 Spring Framework 的 IoC 容器中，配置有三种:xml、annotation 以及 Java config.通过 IoC 容器的控制,把对象的从生成到销毁全部管理起来,再通过依赖注入 DI 的方式将生成的对象提供给所需的类</p></li><li><p>可以说依赖是问题,而注入则是解决方案,同理还有依赖查找和依赖拖拽</p></li><li><p>依赖注入如何实现</p><p>IoC 容器创建好对象后,</p><ol><li><p>通过构造函数传入对象</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    B b;    A(B b)&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre></div></li><li><p>通过 setter 方法传入对象</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    B b;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre></div></li><li><p>通过实现接口</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceName</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">implement</span> <span class="hljs-title">InterfaceName</span></span>&#123;    B b;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre></div><p>前两个可能好理解,但是第三个感觉可能有些鸡肋?</p><p>其实使用接口则是声明了一种依赖的能力,也是可以使用的,只不过 Spring 没有提供</p></li></ol></li><li><p>依赖注入和依赖查找的区别:</p><ol><li>依赖注入只是被动接收,而依赖查找则是需要自己主动去找</li></ol></li></ol><hr><p>总结:</p><ol><li><p>术语:</p><ol><li><p><a href="#dependency">依赖(dependencies)</a>:是面向对象编程中的一个概念,因为是面向对象编程,一个类 A 可能要用到其它的类 B,那么就说 A 依赖 B.</p></li><li><p><a href="#IOC">控制反转(Inversion of Control,简称 IoC)</a>:为了解偶,将依赖对象的创建交给一个特定的容器(实现了 IoC 的类)来管理对象的生命周期,而不由程序本身实现;是一种设计思想</p></li><li><p><a href="#DIP">依赖倒置原则(Dependencies Inversion Principle,简称 DIP)</a>:是设计模式的一个原则,体现的是<strong>面向接口编程的思想</strong></p></li><li><p><a href="#DI">依赖注入(Dependencies Injection,简称 DI)</a></p></li><li><p>上面好像各种实现方式都说有构造函数,setter 方法,接口,这个实际上就是<strong>传递依赖的三种方式</strong>,而无论是 DI、DIP、IoC,实际上解决的就是依赖的问题</p></li></ol></li><li><p>参考文献:</p><ol><li><p><a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" rel="noopener">IoC Wikipedia</a></p></li><li><p><a href="https://www.zhihu.com/question/23277575" target="_blank" rel="noopener">IoC 知乎</a></p></li><li><p><a href="https://blog.csdn.net/briblue/article/details/75093382" target="_blank" rel="noopener"> IoC 、DIP 和 DI</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">DIP Wikipedia</a></p></li></ol></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener">en</a> <a href="https://zh.wikipedia.org/wiki/%E4%25%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">zh</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitBook生成电子书(pdf)</title>
    <link href="/2020/3/3/GitBook%E7%94%9F%E6%88%90%E7%94%B5%E5%AD%90%E4%B9%A6(pdf)/"/>
    <url>/2020/3/3/GitBook%E7%94%9F%E6%88%90%E7%94%B5%E5%AD%90%E4%B9%A6(pdf)/</url>
    
    <content type="html"><![CDATA[<ol><li>先 clone 仓库 (前提是 gitbook 仓库)</li></ol><a id="more"></a><ol start="2"><li><p>安装 npm 和相关 module 以及其他插件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装 npm</span>sudo pacman -S npm<span class="hljs-meta">#</span><span class="bash"> 安装 gitbook 命令行工具</span>sudo npm install gitbook-cli -g<span class="hljs-meta">#</span><span class="bash"> 此时 gitbook -V 可以看到版本号</span><span class="hljs-meta">#</span><span class="bash"> 安装caliber</span>sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin<span class="hljs-meta">#</span><span class="bash"> 检查所需要的 ebook-convert 插件是否安装成功</span>ebook-convert --version</code></pre></div><p><a href="HTTPS://CALIBRE-EBOOK.COM/DOWNLOAD">CALIBER 全平台下载地址</a></p></li><li><p>准备生成 EBOOK</p> <div class="hljs"><pre><code class="hljs SHELL">cd [项目文件夹]<span class="hljs-meta">#</span><span class="bash"> 可以看到有 SUMMARY.md,cover.jpg 等,确认是一个 gitbook类型的仓库</span><span class="hljs-meta">#</span><span class="bash"> 安装所需插件</span>gitbook install <span class="hljs-meta">#</span><span class="bash"> 生成电子书以 pdf 为例</span>gitbook pdf<span class="hljs-meta">#</span><span class="bash"> 可以看到有一个 book.pdf 文件已经生成</span></code></pre></div></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux下添加环境变量</title>
    <link href="/2020/2/26/Linux%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2020/2/26/Linux%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="header-anchor" href="#写在前面">⚡</a>写在前面</h2><p>$PATH:决定了 shell 将到哪些目录中去寻找命令或程序，PATH 的值是一系列目录，当运行一个程序时，Linux 将在这些目录下进行搜寻编译链接</p><a id="more"></a><p>添加格式为：</p><blockquote><p>PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:------:<PATH N></p></blockquote><p>编辑完成之后，通过 source .bashrc(如果是 zsh 的话,就是 .zshrc)命令立刻生效</p><p>需要注意的是，最好不要把当前路径 “./” 放到 PATH 里，这样可能会受到意想不到的攻击。</p><p>完成后，可以通过 echo $PATH 查看当前的搜索路径。这样定制后，就可以避免频繁的启动位于 shell 搜索的路径之外的程序了。</p><h2 id="步骤"><a class="header-anchor" href="#步骤">⚡</a>步骤</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改 .zshrc 文件 （如果是 bash，则是 .bashrc）</span>vim ~/.zshrc<span class="hljs-meta">#</span><span class="bash"> 在文件最后加上这样一行</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-variable">$PATH</span> 后面就是路径</span>export PATH="$PATH:/opt/gtm.v1.3.5"<span class="hljs-meta">#</span><span class="bash"> 使修改立刻生效</span>source .zshrc</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ObjectBox</title>
    <link href="/2020/2/19/ObjectBox/"/>
    <url>/2020/2/19/ObjectBox/</url>
    
    <content type="html"><![CDATA[<ol><li><p>介绍:</p><p><a href="https://github.com/objectbox/objectbox-java" target="_blank" rel="noopener">github地址</a></p> <a id="more"></a><p><a href="https://objectbox.io/cn" target="_blank" rel="noopener">官方首页</a></p><p><a href="https://docs.objectbox.io/" target="_blank" rel="noopener">文档</a></p><p><a href="https://objectbox.io/features/" target="_blank" rel="noopener">好处</a>:</p><ol><li><p>速度快:</p><p>无论是传统的 sqlite 还是 Google 推荐的 realm 和 room , 甚至作者之前的产品 GreeDao 在速度上非常有优势.</p><p><img src="https://objectbox.io/wordpress/wp-content/uploads/2018/06/performance-front-page.png" srcset="/img/loading.gif" alt="比较"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/10/163e630d5cccaf06?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="比较2"></p><blockquote><p>从图上可以看出除了在加载 100k 的大量数据的时候 ObjectBox 的速度慢于 Realm，在执行其他数据操作的时候 ObjectBox 的性能对其他两位都是近乎碾压式的存在</p></blockquote><p>官方说是世界上最快的嵌入式数据库!</p><blockquote><p>为了提供高性能的数据库；我们开发ObjectBox。经过测试，ObjectBox是世界上最快的嵌入式数据库。</p></blockquote></li><li><p>是一个 NoSQL 第三方数据库(不是 ORM)</p><p>ObjectBox 并不是一个典型 ORM，它是完全为对象构建的；所以它没有行，列和数据库。没有行，列和 SQL —— ObjectBox 是一个从零开始的对象数据仓库（没有 ORM，没有 SQLite）。</p></li><li><p>调试方便：</p> <div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-comment">// 详情见下面的全局配置示例</span>AndroidObjectBrowser(boxStore).start(context.applicationContext)</code></pre></div> <div class="hljs"><pre><code class="hljs shell">adb forward tcp:8090 tcp:8090</code></pre></div><p>在浏览器输入<a href="http://localhost:8090/index.html" target="_blank" rel="noopener">http://localhost:8090/index.html</a>就可以在网页看到数据的内容了!</p></li></ol> <!-- 1. 其他 --> <!-- ObjectBox 的团队似乎对 RxJava 不太感冒，主要是介意引入RxJava 之后急剧增加的包体积和方法数，所以 ObjectBox 自己封装了一套支持 Reactive Extensions 的接口。 --></li><li><p>博客文章</p><p><a href="https://juejin.im/post/5b1c34fae51d4506ce34a56b" target="_blank" rel="noopener">https://juejin.im/post/5b1c34fae51d4506ce34a56b</a></p><p><a href="https://juejin.im/post/5a0e7bdc6fb9a0451a75f38e" target="_blank" rel="noopener">https://juejin.im/post/5a0e7bdc6fb9a0451a75f38e</a></p><p><a href="https://www.jianshu.com/p/e9996296a982" target="_blank" rel="noopener">https://www.jianshu.com/p/e9996296a982</a></p><p><a href="https://www.jianshu.com/p/e4ebaa433ae7" target="_blank" rel="noopener">https://www.jianshu.com/p/e4ebaa433ae7</a></p><p><a href="https://zhuanlan.zhihu.com/p/31146878" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31146878</a></p></li><li><p>项目例子:</p><ol><li><p>代码地址:</p><p><a href="mailto:git@github.com">git@github.com</a>:objectbox/objectbox-examples.git</p></li><li><p>心得体会</p><p>此项目有很多 module 使用 android-app-kotlin 这一个 module 就好</p><p>android-app-kotlin module 里面有两个类似的文件分别是 NoteActivity 和 ReactiveNoteActivity</p><p>其区别是,前者使用对数据进行更改需要刷新页面的时候,是使用重新查找全部内容然后重新渲染,并且调用 notifyDataSetChanged()方法实现,其思想较简单.</p><p>而 ReactiveNoteActivity 虽然也是重新查找数据并显示,但却是使用订阅观察者模式和多线程的方法,而和前者顺序顺序执行有所区别.</p><p>我猜测可能是基于效率和方便复用的考量</p><p>因为当用户增加文本的时候,会刷新全部数据,把最新的数据刷新上去,但是此时增加按钮应该是阻塞状态.(觉得这个想法有点牵强,不过也是因为这个比较简单的原因,如果是上传大文件或者是项目逻辑比较复杂的时候就应该很有用了)</p><p>复用是为了方便,因为不需要再每次的 addNote() 方法里面顺序调用 updateNotes() 方法重新查找并将数据保存到内存的list里面,而是隐式调用这个方法,减少模板代码的书写.</p></li></ol></li><li><p>注意事项</p><ol><li><p>先编译项目否则会提示有的类找不到</p></li><li><p>必须要一个自增 ID 才行, 用注解 @Id 标识</p></li><li><p>apply plugin: ‘io.objectbox’ 一定要添加到 dependencies 模块后面</p></li><li><p>但是,如果 put、find 这些方法全是同步的，对于大量数据的存和查都是耗时操作，如果直接写在主线程会阻塞主线程，尤其是 find 方法，而 ObjectBox 的 Reactive 封装显然没有 RxJava 那么强大，</p></li><li><p>尽量使用全局配置</p> <div class="hljs"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> ObjectBox &#123;    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> boxStore: BoxStore    <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;        boxStore = MyObjectBox.builder().androidContext(context.applicationContext).build()        <span class="hljs-keyword">if</span> (BuildConfig.DEBUG) &#123;            <span class="hljs-keyword">val</span> start = AndroidObjectBrowser(boxStore).start(context.applicationContext)            Log.d(App.TAG, <span class="hljs-string">"browser start status: <span class="hljs-variable">$start</span>)"</span>)        &#125;    &#125;&#125;</code></pre></div></li><li><p>(手机路径)默认保存位置在 /data/data/包名/files/objectbox/data.mdb</p></li><li><p>设置查询个数</p> <div class="hljs"><pre><code class="hljs kotlin">Query.find(<span class="hljs-built_in">Long</span> offset, <span class="hljs-built_in">Long</span> limit)</code></pre></div></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh</title>
    <link href="/2020/2/3/ssh/"/>
    <url>/2020/2/3/ssh/</url>
    
    <content type="html"><![CDATA[<h2 id="ssh免密登陆"><a class="header-anchor" href="#ssh免密登陆">⚡</a>ssh免密登陆</h2><a id="more"></a><div class="hljs"><pre><code class="hljs shell">cd ~/.ssh<span class="hljs-meta">#</span><span class="bash"> 生成公有和私有密钥id_rsa.pub和iid_rsa</span><span class="hljs-meta">#</span><span class="bash">需要输入的密码地方按回车即可</span>ssh-keygen -t rsa -C '标记'ls -alssh-copy-id -i id_rsa.pub java@218.199.68.208<span class="hljs-meta">#</span><span class="bash">验证登陆</span>ssh -i ./id_rsa java@218.199.68.208</code></pre></div><h2 id="ssh别名登陆"><a class="header-anchor" href="#ssh别名登陆">⚡</a>ssh别名登陆</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">没有config就创建</span>vim ~/.ssh/config</code></pre></div><div class="hljs"><pre><code class="hljs xml">#加入以下配置:Host feidianHostName 218.199.68.208User javaIdentityFile ~/.ssh/id_rsa.pubIdentitiesOnly yes#去相应服务器上用 vim .ssh/authorized_keys 查看是否已经添加</code></pre></div><h2 id="使用ssh连接到github"><a class="header-anchor" href="#使用ssh连接到github">⚡</a>使用ssh连接到github</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 先将~/.ssh目录下的id_rsa.pub文件内容粘贴,再去Github的个人设置的页面,把内容复制过去,在title写下标签,例如:Linux,方便以后管理</span><span class="hljs-meta">#</span><span class="bash"> 测试能否连接上</span>ssh -T git@github.com<span class="hljs-meta">#</span><span class="bash"> 一般来说第一次会出现提示让你确定是否继续连接输入yes即可</span><span class="hljs-meta">#</span><span class="bash"> 如果要等待很长一段时间或者出现timeout的情况,那么可能是本机的防火墙端口配置出现了问题,则修改~/.ssh/config文件</span>vim ~/.ssh/config</code></pre></div><div class="hljs"><pre><code class="hljs xml">Host github.com# 把下方的Email改成自己的EmailUser YourEmailHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa## 修改端口号为443Port 443</code></pre></div><p>再次ssh -T测试即可</p><h2 id="ssh连接Gitlab"><a class="header-anchor" href="#ssh连接Gitlab">⚡</a>ssh连接Gitlab</h2><p>和Github配置同理,如果出现timeout,则修改配置文件:</p><div class="hljs"><pre><code class="hljs xml">Host gitlab.com# 把下方的Email改成自己的EmailUser YourEmailHostname altssh.gitlab.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>shellCommand</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidSetting</title>
    <link href="/2020/1/25/AndroidSetting/"/>
    <url>/2020/1/25/AndroidSetting/</url>
    
    <content type="html"><![CDATA[<h1>Android Studio配置</h1><a id="more"></a><ul><li><p>解决Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 1.6. Please specify proper ‘-jvm-target’ option</p><p>在app/build.gradle文件内添加以下内容</p>  <div class="hljs"><pre><code class="hljs gradle">android &#123;    ...    compileOptions &#123;        <span class="hljs-keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8        <span class="hljs-keyword">targetCompatibility</span> JavaVersion.VERSION_1_8    &#125;    kotlinOptions &#123;        jvmTarget = JavaVersion.VERSION_1_8.toString()    &#125;&#125;</code></pre></div></li><li><p>加入toasty</p><p>在app/build.gradle文件中加入:</p>  <div class="hljs"><pre><code class="hljs gradle"><span class="hljs-keyword">allprojects</span> &#123;    <span class="hljs-keyword">repositories</span> &#123;    ...    maven &#123; url <span class="hljs-string">"https://jitpack.io"</span> &#125;    &#125;&#125;</code></pre></div><p>在module/build.gradle文件中加入:</p>  <div class="hljs"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;    <span class="hljs-comment">// add Toasty</span>    implementation <span class="hljs-string">'com.github.GrenderG:Toasty:1.4.2'</span>&#125;</code></pre></div></li><li><p>使用viewBinding</p><p>在app/build.gradle文件中加入:</p>  <div class="hljs"><pre><code class="hljs xml">android&#123;    ...    viewBinding&#123;        enabled = true    &#125;&#125;...dependencies &#123;    // add viewBinding    implementation 'cz.kinst.jakub:viewmodelbinding:2.0.0'&#125;</code></pre></div><p>如果想要在生成 binding class 时忽略某个布局文件, 我们需要在该布局文件的根元素添加 <code>tools:viewBindingIgnore=&quot;true&quot;</code> 属性.</p><p>注意:</p><blockquote><p>目前ViewBinding的功能还不够完善，比如XML中使用了 inClude 标签时无法对view进行引用。</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cron表达式</title>
    <link href="/2020/1/10/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/1/10/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Cron表达式是一个字符串，以五个或者六个空格隔开，分为6或7个域，每一个域代表一个含义</p><a id="more"></a><p>秒 (0～59)<br>分 (0～59)<br>小时 (0～23)<br>天 (0-31/28/30) <strong>月的第几天</strong><br>月 （0-11）<br>星期 (1-7) <strong>星期几</strong><br>年份 (1970~2099)</p><p>每个元素可以是:</p><ul><li><p>一个具体值</p></li><li><p>一个连续区间(9-12)</p></li><li><p>一个间隔时间</p><p>0/5: 表示从0开始每间隔5，写到哪个元素就表示间隔的是哪个元素，如果写到了秒，那么表示从0开始，每隔5秒执行一次。</p></li><li><p>一个列表</p><p>(1,3,5): 表示第1,3,5时间执行</p></li><li><p>通配符</p><p>(，- * / L W #)</p><p>月份的日期和星期的日期这两个元素是互斥的，必须对其中一个设置通配符 <code>？</code></p></li></ul><p>通配符的详解</p><ul><li><code>*</code> 所有可能的值</li><li><code>/</code> 指定数值的增量</li><li><code>？</code> 表示不指定值</li><li><code>L</code> 表示最后，只能用在<code>日</code>或者<code>周</code>那一栏</li><li><code>W</code> 离指定日期最近的那个工作日(周一至周五), 只能在<code>日</code>那一栏使用。</li><li><code>#</code> 表示每月的第几个周几</li></ul><p><strong>注意</strong>：</p><ol><li><p>基本都允许的字符： ， - * ？</p></li><li><p>特别的:</p><p>表示<code>日</code>的域还可以用 L W</p><p>星期也可以用 L</p></li></ol><p>例如：</p><ol><li><p>0 55 23 L * ? 表示每月的最后一天的23:55分</p></li><li><p>0 0/30 9-17 * * ? ? ? 朝九晚五工作时间内每半小时</p></li><li><p>0 0 12 ? * WED 表示每个星期三中午12点</p></li><li><p>0 0 12 * * ? 每天12点触发</p></li><li><p>0 15 10 ? * * 每天10点15分触发</p></li><li><p>0 * 10 * * ? 每天10:00-10:59每分钟触发一次</p></li><li><p>0 0/5 10 * * ? 每天 10:00-10:59每隔5分钟触发</p></li><li><p>0 0/5 10,15 * * ? 每天10:00-10:59,15:00-15:59(每隔5分触发)</p></li><li><p>0 0-5 15 * * ? 每天15:00-15:05每分触发</p></li><li><p>0 10,55 14 ? 3 WED 3月份每周三14:10触发 ,14:55触发</p></li><li><p>0 15 10 ? * MON-FRI 从周一到周五每天10:15分触发</p></li><li><p>0 15 10 15 * ? 每月15号10:15分触发</p></li><li><p>0 15 10 L * ? 每月最后一天的10:15分触发</p></li><li><p>0 15 10 ? * 6L 每月最后一周的星期五的10:15分触发</p></li><li><p>0 15 10 ? * 6L 2017-2020 从2017年到2020年每月最后一个星期五的10:15分触发</p></li><li><p>0 15 10 ? * 6#3 每月的第三周的星期五10:15触发</p></li><li><p>0 0 12 1/5 * ? 每月的第一天开始每隔5天的12:00触发一次</p></li><li><p>0 11 11 11 11 ? 每年的11月11号 11点11分触发(光棍节)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>util</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java聊天器</title>
    <link href="/2019/12/14/Java%E8%81%8A%E5%A4%A9%E5%99%A8/"/>
    <url>/2019/12/14/Java%E8%81%8A%E5%A4%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>项目地址</h1><p><a href="https://github.com/Chao-Yin-Github/javaChartDemo" target="_blank" rel="noopener">https://github.com/Chao-Yin-Github/javaChartDemo</a></p><a id="more"></a><h1>项目介绍</h1><ul><li><p>开发环境</p><ul><li><p>Manjaro 18.1.4 Juhraya</p></li><li><p>JDK:1.8.0_212</p></li><li><p>intellij-idea 2019.3</p></li></ul></li><li><p>本项目基于Java NIO开发，使用到了以下技术:</p><ol><li><p>Java NIO</p><p>使用ServerSocketChannel和SocketChannel，完成客户端和服务端socket通道的建立，来实现数据传输</p></li><li><p>使用slf4j日志框架进行日志管理和程序信息输出</p></li><li><p>使用lombok简化Java Bean的Setter和Getter方法、构造方法、toString等模板化方法的撰写</p></li><li><p><strong>自定义数据传输协议</strong>(Transmission.java)**</p></li></ol></li><li><p>技术栈分析</p><ul><li><p>NIO</p><ul><li><p>背景</p><p>NIO是jdk1.4才引入的，有人称作Non-Blocking-IO(非阻塞IO)，还有人喜欢把他成为New-IO。</p><p>我认为各自都有理，首先Non-Blocking-IO就不用说了，因为NIO提供了非阻塞的IO模式，这和传统的BIO(Blocking-IO)有了明显区别。</p><p>那为什么New-IO也是可以的呢，因为NIO是面向缓冲的(Buffer oriented)，基于通道(Channel)(双工，既能读也能写)的IO操作方法，这样就和老式的BIO面向流(Stream oriented)(单方向，只能读或者只能写)的操作，有了本质的区别，所以把它称作New-IO也不无道理。</p></li></ul></li><li><p>使用自定义协议传输数据(Transmission.java)</p><ul><li><p>背景:</p><p>当我在基本分别完成传输字符串和传输文件的功能时，遇到了一个问题，NIO的Server是单线程的，那么就不能通过一般的方式解决传输文件和文本字符串的问题。</p><p>因为如果是多线程的服务端，可以在有一个新的连接到服务端时，服务端就开启一个线程专门处理这个客户端的连接，多个客户端之间不会混乱。</p><p>这样，我这个用户1可以先发送一个标识符来标识一下，我接下来将要发送文本字符串还是文件。如果有客户2同时发送别的信息，服务端的这两个线程之间是不会受到任何影响的。</p><p>但是通过NIO写的服务端是单线程处理连接的，这样，一个用户1发送一个标识符表示接下来会发送一个字符串，但是这时，又有另外一个用户把文件发送过来，服务端是没法分辨出到底是哪一个客户端发送的标识符，也无法分辨出是哪一个客户端发送的数据，这样服务端就会混乱掉。</p></li><li><p>解决办法</p><ol><li><p>方法一：</p><p>最容易想到的是：</p><p>既然服务端无法标识用户，那么客户端就可以规定一个长度一定的标识，然后后面接着数据一起发送给服务端，那么服务端就可以直接把标识信息和数据一起读出来。</p><p>我传输文件用的是FileChannel，然后再使用transferFrom和transferTo方法来实现传到SocketChannel里面和从SocketChannel里面读取数据到FileChannel。</p><p>这样转化其实是可行的，但是我觉得有些麻烦也不够优雅。</p></li><li><p>方法二：</p><p>和方法一一样，都是把标识信息和数据一起传输，但是方式略有不同。</p><p>对于发送方的客户端，我们可以把信息和数据全部封装成一个类，然后我们就可以把这个类序列化成字符串，再把字符串转化为字节数组用SocketChannel传输。</p><p>而服务端则将接收的字节数组反序列化成对象，从中提取需要的信息，再序列化传输给另一个客户端。</p><p>至于另一个接收方的客户端，则同理，将获得的字节数组反序列化成对象，就可以拿到数据进行处理获取相应的内容了。</p></li></ol></li><li><p>选择方法二的理由</p><p>我认为方法二比方法一更好的理由是:如果自定义一个类传输数据，我们就可以把这个类称作为一种数据传输协议。</p><p>因为像http传输协议就是一个基于tcp/ip的传输协议，它定义了请求/响应行(Request/Response Line)，请求/响应头(Request/Response Header)，空行和请求/响应数据(Request/Response Body)，所有使用http协议都要有它所规定的这些结构。</p><p>而这个Transmission类其实也是一样的道理，声明了数据的类型(TransmissionType)，也保存了数据内容(content)本身，还有消息目的方的信息(destinationNumber)等等信息。</p><p><strong>由此，我可以大胆把这个Transmission类称作为我自己的一个聊天器协议！</strong></p></li><li><p>Transmission.java</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transmission</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 数据内容</span><span class="hljs-comment">     */</span> <span class="hljs-keyword">private</span> String content;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文件类型</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> TransmissionType transmissionType;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送目的客户编号</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> destinationNumber;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 原客户编号</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sourceNumber;&#125;</code></pre></div></li><li><p>TransmissionType.java</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> TransmissionType implements Serializable &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文件类型</span><span class="hljs-comment">     */</span>    FILE,        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文本字符串</span><span class="hljs-comment">     */</span>    STRING,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 信息</span><span class="hljs-comment">     */</span>    MESSAGE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * id标识</span><span class="hljs-comment">     */</span>    UUID&#125;</code></pre></div></li><li><p>那这个Transmission类如何传输文本字符串和文件这两种数据呢？</p><p>对于文本字符串自不必说，把要发送的字符串存到content字段里即可，接收方可以直接获取content字段内容。</p><p>至于传输文件，我是先把文件转化成字节数组，再用Base64加密以防字符集乱码，再转化成字符串存到content里。</p><p>接收数据时，则跟发送数据时的操作正好相反，先把读到的字节数组转化成Transmission类，再拿到content字段内容之后，先用Base64解密，再转化为文件保存下来。</p></li></ul></li></ul></li><li><p>可能时由于网络速度的限制加上NIO的特性，这个在本地测试没问题，可是一放到服务器上就出现超过一定大小文件就发送失败的问题。可能和服务器的网速太慢还有NIO非阻塞的特性两者综合作用的结果。因为网速较慢，所以有时服务端接收到一半就认为没有数据了，而客户端的数据还没有发送上来，而服务端又是NIO非阻塞的特性，所以很可能数据读到一半就停止了，开始转化信息，但是数据不完整就会出错。这个由于时间问题还没有解决，以后有空的时候还是想找找其他方法解决一下。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中对象和对象引用的区别</title>
    <link href="/2019/12/6/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/12/6/Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="对象"><a class="header-anchor" href="#对象">⚡</a>对象</h2><p>对象是什么?</p><p>在《Java编程思想》里，是这样解释的：</p><a id="more"></a><blockquote><p>“按照通俗的说法，每个对象都是某个类（class）的一个实例（instance），这里，‘类’就是‘类型’的同义词。”</p></blockquote><p>所以对象是类的实例。而类就是类型的意思。</p><h2 id="对象引用"><a class="header-anchor" href="#对象引用">⚡</a>对象引用</h2><p>同样是《Java编程思想》里面的一句话：</p><blockquote><p>“每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。”</p></blockquote><p>用一个例子来理解</p><div class="hljs"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();</code></pre></div><p>A a则仅仅是对象的声明，是在栈上创建了一个对象引用。</p><p>即a是一个对象引用而非对象本身。</p><p>而只有当new A()这个操作调用之后，才在堆上创建一个类A的对象，或者说是实例。</p><p>而a = new A()；才是真正把a这个对象引用和对象本身关联上。</p><h2 id="对象和对象引用的区别"><a class="header-anchor" href="#对象和对象引用的区别">⚡</a>对象和对象引用的区别</h2><p>下面看一个例子</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">int</span> b = a[<span class="hljs-number">0</span>];        b = <span class="hljs-number">123</span>;        System.out.println(a[<span class="hljs-number">0</span>]);    &#125;&#125;</code></pre></div><p>如果我们认为Java中的引用和C中的指针是同一个东西的话，上面这段Java程序就应该对应的下面这段c++程序</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a[<span class="hljs-number">1</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> *b = a;*b = <span class="hljs-number">123</span>;<span class="hljs-built_in">cout</span>&lt;&lt;a[<span class="hljs-number">0</span>];<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>这段C++程序的结果当然是123。</p><p>但上面第一段Java程序输出结果当然是0而不是123。</p><p>这是因为Java中的引用虽然和C++的指针看似好像一样，都是描述变量的工具，但实际上还是有差别的。</p><hr><p>Java中的变量只有两种类型，一种是基本数据类型，还有一种是引用类型。</p><p>当作为参数传递给一个方法时，处理这两种类型的方式是相同的。Java中都是<strong>按值传递</strong>，没有引用传递。即：</p><p>按值传递意味着传递的是原始值的一个副本。这样，即使函数改变了值，改变的也是原始值的副本，而非原始值本身。</p><p>而引用传递则意味着函数接收的就是原始值本身，这样当函数修改这个值，那么对应的原始值也会被修改。</p><p>看一个例子</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinchao</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewClassForTest</span> </span>&#123;    <span class="hljs-keyword">int</span> a;    String name;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinchao</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMethod</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        String string = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"123"</span>);        NewClassForTest newClassForTest = <span class="hljs-keyword">new</span> NewClassForTest();        newClassForTest.a = <span class="hljs-number">1</span>;        newClassForTest.name =  <span class="hljs-string">"test1"</span>;        change(string,newClassForTest);        System.out.println(string);        System.out.println(newClassForTest.a+<span class="hljs-string">"\n"</span>+newClassForTest.name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(String newString,NewClassForTest newClassForTest)</span> </span>&#123;        newString = <span class="hljs-string">"1234"</span>;        newClassForTest.a = <span class="hljs-number">2</span>;        newClassForTest.name = <span class="hljs-string">"test2"</span>;    &#125;&#125;</code></pre></div><blockquote><p>结果：<br>123<br>2<br>test2</p></blockquote><p>那么在此处为什么同样是通过change方法，string的结果没变，而newClassForTest的改变了?</p><ul><li><p>对于string因为在change方法中，newString = &quot;1234&quot;实际上是newString = new String(&quot;1234);</p><p>newString这个对象引用已经不再指向原来的对象&quot;123&quot;了，在new String的过程中，newString这个对象引用已经把原来的指向取消，而且建立了一个新的指向到这个新的String “1234”。“1234”，而原来的string还是指向到原来的&quot;123&quot;，并没有收到对象引用副本改变指向的影响。</p></li><li><p>对于newClassForTest，newClassForTest.a = 2;实际上是把对象的属性赋了新的值。函数形参和实参都是对象的引用，而且都是指向同一个对象，和副本并无关系，和是否在函数内也没有关系。这两个newClassForTest并没有主从之分，一个对象引用改变的对象的属性,另一个对象引用的对象当然也会随之改变。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql中的相关子查询和不相关子查询</title>
    <link href="/2019/10/28/SQL%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8C%E4%B8%8D%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <url>/2019/10/28/SQL%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8C%E4%B8%8D%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<ul><li><p>不相关子查询：</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ×<span class="hljs-keyword">from</span> tableOneName<span class="hljs-keyword">where</span> columnName <span class="hljs-keyword">in</span> (    <span class="hljs-keyword">select</span> columnName    <span class="hljs-keyword">from</span> tableTwoName    <span class="hljs-keyword">where</span> condition);</code></pre></div>  <a id="more"></a><p>类似上面这种<strong>先执行子查询</strong>，得到一个集合或者值，然后将这个集合或者值作为一个<strong>常量</strong>，再带入到父查询中作为父查询的一个条件。</p></li><li><p>相关子查询</p><p>通俗来说，相关子查询就是：子查询要用到父查询中的值。</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> *<span class="hljs-keyword">from</span> tableOneName<span class="hljs-keyword">where</span> columnOneName <span class="hljs-keyword">in</span> (    <span class="hljs-keyword">select</span> columnOneName    <span class="hljs-keyword">from</span> tableTwoName    <span class="hljs-keyword">where</span> tableTwoName.columnTwoName = tableOneName.columnTwoName)</code></pre></div><p>先扫描副查询的数据表中的<strong>每一条</strong>记录，然后将当前这条记录中的子查询会用到的数据，<strong>带入到子查询中</strong>，然后<strong>再执行子查询</strong>，得到结果，然后再将这个结果<strong>回代</strong>到父查询中，判断父查询的值是否为true，如果为true则把这条记录放回到结果集中，反之，如果为false，则不会把这条记录放到结果集中。</p><blockquote><p>此时，子查询就用到了父查询的结果</p></blockquote></li><li><p>如何判断是相关的还是不相关的子查询？</p><p>如果子查询不能脱离父查询单独执行，那么就是相关子查询。</p></li><li><p>EXISTS</p><p>exists的概念和相关子查询的概念相似，它的作用就是判断子查询得到的<strong>结果集是否是一个空集</strong>。</p><p>它和相关子查询一样，在子查询中用到父查询的条件。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql中having 和 where的区别</title>
    <link href="/2019/10/24/SQL%E4%B8%ADhaving%E5%92%8Cwhere%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/10/24/SQL%E4%B8%ADhaving%E5%92%8Cwhere%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ul><li><p>having 是对结果进行筛选</p><p>having是一个过滤声明，所谓过滤是在查询数据库的结果返回之后进行过滤，即在结果返回之后起作用，并且having后面可以使用“聚合函数”。</p>  <a id="more"></a></li><li><p>where 是在查询数据的时候直接对数据库进行筛选</p><p>where是一个约束声明，在查询数据库的结果返回之前对数据库中的查询条件进行约束，即在结果返回之前起作用，且where后面不能使用“聚合函数”。</p></li><li><p>聚合函数，是对一组值进行计算并且返回<strong>单一值</strong>的函数。聚合函数一定是返回一个结果。</p></li><li><p>where后面之所以不能使用聚合函数是因为where的执行顺序在聚合函数之前</p></li><li><p>having 是对查出来的结果进行过滤，这样就不能对没有查出来的值进行过滤。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot学习建议</title>
    <link href="/2019/10/22/Spring%20Boot%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE/"/>
    <url>/2019/10/22/Spring%20Boot%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Spring-Boot"><a class="header-anchor" href="#什么是Spring-Boot">⚡</a>什么是Spring Boot</h2><a id="more"></a><p>了解一下企业级开发从servlet，jsp，Java EE的MVC模式到Spring FrameWork，再在Spirng FrameWork的基础上Spring Boot的<a href="https://zhuanlan.zhihu.com/p/34985791" target="_blank" rel="noopener">发展历史</a>。</p><p><a href="https://blog.csdn.net/weixin_39893958/article/details/84389384" target="_blank" rel="noopener">Java Web发展历史1</a></p><p><a href="https://www.jianshu.com/p/bec6736dcc3d" target="_blank" rel="noopener">Java Web发展历史2</a></p><p>至于具体Spring 框架的IOC、AOP、容器等等相关概念，现在可以暂时先不用学习太深，主要了解Spring Framework这个框架的来龙去脉之后，首先把后台写出来，项目完成之后再去看相关的重要原理实现。</p><p>还是知乎上一个<a href="https://www.zhihu.com/question/318377502/answer/641205726" target="_blank" rel="noopener">回答</a>：</p><blockquote><p>spring boot给你使用20%的时间去解决80%的问题，剩下20%的问题需要你用200%的时间去弄懂。<br>——by：沃·兹基硕德</p></blockquote><ul><li><p><a href="https://www.zhihu.com/question/303235503/answer/537538561" target="_blank" rel="noopener">https://www.zhihu.com/question/303235503/answer/537538561</a> (可以关注一下陈龙这个作者)</p></li><li><p><a href="https://www.zhihu.com/question/49649311/answer/364216794" target="_blank" rel="noopener">https://www.zhihu.com/question/49649311/answer/364216794</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/59117834" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59117834</a></p></li></ul><p>也要知道前后端分离是如何通信的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener">http请求</a></p><p>当然数据库简单语法也得会 (没学过SQL的或者对SQL语法掌握不太牢固的可以看 <strong>《MySQL必知必会》</strong> 这本书)</p><h2 id="官方资源"><a class="header-anchor" href="#官方资源">⚡</a>官方资源</h2><ul><li><p><a href="https://spring.io/guides/gs/spring-boot/" target="_blank" rel="noopener">指南</a></p></li><li><p><a href="https://www.springcloud.cc/spring-boot.html" target="_blank" rel="noopener">中文文档(第三方，非官方翻译)</a></p></li><li><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/" target="_blank" rel="noopener">文档</a></p></li></ul><!-- more --><h2 id="后台学习任务"><a class="header-anchor" href="#后台学习任务">⚡</a>后台学习任务</h2><ul><li><p>实现类似<a href="http://suo.im/" target="_blank" rel="noopener"> 缩我 </a>的网站吗？</p><p>它可以根据用户用户输入的长链接替换为一个短链接，之后，所有知道这个短链接的人都可以访问这个短链接来访问到原来的长链接。</p></li><li><p>实现原理</p><ol><li><p>首先，在网站上点击一键缩短按钮时，前端把用户输入的网址通过一个[http请求] (post请求)发送给后台。</p><p>查看前端向后台发送的请求:F12 -&gt; network -&gt; XHR</p><p><img src="https://raw.githubusercontent.com/Chao-Yin-Github/PersonalResourcePlan/master/picture/request1.png" srcset="/img/loading.gif" alt="request1"></p><p><img src="https://raw.githubusercontent.com/Chao-Yin-Github/PersonalResourcePlan/master/picture/request2.png" srcset="/img/loading.gif" alt="request2"></p></li><li><p>后台接收请求后，对应到具体的某一个接口，并获取到请求的参数，通过一个算法(自增数或者hash)来生成短链接，其样式为 <a href="http://127.0.0.1:8080/abcd123" target="_blank" rel="noopener">http://127.0.0.1:8080/abcd123</a></p><p>并把这个链接返回给前端。(此时已经完成第一个接口:响应前端的请求，并生成短链)</p><p>然后将用户输入的长链接和生成的短链接保存到数据库中。</p><p>数据库中这张表类似这样:</p><blockquote><table><thead><tr><th style="text-align:center">source_URL</th><th style="text-align:center">short_URL</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></td><td style="text-align:center">localhost:8080/123</td></tr></tbody></table></blockquote><blockquote><p>注意本项目只是一个小demo，对生成短链接的算法不做要求。项目的目的主要是学习Spring Boot，生成算法是次要的。但是如果是以后想放到线上对外部提供服务，那就必须考虑算法的有效性和可靠性。对短链接生成算法感兴趣的同学可以看看这个<a href="https://www.zhihu.com/question/29270034/answer/46446911" target="_blank" rel="noopener">知乎回答</a></p></blockquote><blockquote><p>还有第二个小瑕疵，那就是得考虑并发的问题了，这个目前也不做要求。</p></blockquote></li><li><p>还要写第二个接口:</p><p>当用户输入你生成的短链时，你需要去数据库里查找其对应的原链接，如果找到了，那么就要重定向(redirect)到原网址。</p><p>注意这个可能比较麻烦的一点是，这个必须在Headers里面设置302的重定向状态码。</p></li></ol></li><li><p>要用到的技术:</p><p>Spring Boot 后台框架+ Spring Data JPA或者Mybatis 数据库框架</p><ol><li><p>能够使用Spring FrameWork处理前端请求，实现请求基本的响应</p></li><li><p>能够使用Spring Data JPA或者Mybatis完成数据库的基本增删改查</p><p>JPA：实际上只是Java持久化规范: 全称为Java Persistence API</p><p><a href="https://www.cnblogs.com/ityouknow/p/5891444.html" target="_blank" rel="noopener">Spring Data JPA学习博客例子</a></p></li><li><p>对界面美观有要求者可以自学html、css和javaScript，这样就是一个完整的小项目了。</p><p>当然也建议直接使用postman模拟前端发送请求更简单。</p></li></ol></li><li><p>要用到的工具</p><ul><li><p><a href="https://chrome.google.com/webstore/detail/coohjcphdfgbiolnekdpbcijmhambjff" target="_blank" rel="noopener">postman:Chrome插件版</a></p><p>chrome插件版足够使用 [<strong>需翻墙</strong>] [<strong>vpn或者谷歌访问助手</strong>]</p><p>当然postman是一个跨平台的软件，也可以自行下载独立的软件。</p><p>如果是直接使用chrome插件的话，还需要安装一个<a href="https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo" target="_blank" rel="noopener">依赖插件。</a></p></li><li><p>postman使用方法</p></li></ul></li></ul><hr><h3 id="中文Spring-Boot博客入门"><a class="header-anchor" href="#中文Spring-Boot博客入门">⚡</a>中文Spring Boot博客入门</h3><ul><li><p><a href="http://www.ityouknow.com/spring-boot.html" target="_blank" rel="noopener">http://www.ityouknow.com/spring-boot.html</a></p></li><li><p><a href="https://www.jianshu.com/p/9a08417e4e84" target="_blank" rel="noopener">https://www.jianshu.com/p/9a08417e4e84</a></p></li></ul><h3 id="Spring-Boot学习视频"><a class="header-anchor" href="#Spring-Boot学习视频">⚡</a>Spring Boot学习视频</h3><ul><li><a href="https://www.bilibili.com/video/av65962501?from=search&amp;seid=5089170751259930044" target="_blank" rel="noopener">尚硅谷</a></li></ul><h3 id="友情提示："><a class="header-anchor" href="#友情提示：">⚡</a>友情提示：</h3><ol><li><p>无论是学习视频还是博客，都不要一下子从头看到尾，按需观看即可。</p></li><li><p>虽然任务好像用到了计算机网络的相关知识，但这仅仅是http而已，碰到了什么问题再去通过搜索引擎找解决方案，网络不是任务重点，有用到了解即可，不需要很深的知识。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Java</tag>
      
      <tag>后台开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式(state)</title>
    <link href="/2019/10/16/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F(state)/"/>
    <url>/2019/10/16/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F(state)/</url>
    
    <content type="html"><![CDATA[<h2 id="一句话概括"><a class="header-anchor" href="#一句话概括">⚡</a>一句话概括</h2><p>状态模式<strong>允许对象在内部状态时改变它的行为，对象看起来好像修改了它所属的类。</strong></p><a id="more"></a><p>用途：</p><p>主要是解决当控制一个对象装换的条件表达式过于复杂的时候，把状态判断逻辑转移到表示不同状态的一系列类当中。<strong>可以把复杂的判断逻辑简化。</strong></p><h2 id="例子"><a class="header-anchor" href="#例子">⚡</a>例子</h2><p>现在有这样一个需求：</p><blockquote><p>有一个糖果机，当有人把25美分的硬币放到机器里，转动曲柄，这个机器就会弹出糖果。<br>但是，这个机器有好几种状态，在某些状态下可以弹出糖果，而在某些状态下不能。</p></blockquote><p>如下图所示，用圆圈表示状态，箭头表示行为。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/289823/1571417665158-d62d91cf-f506-44b2-a01f-203f80039da0.png" srcset="/img/loading.gif" alt="糖果机"></p><h3 id="if-else-switch-case-大法"><a class="header-anchor" href="#if-else-switch-case-大法">⚡</a>if-else / switch case 大法</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GumBall</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 糖果机状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> State state;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 糖果数目</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;GumBall(<span class="hljs-keyword">int</span> number) &#123;<span class="hljs-keyword">if</span> (number &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">this</span>.number = number;state = State.NO_QUARTER_STATE;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">this</span>.number = <span class="hljs-number">0</span>;state = State.NO_CANDY_STATE;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 投入一个25美分硬币买糖果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"投入硬币"</span>);<span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",已经放有硬币，请稍候"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">",售罄"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">",正在出货，请等待"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 允许投入硬币的情况</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",成功投入一枚硬币"</span>);state = State.HAS_QUARTER_STATE;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 拿回硬币</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"退款"</span>);<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">",已售罄"</span>);&#125;<span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",没有硬币"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">",硬币已存入"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",退还硬币成功"</span>);state = State.NO_QUARTER_STATE;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 转动曲柄</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"转动曲柄"</span>);<span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",未付款，请先投入硬币"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">"，已售罄"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">"，请稍候正在出货"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">""</span>);state = State.GOING_TO_PRODUCE_STATE;dispense();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 分发糖果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;System.out.print(<span class="hljs-string">"分发糖果"</span>);<span class="hljs-keyword">if</span> (state == State.NO_CANDY_STATE) &#123;System.out.println(<span class="hljs-string">",没有糖果，无法出货"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.NO_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",没有硬币，请先付款"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.HAS_QUARTER_STATE) &#123;System.out.println(<span class="hljs-string">",请先转动曲柄"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == State.GOING_TO_PRODUCE_STATE) &#123;System.out.println(<span class="hljs-string">",出货成功"</span>);number--;<span class="hljs-keyword">if</span> (number == <span class="hljs-number">0</span>) &#123;System.out.println(<span class="hljs-string">"糖果卖完了"</span>);state = State.NO_CANDY_STATE;&#125; <span class="hljs-keyword">else</span> &#123;state = State.NO_QUARTER_STATE;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"state:"</span> + String.valueOf(state) + <span class="hljs-string">"\tinventory:"</span> + number;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 装填糖果</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> number 新加入糖果数量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refill</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;System.out.println(<span class="hljs-string">"before refill:"</span> + <span class="hljs-keyword">this</span>.number);<span class="hljs-keyword">this</span>.number += number;<span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span> || state == State.NO_CANDY_STATE) &#123;state = State.NO_QUARTER_STATE;&#125;System.out.println(<span class="hljs-string">"after refill:"</span> + <span class="hljs-keyword">this</span>.number);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> State &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 没有25美分</span><span class="hljs-comment"> */</span>NO_QUARTER_STATE,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 有25美分</span><span class="hljs-comment"> */</span>HAS_QUARTER_STATE,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 即将产生糖果</span><span class="hljs-comment"> */</span>GOING_TO_PRODUCE_STATE,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 售罄</span><span class="hljs-comment"> */</span>NO_CANDY_STATE&#125;&#125;</code></pre></div><p>主函数测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;GumBall gumBall = <span class="hljs-keyword">new</span> GumBall(<span class="hljs-number">2</span>);System.out.println(gumBall.toString());<span class="hljs-comment">// 正常流程</span>gumBall.insertQuarter();gumBall.turnCrank();System.out.println(gumBall.toString());<span class="hljs-comment">// 直接退款无效</span>gumBall.ejectQuarter();System.out.println(gumBall.toString());<span class="hljs-comment">// 投钱再取出,再转动曲柄，无效</span>gumBall.insertQuarter();gumBall.ejectQuarter();gumBall.turnCrank();System.out.println(gumBall.toString());<span class="hljs-comment">// 投钱再转动曲柄,再取出，有效</span>gumBall.insertQuarter();gumBall.turnCrank();gumBall.ejectQuarter();System.out.println(gumBall.toString());<span class="hljs-comment">// 没货了</span>gumBall.insertQuarter();gumBall.ejectQuarter();gumBall.turnCrank();System.out.println(gumBall.toString());&#125;&#125;</code></pre></div><p>输出：</p><blockquote><p>state:NO_QUARTER_STATEinventory:2</p></blockquote><blockquote><p>投入硬币,成功投入一枚硬币<br>转动曲柄<br>分发糖果,出货成功<br>state:NO_QUARTER_STATEinventory:1</p></blockquote><blockquote><p>退款,没有硬币<br>state:NO_QUARTER_STATEinventory:1</p></blockquote><blockquote><p>投入硬币,成功投入一枚硬币<br>退款,退还硬币成功<br>转动曲柄,未付款，请先投入硬币<br>state:NO_QUARTER_STATEinventory:1</p></blockquote><blockquote><p>投入硬币,成功投入一枚硬币<br>转动曲柄<br>分发糖果,出货成功<br>糖果卖完了<br>退款,已售罄<br>state:NO_CANDY_STATEinventory:0</p></blockquote><blockquote><p>投入硬币,售罄<br>退款,已售罄<br>转动曲柄，已售罄<br>state:NO_CANDY_STATEinventory:0</p></blockquote><p>到目前为止好像都很顺利?</p><hr><p>然后，最讨厌的部分还是来了，<strong>改需求！?</strong></p><blockquote><p>现在，糖果机为了增加销量增加，有10%的几率会在转动曲柄的时候出来两颗糖果。</p></blockquote><p>这样糖果机会多出一个 <strong>'中奖’</strong> 状态</p><p>那么，此时就要修改原来写好的代码逻辑：</p><p>在insetQuarter、ejectQuarter、turnCrank（）、dispense（）等方法里，每个方法再加上一个if条件判断-&gt;是否为中奖状态。</p><p>而且turnCrank方法会变得特别复杂，因为这里就需要考虑是转变为<strong>中奖状态(winner_state)<strong>还是</strong>即将销售状态(Going_to_produce_state)</strong>。</p><p>存在的问题:</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/289823/1571416247293-a5fb488a-852c-46af-a9b8-3189bbfe809c.png" srcset="/img/loading.gif" alt="存在的问题"></p><p>这样的程序就更像是一般我们写C++的顺序的，或者说是过程化的编程范式，没有用到面向对象的设计思想，而且扩展性很差。</p><p>无独有偶，在《重构：改善既有代码的设计》一书中，提到一个概念：<br><strong>代码的坏味道(bad smell)：</strong></p><p>其中一种就是Long Method(过长的方法)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>:</p><p>由此，状态模式就出场了⬇。</p><hr><h3 id="状态模式"><a class="header-anchor" href="#状态模式">⚡</a>状态模式</h3><ul><li><p>新的设计:</p><blockquote><p>将<strong>状态对象</strong>封装到各自类中，然后在动作发生时<strong>委托</strong>给当前状态。</p></blockquote></li><li><p>步骤：</p><ol><li><p>定义一个State<strong>接口</strong>。</p><p>糖果机的每个动作都有一个对应的<strong>方法</strong>,然后把所有动作封装好。</p></li><li><p>为机器中每个状态实现<strong>状态类</strong>。</p><p>这些具体状态类负责在对应状态下进行机器的行为。</p></li><li><p>将动作委托到状态类。</p></li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/289823/1571416193267-d7c6251c-33f0-4a04-a6f0-13bec77ae5fc.png" srcset="/img/loading.gif" alt="类图"></p><ul><li><p>代码</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">State</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">turnGrank</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 没有硬币状态</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoQuarterState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span>()</span>&#123;NewGumball newGumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NoQuarterState</span><span class="hljs-params">(NewGumBall newGumBall)</span></span>&#123;<span class="hljs-keyword">this</span>.newGumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"成功投入一枚硬币"</span>);newGumBall.setState(newGumBall.getHasQuarterState());&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"没有硬币，退款失败"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"请先投入硬币再转动曲柄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"请先投入硬币"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"NoQuarterState"</span>);&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 没有糖果状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoCandyState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<span class="hljs-keyword">private</span> NewGumBall newgumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NoCandyState</span><span class="hljs-params">(NewGumBall newGumBall)</span> </span>&#123;<span class="hljs-keyword">this</span>.newgumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"售罄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"NoCandyState"</span>;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 即将出货状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoingToBeProduceState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<span class="hljs-keyword">private</span> NewGumBall newGumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GoingToBeProduceState</span><span class="hljs-params">(NewGumBall newGumBall)</span> </span>&#123;<span class="hljs-keyword">this</span>.newGumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"正在出货，请勿重复投币"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;newGumBall.releaseCandy();<span class="hljs-keyword">if</span> (newGumBall.getCandyNumber() &gt; <span class="hljs-number">0</span>) &#123;newGumBall.setState(newGumBall.getNoQuarterState());&#125; <span class="hljs-keyword">else</span> &#123;System.out.println(<span class="hljs-string">"最后一个糖果已卖出"</span>);newGumBall.setState(newGumBall.getNoCandyState());&#125;System.out.println(<span class="hljs-string">"出货成功"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"退款失败，硬币已投入"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"正在出货，请勿转动曲柄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"GoingToBeProduceState"</span>;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 有硬币状态</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasQuarterState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">State</span> </span>&#123;<span class="hljs-keyword">private</span> NewGumBall newGumBall;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HasQuarterState</span><span class="hljs-params">(NewGumBall newGumBall)</span> </span>&#123;<span class="hljs-keyword">this</span>.newGumBall = newGumBall;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"已投入硬币，请勿重复投入"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispense</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"请转动曲柄"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"退款成功"</span>);newGumBall.setState(newGumBall.getNoQuarterState()); &#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"转动曲柄，等待出货"</span>);newGumBall.setState(newGumBall.getGoingToBeProduceState());&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"HasQuarterState"</span>;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 全新的糖果机</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewGumBall</span> </span>&#123;<span class="hljs-keyword">private</span> State state;<span class="hljs-keyword">private</span> State goingToBeProduceState;<span class="hljs-keyword">private</span> State HasQuarterState;<span class="hljs-keyword">private</span> State NoCandyState;<span class="hljs-keyword">private</span> State NoQuarterState;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> candyNumber = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NewGumBall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> candyNumber)</span> </span>&#123;goingToBeProduceState = <span class="hljs-keyword">new</span> GoingToBeProduceState(<span class="hljs-keyword">this</span>);HasQuarterState = <span class="hljs-keyword">new</span> HasQuarterState(<span class="hljs-keyword">this</span>);NoCandyState = <span class="hljs-keyword">new</span> NoCandyState(<span class="hljs-keyword">this</span>);NoQuarterState = <span class="hljs-keyword">new</span> NoQuarterState(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">if</span> (candyNumber &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">this</span>.candyNumber = candyNumber;state = NoQuarterState;&#125; <span class="hljs-keyword">else</span> &#123;state = NoCandyState;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseCandy</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"糖果已出货"</span>);<span class="hljs-keyword">if</span> (candyNumber &gt; <span class="hljs-number">0</span>) &#123;candyNumber--;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;<span class="hljs-keyword">this</span>.state = state;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCandyNumber</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> candyNumber;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getGoingToBeProduceState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> goingToBeProduceState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getHasQuarterState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> HasQuarterState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getNoCandyState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> NoCandyState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getNoQuarterState</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> NoQuarterState;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertQuarter</span><span class="hljs-params">()</span> </span>&#123;state.insertQuarter();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">turnCrank</span><span class="hljs-params">()</span> </span>&#123;state.turnCrank();state.dispense();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ejectQuarter</span><span class="hljs-params">()</span> </span>&#123;state.ejectQuarter();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"state:"</span> + state + <span class="hljs-string">"\t inventory:"</span> + candyNumber;&#125;&#125;</code></pre></div>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;NewGumBall newGumBall = <span class="hljs-keyword">new</span> NewGumBall(<span class="hljs-number">2</span>);System.out.println(newGumBall.toString());<span class="hljs-comment">// 正常流程</span>newGumBall.insertQuarter();newGumBall.turnCrank();System.out.println(newGumBall.toString());<span class="hljs-comment">// 直接退款无效</span>newGumBall.ejectQuarter();System.out.println(newGumBall.toString());<span class="hljs-comment">// 投钱再取出,再转动曲柄，有效</span>newGumBall.insertQuarter();newGumBall.ejectQuarter();newGumBall.turnCrank();System.out.println(newGumBall.toString());<span class="hljs-comment">// 投钱再转动曲柄,再取出，无效</span>newGumBall.insertQuarter();newGumBall.turnCrank();newGumBall.ejectQuarter();System.out.println(newGumBall.toString());<span class="hljs-comment">// 没货了</span>newGumBall.insertQuarter();newGumBall.ejectQuarter();System.out.println(newGumBall.toString());&#125;&#125;</code></pre></div><p>输出：</p><blockquote><p>state:NoQuarterSate inventory:2</p></blockquote><blockquote><p>成功投入一枚硬币<br>转动曲柄，等待出货<br>糖果已出货<br>出货成功<br>state:NoQuarterSate inventory:1</p></blockquote><blockquote><p>没有硬币，退款失败<br>state:NoQuarterSate inventory:1</p></blockquote><blockquote><p>成功投入一枚硬币<br>退款成功<br>请先投入硬币再转动曲柄<br>请先投入硬币<br>state:NoQuarterSate inventory:1</p></blockquote><blockquote><p>成功投入一枚硬币<br>转动曲柄，等待出货<br>糖果已出货<br>最后一个糖果已卖出<br>出货成功<br>售罄<br>state:NoCandyState inventory:0</p></blockquote><blockquote><p>售罄<br>售罄<br>售罄<br>售罄<br>state:NoCandyState inventory:0</p></blockquote><ul><li><p>好处？</p><ol><li><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开。</p><p>局部化：将具有普适性的行为抽象出来，放到一个抽象对象中封装起来。</p><p>这样，当有新的状态加入时，我们可以通过定义新的状态类来实现接口/继承父类，来<strong>消除庞大的条件分支语句</strong>来判断状态。</p><p>原理:把逻辑分布到State子类之间，来减少相互间的依赖。</p></li><li><p>而且当从这个状态对象转化为另为一个状态对象时，封装起来的行为潜在的改变，但是用户对此毫不知情。</p></li></ol></li><li><p>缺点:</p><p>子类太多，不好管理。</p></li><li><p>适用情况:</p><ol><li><p>当一个对象有很多种状态，而且他的行为依赖于他的状态，并且在运行时可能动态改变。</p></li><li><p>一个对象中含有庞大的条件分支语句，并且这些分支依赖于该对象的状态。</p></li></ol></li></ul></li></ul><hr><h2 id="设计模式之外的部分"><a class="header-anchor" href="#设计模式之外的部分">⚡</a>设计模式之外的部分</h2><ol><li><p>多范式编程语言: 支持超过一种编程范型语言</p></li><li><p>编程范型: 一类典型编程风格，如:</p><blockquote><p>并发编程，约束编程，数据流编程，声明性编程，分布式的编程，函数式编程，泛型编程，命令式(指令式)编程，逻辑编程，元编程，面向对象编程</p></blockquote><p>过程式编成: 主要采取程序调用（procedure call）或函数调用（function call）的方式来进行流程控制。</p><p>编程范型提供并决定程序员对程序执行的看法</p><p>Scala是一门多范式的编程语言，集成面向对象和函数式编程的特性。</p><p>C++支持过程化，面向对象，范型编程</p></li><li><p>符合迪米特法则(得墨忒耳定律 Law of Demeter -&gt; LoD、最小知识原则)：</p><p>迪米特法则可以简单说成：talk only to your immediate friends。</p><p>一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p><ol><li><p>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；</p></li><li><p>每个单元只能和它的朋友交谈：不能和陌生单元交谈；</p></li><li><p>只和自己直接的朋友交谈。</p></li></ol><p>得墨忒耳定律使得软件更好的可维护性与适应性。</p><p>因为对象较少依赖其它对象的内部结构，可以改变对象容器（container）而不用改变它的调用者（caller）。</p><blockquote><p>一个简单例子是，人可以命令一条狗行走(walk)，但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p></blockquote></li><li><p>卫语句</p><p>如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为“卫语句”。</p><p>常用到的地方: if语句使用“卫语句 ”减少层级嵌套。</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>拥有[短方法] (short methods)的对象会活得比较好、比较长。不熟悉面向对象技术的人，常常觉得对象程序中只有无穷无尽的delegation(委托)，根本没有进行任何计算。和此类程序共同生活数年之后，你才会知道，这些小小方法有多大价值。［间接层］所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型方法支持的。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>design pattern</tag>
      
      <tag>state pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端接收Post请求</title>
    <link href="/2019/9/16/%E5%90%8E%E7%AB%AF%E6%8E%A5%E6%94%B6Post%E8%AF%B7%E6%B1%82/"/>
    <url>/2019/9/16/%E5%90%8E%E7%AB%AF%E6%8E%A5%E6%94%B6Post%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Content-Type以application/x-www-form-urlencoded进行传输</p><p>此种传输方式是构造form表单的普通post请求的方式进行传输</p> <a id="more"></a><p>controller中需要有两个参数，同时这个两个参数不能加@RequestBody或者是加@RequestParam，参数会以字符串和数组的形式填充到参数里面</p></li><li><p>Content-Type以application/json的方式进行传输</p><p>此种方式需要传输一个json格式的字符串</p><p>controller中需要以一个字符串来进行接受这个json字符串</p><p>如果用注解的话需要添加@RequestBody</p><p>如果不用注解，需要从request域里面把body内容读取出来，然后将此字符串进行json反序列化成对象，如果想让他自动转化成对象，需要在SpringMVC的配置里面配置json序列化工具。</p><p>接收参数：多个单一属性的一个对象</p></li><li><p>以键值对方式发送请求</p><p>这样发送参数在请求头，即每个参数使用@RequestParam注解即可</p><p>接受参数：多个单一参数</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>后台开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器搭建手记(Ubuntu)</title>
    <link href="/2019/9/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%89%8B%E8%AE%B0(Ubuntu)/"/>
    <url>/2019/9/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%89%8B%E8%AE%B0(Ubuntu)/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="软件安装"><a class="header-anchor" href="#软件安装">⚡</a>软件安装</h2>  <a id="more"></a><ul><li><h3 id="mysql"><a class="header-anchor" href="#mysql">⚡</a>mysql</h3>  <div class="hljs"><pre><code class="hljs shell">sudo apt-get update<span class="hljs-meta">#</span><span class="bash"> 直接装老版本5.7</span>sudo apt-get install mysql-server</code></pre></div><ul><li><p>修改root用户密码</p><p>在debain系的Linux下，mysql是有默认的debian-sys-maint用户的</p><p>其密码在/etc/mysql/debain.cnf下</p>  <div class="hljs"><pre><code class="hljs shell">mysql -udebian-sys-maint -ppassword</code></pre></div>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">use</span> mysql;<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> authentication_string=<span class="hljs-keyword">password</span>(<span class="hljs-string">'root'</span>) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">'root'</span> <span class="hljs-keyword">and</span> Host=<span class="hljs-string">'localhost'</span>;<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">plugin</span>=<span class="hljs-string">"mysql_native_password"</span>;        <span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;quit;</code></pre></div></li><li><p>创建用户，授予权限</p>  <div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment"># 创建用户</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">'guest'</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'密码'</span>;<span class="hljs-comment"># 授予databaseName数据库的所有权限</span>grants all privileges on databaseName.* to 'guest'@'%' with grant option;<span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;<span class="hljs-comment"># 或者授予mysql所有权限</span>grants all privileges on *.* to 'guest'@'%' with grant option;<span class="hljs-comment"># 查看权限</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">grants</span> <span class="hljs-keyword">for</span> guest;</code></pre></div></li><li><p>开启远程连接</p>  <div class="hljs"><pre><code class="hljs shell">cd /etc/mysql/mysql.conf.d/sudo vim mysqld.cnf</code></pre></div>  <div class="hljs"><pre><code class="hljs cnf"># 把下面这行注释掉bind-address &#x3D; 127.0.0.1</code></pre></div>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 重启</span>sudo systemctl restart mysql</code></pre></div></li></ul></li><li><p>JDK8(Oracle)</p><p>网上ppa源的办法已失效，只能手动去官网下载jdk8的tar.gz包</p><ol><li><p>在本地下载好scp传到服务器</p></li><li><p>在服务器端解压</p></li></ol></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux软链</title>
    <link href="/2019/9/1/Linux%E8%BD%AF%E9%93%BE/"/>
    <url>/2019/9/1/Linux%E8%BD%AF%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="写在前面"><a class="header-anchor" href="#写在前面">⚡</a>写在前面</h2><p>在Linux系统中，内核为每一个新创建的文件分配一个inode(索引结点)，每个文件有一个唯一的inode号。文件属性保存在inode里。</p>  <a id="more"></a><p>在访问文件时，inode被复制到内存里，从而实现文件的快速访问。</p></li><li><h2 id="链接是什么？"><a class="header-anchor" href="#链接是什么？">⚡</a>链接是什么？</h2><p>链接是一种共享文件和访问它的用户的若干目录项之间建立联系的一种方法。</p><p>在windows下，我们称为快捷方式。</p></li><li><h2 id="硬链接"><a class="header-anchor" href="#硬链接">⚡</a>硬链接</h2><p>如果一个inode对应多个文件名，则称这些文件为硬链接。</p><p>换言之，硬链接就是一个文件的多个别名。也可以认为是以inode作为文件指针。</p><ul><li><p>特性:</p><ul><li><p>文件inode相同</p></li><li><p>只能对已存在的文件进行创建</p></li><li><p>不能交叉文件系统进行硬链接的创建</p></li><li><p>不能对目录进行创建，只能对文件</p><p>但是可以通过*通配符进行文件夹中的文件统一创建</p></li><li><p>删除一个硬链接文件不影响其它相同inode文件，只是结点连接数减少。</p><p>只要结点连接数不是0，文件就一直存在。</p><p>而且此时就不再区分源文件和链接文件，只要任一文件被修改，所有文件都会同步修改。</p></li><li><p>只有超级用户才可以为目录创建硬链接。</p></li></ul></li><li><p>创建硬链接</p>  <div class="hljs"><pre><code class="hljs shell">link existingFile newFile</code></pre></div><p>这样当前目录下就出现了一个和existingFile一模一样的文件newFile</p></li></ul></li><li><h2 id="软链接，也成为符号链接"><a class="header-anchor" href="#软链接，也成为符号链接">⚡</a>软链接，也成为符号链接</h2><p>软链接就是一个普通文件，它有着自己的inode号。</p><p>软链接就是另一文件的指向。可以认为是以文件路径名作为文件指针。</p><ul><li><p>特性:</p><ul><li><p>有自己的文件属性和权限</p></li><li><p>可以对不存在的文件或目录创建</p></li><li><p>可以交叉文件系统</p></li><li><p>删除软链接并不影响原文件，但若原文件被删除，相关软链接则被称为死链接</p></li></ul></li><li><p>创建软链</p>  <div class="hljs"><pre><code class="hljs shell">link -s sourceFile newFile</code></pre></div></li><li><p>删除软链</p><p>注意软链接newFile后面不能加<code>/</code>，否则会删除原文件。</p>  <div class="hljs"><pre><code class="hljs shell">rm -rf newFile</code></pre></div></li><li><p>修改软链接</p>  <div class="hljs"><pre><code class="hljs shell">ln -snf sourceFile newFile</code></pre></div><p>这样就把newFile的指向指到了sourceFile的路径了。</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java重载和重写</title>
    <link href="/2019/8/30/java%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99/"/>
    <url>/2019/8/30/java%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99/</url>
    
    <content type="html"><![CDATA[<ul><li><p>重载</p><p>overload</p><p>在<strong>同一个类</strong>中，方法名字相同，参数不同。</p></li></ul><a id="more"></a><div class="hljs"><pre><code>和返回值没有关系。无法以返回值类型作为重载函数的区分标准。以类的多态性表现。</code></pre></div><ul><li><p>重写</p><p>override (覆盖)</p><p><strong>方法的名字和参数列表被称为方法签名</strong></p><p>如果子类中定义了一个与超类方法签名相同的方法，那么就实现了覆盖或者叫重写。</p><p>即是子类和父类之间的关系。</p><p>注意：</p><ol><li><p>在实现覆盖的时候，子类的方法不能低于超类方法的可见性。</p></li><li><p>超类的方法如果用final修饰，则子类不允许覆盖。</p></li><li><p>返回类型可以和超类不同，但是必须为超类返回值的派生类。</p></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中的对象</title>
    <link href="/2019/8/29/java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/8/29/java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="PO"><a class="header-anchor" href="#PO">⚡</a>PO</h2><p>persistent object (持久对象)</p><p>一般看成是与数据库中的表相映射的java对象。</p><p>po中应该<strong>不包含任何</strong>对数据库的操作</p>  <a id="more"></a></li><li><h2 id="VO"><a class="header-anchor" href="#VO">⚡</a>VO</h2><p>view object (value object) 表现层对象</p><p>和po一样仅仅包含数据，并且是页面显示<strong>所需要</strong>的数据。</p></li><li><h2 id="BO"><a class="header-anchor" href="#BO">⚡</a>BO</h2><p>business object (业务对象)</p><p>把业务逻辑封装为一个对象，可以包含其他几个或多个对象。</p><p>通常需要把BO转化为PO，才能进行数据持久化;<br>反之，从数据库中得到PO，转化成BO才能在业务层使用。</p></li><li><h2 id="POJO"><a class="header-anchor" href="#POJO">⚡</a>POJO</h2><p>plain old java object (简单无规则java对象)</p><p>宽泛的概念</p><blockquote><p>POJO转化之后 =&gt; PO<br>POJO传输过程中 =&gt; DTO<br>POJO用作表现层 =&gt; VO</p></blockquote></li><li><h2 id="DAO"><a class="header-anchor" href="#DAO">⚡</a>DAO</h2><p>data access object (数据访问对象)</p><p>几种理解:</p><ol><li><p>是sun的一个标准J2EE设计模式，这个模式中有个接口就是DAO，负责将PO持久化到数据库发，也负责将数据库查询结果集映射为PO。</p></li><li><p>为业务层提供接口，<strong>此对象用于访问数据库(CRUD操作)</strong></p></li></ol><p>通常和PO结合使用，DAO中包含了各种数据库的操作方法，提供数据库的CRUD操作。</p></li><li><h2 id="DTO"><a class="header-anchor" href="#DTO">⚡</a>DTO</h2><p>data transform object (数据传输对象)</p><p>有几种理解:</p><ol><li><p>用在需要跨进程或者远程传输时，它不应该包含业务逻辑</p></li><li><p>一个例子:</p><blockquote><p>一张表有100个字段，PO就有100个属性，但是有一些属性比如密码，是不能展示出来的，我们只展示10个字段。那么我们就没必要把PO传给客户端，而可以把只有需要的10个属性的DTO传给客户端，这样也不会暴露表结构。到达客户端之后，这个对象用来展示对应数据，那么它就变成了VO。</p></blockquote></li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Chao-Yin-Github/PersonalResourcePlan/master/picture/Java%E5%AF%B9%E8%B1%A1.jpeg" srcset="/img/loading.gif" alt="Java对象大集合"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>后台开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一个‘小‘坑</title>
    <link href="/2019/8/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E2%80%98%E5%B0%8F%E2%80%98%E5%9D%91/"/>
    <url>/2019/8/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E2%80%98%E5%B0%8F%E2%80%98%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>在后台开发经常会遇到的一个需求：</p><p>用户输入id，我们就根据这个id去数据库里面找相应的数据。</p><a id="more"></a><p>但是，用户还可以选择在id的同时传入一段时间，（start和end）在这段时间内查找数据。</p><p>甚至，用户还可以选择第三个条件上传者uploader，需要我们同时根据id，时间，和上传者三个条件同时查找数据。</p><p>不过解决方法其实很简单，我们不需要在java程序里进行复杂的条件判断到底哪几个条件为空，在每个条件下单独写sql语句。</p><p>我们只需要在mybatis的mapper.xml里，进行if判断即可。</p><div class="hljs"><pre><code class="hljs xml">select *from tableNamewhere id = #&#123;id,jdbcType = INTEGER&#125;<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">"start!=null and start !='' and end !=null and end != ''"</span>&gt;</span>and date between #&#123;start,jdbcType=TIMESTAMP&#125; and #&#123;end,jdbcType=TIMESTAMP&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">uploader!</span>=<span class="hljs-string">null</span> <span class="hljs-attr">and</span> <span class="hljs-attr">uploader</span>!=<span class="hljs-string">''</span> "&gt;</span>and uploader = #&#123;uploader,jdbcType=VARCHAR&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></code></pre></div><p>这样，如果用户输入的某一个条件为空，那么就不会用于sql的条件判断里。</p><p>经过测试事实也的确是这样</p><p>当前端传了uploader=，后面没有值的时候，没有问题</p><div class="hljs"><pre><code class="hljs json">&#123;    id: 1    uploader:&#125;</code></pre></div><p>当前端不传uploader，也没有问题</p><div class="hljs"><pre><code class="hljs json">&#123;    id:1&#125;</code></pre></div><p><strong>但是！！！！</strong></p><p>当前端传的是</p><div class="hljs"><pre><code class="hljs json">&#123;    id:1    uploader:null&#125;</code></pre></div><p>这时传入的就是null这个<strong>字符串</strong>!!!</p><p>虽然前端返回的<strong>的的确确返回的就是<code>null(空)</code></strong>，但是后台在接收的时候就变成了**<code>null(字符串)</code>**</p><p>由此，我们可以大胆的把if判断改成如下格式</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span> = <span class="hljs-string">'uploader != "null" and uploader!=null and uploader!="" '</span>&gt;</span>and uploader = #&#123;uploader,jdbcType=VARCHAR&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></code></pre></div><p>注意单双引号有所改变</p><hr><p>还有一个很坑的点，后台时间参数是Date类型时，传入的必须是<code>2019/08/27 23:26:41</code>这样的时间格式</p><p>而传入参数为<code>2019-08-27 23:26:41</code>时，后台就必须为String类型的，否则会出现参数不匹配的错误(MisMatch)</p><p>而且，当参数是String时，无需担心和Date类型不匹配，直接传入String到mapper.xml里，不过记得jdbcType还是写TIMESTAM即可。可能mybatis框架会有优化吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>后台开发</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2019/8/27/%E5%BC%82%E5%B8%B8/"/>
    <url>/2019/8/27/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>异常的几种类型:</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Chao-Yin-Github/PersonalResourcePlan/master/picture/TypeOfException.png" srcset="/img/loading.gif" alt="异常的几种类型"></p><p>以旅行实例说明异常的分类：</p><ul><li><p>武汉发生地震，属于不可抗因素，对应**<code>Error</code>**错误，这个我们根本想不到具体发生的原因。例如，突然没有权限往硬盘上写数据的能力了。这种就只能老老实实的把错误信息返回（如果有的话），程序无法处理。</p></li><li><p>堵车，或者航班延误，属于异常**<code>Exception</code><strong>，确切来说属于异常中的</strong><code>checked</code>**，即受检异常，对于这种异常，我们虽然可以预料，但是预料到了也无能为力，只有监测并关注。</p></li><li><p>没有带驾驶证，或者忘记机票，属于异常中的**<code>unchecked</code><strong>类型。具体则属于</strong>可预测的异常**这些完全可以预测并且返回相应的提示。</p></li><li><p>需捕捉异常，例如:汽车抛锚，我们就需要采取公共汽车作为解决的方式</p></li><li><p>检票机坏掉了，属于可透出异常，交由航空公司处理即可，我们无法处理。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven</title>
    <link href="/2019/8/25/Maven/"/>
    <url>/2019/8/25/Maven/</url>
    
    <content type="html"><![CDATA[<ul><li><p>运行mvn package提示-source 1.5，编译失败</p>  <a id="more"></a><p>设置maven中的Java版本为8</p>  <div class="hljs"><pre><code class="hljs shell">sudo vim /opt/maven/conf/setting.xml</code></pre></div><p>找到注释掉的example—profile，或者直接在最后添加</p>  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>JDK1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span></code></pre></div></li><li><p>java -jar maven打包后的jar文件，提示没有主清单程序</p><p>这是因为项目中有多个main函数入口，这样就必须在pom文件中指明主程序入口。</p>  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">transformers</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span> <span class="hljs-attr">implementation</span>=<span class="hljs-string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.example.project.mianApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">transformers</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>其中<code>com.example.project</code>是入口类所在的包名，即<code>groupId</code>和<code>artifactID</code>拼接而成的结果</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>util</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis使用</title>
    <link href="/2019/8/22/Mybatis%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/8/22/Mybatis%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="idea下使用Spring-Boot-搭建Mybatis框架"><a class="header-anchor" href="#idea下使用Spring-Boot-搭建Mybatis框架">⚡</a>idea下使用Spring Boot 搭建Mybatis框架</h2></li></ul><a id="more"></a><div class="hljs"><pre><code>- 添加maven依赖- 在application.properties文件中，添加Mybatis的配置：    <pre><code class="hljs yaml"><span class="hljs-string">mybatis.config-location=classpath:mybatis-config.xml</span></code></pre></div>- 在resources下新建mybatis-config.xml，具体配置请见文件。</code></pre><ul><li><h2 id="parameter-和-parameter-的区别"><a class="header-anchor" href="#parameter-和-parameter-的区别">⚡</a>#{parameter} 和 ${parameter} 的区别</h2><p><strong>#是占位符号，$是拼接符号</strong></p><ol><li><p>参数预处理</p><ul><li><p><code>#</code> 将传入的数据当成一个字符串，会自动对传入数据<strong>加双引号</strong></p></li><li><p><code>$</code> 将传入的数据直接显示，而不处理</p></li></ul></li><li><p>sql注入</p><ul><li><p><code>$</code> 不能防止sql注入</p></li><li><p><code>#</code> 可以防止sql注入</p></li></ul></li><li><p><strong><code>$</code></strong> 一般用于传入<strong>数据库对象</strong>，例如表名、列名</p></li><li><p>尽量使用<code>#</code></p></li><li><p>order by动态参数需要用<code>$</code></p></li></ol></li><li><h2 id="trim"><a class="header-anchor" href="#trim">⚡</a>trim</h2></li></ul><table><thead><tr><th style="text-align:center">trim的几个属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">prefix</td><td style="text-align:center">当 trim 元素包含有内容时， 增加 prefix 所指定的前缀</td></tr><tr><td style="text-align:center">prefixOverrides</td><td style="text-align:center">当 trim 元素包含有内容时， 去除 prefixOverrides 指定的 前缀</td></tr><tr><td style="text-align:center">suffix</td><td style="text-align:center">当 trim 元素包含有内容时， 增加 suffix 所指定的后缀</td></tr><tr><td style="text-align:center">suffixOverrides</td><td style="text-align:center">当 trim 元素包含有内容时， 去除 suffixOverrides 指定的后缀</td></tr></tbody></table><p>下面的语句表示为：trim标签中有内容时，添加 where ，而当第一个为and 或者 or 时，会把 and 或者 or 去掉。而如果trim标签中没有内容，则不会添加where语句。(此语句和<where> 标签等价)</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"where"</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">"AND | OR"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre></div><p>同理，还有类似<set> 标签的trim</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"set"</span> <span class="hljs-attr">suffiexOverrides</span>=<span class="hljs-string">","</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre></div><p>当trim中有内容时，添加set，当最后一个为<code>,</code>时，去掉它。</p>]]></content>
    
    
    
    <tags>
      
      <tag>后台开发</tag>
      
      <tag>configuration</tag>
      
      <tag>SQL</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SwaggerUI</title>
    <link href="/2019/8/20/SwaggerUI/"/>
    <url>/2019/8/20/SwaggerUI/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="SwaggerUI简述"><a class="header-anchor" href="#SwaggerUI简述">⚡</a>SwaggerUI简述</h2><p>Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件</p>  <a id="more"></a><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>总体目标是使客户端和文件系统作为服务器以同样的速度来更新。</p><p>文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步</p></li><li><h2 id="Spring-Boot-Maven-依赖"><a class="header-anchor" href="#Spring-Boot-Maven-依赖">⚡</a>Spring Boot Maven 依赖</h2>  <div class="hljs"><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!--swagger2--&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><h2 id="配置"><a class="header-anchor" href="#配置">⚡</a>配置</h2><p>在configuration包下，新建SwaggerUIConfiguration</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*在类上加入注解*/</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-meta">@Configuration</span><span class="hljs-comment">/* 控制swagger是否开启，当application.properties设置中swagger.enable=true,即符合havingValue的期望值时配置生效 */</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"swagger"</span>, value = &#123;<span class="hljs-string">"enable"</span>&#125;, havingValue = <span class="hljs-string">"true"</span> )<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerUIConfiguration</span></span>&#123;<span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestfulApi</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)        .apiInfo(apiInfo())        .select()        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.example"</span>))        .paths(PathSelectors.any())        .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()        .titile(<span class="hljs-string">"title"</span>)        .description(<span class="hljs-string">"====================\n"</span>        +<span class="hljs-string">"项目名称:xxx\n"</span>        +<span class="hljs-string">"项目分支:xxx\n"</span>        +<span class="hljs-string">"项目成员:xxx\n"</span>            +<span class="hljs-string">"====================\n"</span>            +<span class="hljs-string">"项目简介:后端采用Spring Boot + Mybatis框架,使用Mysql数据库\n"</span>        +<span class="hljs-string">"====================\n"</span>        +<span class="hljs-string">"注意事项:\n"</span>        +<span class="hljs-string">"1. 后端服务端口号:xxx\n"</span>        +<span class="hljs-string">"2. develop分支为开发版本,master分支为稳定版本\n"</span>        +<span class="hljs-string">"3. 每次提交认真写git commit\n\n"</span>        +<span class="hljs-string">"====================\n"</span>)        .termsOfServiceUrl(<span class="hljs-string">""</span>)        .version(<span class="hljs-string">"1.0"</span>)        .build();    &#125;&#125;</code></pre></div></li><li><h2 id="注解介绍"><a class="header-anchor" href="#注解介绍">⚡</a>注解介绍</h2></li></ul><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">@Api</td><td style="text-align:center"></td><td style="text-align:center">用在Contoller控制器类上,标志这个类是Swagger的资源</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">value</td><td style="text-align:center">[没有效果]</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">tags</td><td style="text-align:center">控制器说明</td></tr><tr><td style="text-align:center">@ApiOperation</td><td style="text-align:center"></td><td style="text-align:center">用在接口方法上,描述方法的作用</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">value</td><td style="text-align:center">方法说明</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">note</td><td style="text-align:center">增加说明</td></tr><tr><td style="text-align:center">@APiImplicitParams</td><td style="text-align:center"></td><td style="text-align:center">用在接口方法上,包装器,用{}包含多个ApiImplicitParam</td></tr><tr><td style="text-align:center">@ApiImpicitParam</td><td style="text-align:center"></td><td style="text-align:center">定义在ApiImplicitParams内  ,描述单个参数的详细信息</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">ParamType</td><td style="text-align:center">获取参数的位置</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">header -&gt; @RequestHeader</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">query -&gt; @RequestParam</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">path -&gt; @PathVariable</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">body: 以流的形式提交,进支持post</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">form: 以form表单形式提交,仅支持post</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">name</td><td style="text-align:center">参数名</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">dataType</td><td style="text-align:center">参数的数据类型,有<strong>Long</strong> 和String，但是用Long会出现格式错误问题，所以数字统一也用String</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">required</td><td style="text-align:center">是否为必须参数true/false</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">value</td><td style="text-align:center">参数说明</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">defaultValue</td><td style="text-align:center">参数默认值</td></tr><tr><td style="text-align:center">@ApiResponses</td><td style="text-align:center"></td><td style="text-align:center">用在接口方看法上,用{}包含多个@ApiResonse</td></tr><tr><td style="text-align:center">@ApiResponse</td><td style="text-align:center"></td><td style="text-align:center">表示一个错误信息</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">code</td><td style="text-align:center">状态码[200、201、403、404、500等]</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">message</td><td style="text-align:center">状态信息</td></tr><tr><td style="text-align:center">@ApiModel</td><td style="text-align:center"></td><td style="text-align:center">用在类上,描述对象的作用</td></tr><tr><td style="text-align:center">@ApiModelProperty</td><td style="text-align:center"></td><td style="text-align:center">描述对象中字段的作用 ,一般用在请求对象或者返回结果对象</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>后台开发</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot注解之——@Resource和@Autowired</title>
    <link href="/2019/7/28/Spring%20Boot%E6%B3%A8%E8%A7%A3%E4%B9%8B%E2%80%94%E2%80%94@Resource%E5%92%8C@Autowired/"/>
    <url>/2019/7/28/Spring%20Boot%E6%B3%A8%E8%A7%A3%E4%B9%8B%E2%80%94%E2%80%94@Resource%E5%92%8C@Autowired/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="相同点："><a class="header-anchor" href="#相同点：">⚡</a>相同点：</h2><ol><li><p>都是bean注入时使用</p></li><li><p>二者都可以写在字段上用来消除Setter和Getter方法</p></li><li><p>也可以写在Setter方法上</p></li></ol></li></ul><a id="more"></a><ul><li><h2 id="不同点："><a class="header-anchor" href="#不同点：">⚡</a>不同点：</h2><ol><li><h3 id="包"><a class="header-anchor" href="#包">⚡</a>包</h3><p>@Resource 是属于Java EE的，在Javax包下</p><p>@Autowired 是属于Spring boot的</p></li><li><h3 id="自动装配的类型-Resource"><a class="header-anchor" href="#自动装配的类型-Resource">⚡</a>自动装配的类型-<code>@Resource</code></h3><p>@Resource 默认按照byName注入，但也可以用byType注入</p><p>spring将其注解的name属性解析为bean的名字，而type属性解析为bean的类型。</p><ol><li><p>若同时指定了name和type属性，则从spring上下文中找到唯一的匹配的bean进行装配，找不到则抛出异常。</p></li><li><p>如果指定了name，则从上下文中查找名称（id）匹配的bean，找不到同上。</p></li><li><p>如果指定了type，则从上下文中查找类似匹配的bean，找不到或者<strong>找到多个</strong>都会抛出异常。</p></li><li><p>如果既不指定name，也不指定type，这时将通过反射机制使用默认的byName，没有匹配则退为一个原始类型进行匹配。</p></li></ol></li><li><h3 id="自动装配的类型-Autowired"><a class="header-anchor" href="#自动装配的类型-Autowired">⚡</a>自动装配的类型-<code>@Autowired</code></h3><p>只能通过byType自动注入</p><p>默认情况下它要求依赖的对象必须存在，如果允许null，则可以将它的required属性设置为false。</p><p>如果想按照名字来自动装配，则需结合@Qulifier注解使用：</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-meta">@Qulifier</span>(<span class="hljs-string">"userDao"</span>)<span class="hljs-keyword">private</span> UserDao userDao;</code></pre></div></li></ol></li></ul><p>个人感觉用Autowired会更整齐，而且也方便。</p>]]></content>
    
    
    
    <tags>
      
      <tag>后台开发</tag>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok</title>
    <link href="/2019/7/27/Lombok/"/>
    <url>/2019/7/27/Lombok/</url>
    
    <content type="html"><![CDATA[<ul><li><p>@Setter、@Getter、@ToString、@NonNull</p></li><li><p>@NoArgsConstructor、@AllArgsConstructor</p>  <a id="more"></a><p>有final修饰的变量无法使用NoArgsConstructor</p></li><li><p>@RequiredConstructor</p><p>生成类中所有@NonNull注释或者是final修饰的变量的构造函数</p><p>三种注释都不能用在含有静态数据成员的类上</p></li><li><p>@Data</p><p>包含了以下注解：</p><p>@Setter、@Getter、@ToString、@equals、@hashCode</p></li><li><p>@value与@Data类似，只不过前者会把所有变量没，默认为pirvate final，并且不会生成setter方法(final不可修改)。</p></li><li><p>@SneakyThrows: 捕获异常。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>后台开发</tag>
      
      <tag>Lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>沸点hosts</title>
    <link href="/2019/7/25/%E6%B2%B8%E7%82%B9hosts/"/>
    <url>/2019/7/25/%E6%B2%B8%E7%82%B9hosts/</url>
    
    <content type="html"><![CDATA[<p>218.199.68.208 <a href="http://git.feidian.hzau.edu.cn" target="_blank" rel="noopener">git.feidian.hzau.edu.cn</a></p><a id="more"></a><p>218.199.68.208 <a href="http://wiki.feidian.hzau.edu.cn" target="_blank" rel="noopener">wiki.feidian.hzau.edu.cn</a></p><p>218.199.68.208 <a href="http://accounts.feidian.hzau.edu.cn" target="_blank" rel="noopener">accounts.feidian.hzau.edu.cn</a></p><p>218.199.68.208 <a href="http://ldap.feidian.hzau.edu.cn" target="_blank" rel="noopener">ldap.feidian.hzau.edu.cn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>chore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git commit 规范</title>
    <link href="/2019/7/14/git%20commit%20%E8%A7%84%E8%8C%83/"/>
    <url>/2019/7/14/git%20commit%20%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="git-commit-规范"><a class="header-anchor" href="#git-commit-规范">⚡</a>git commit 规范</h2><ul><li><p>Header</p><p>type (scope) : subject</p>  <a id="more"></a><p>type的几种类型</p><ul><li><p>feat: 新功能</p></li><li><p>fix: 修补bug</p></li><li><p>docs: 文档</p></li><li><p>style: 格式</p></li><li><p>refactor: 重构</p></li><li><p>test: 测试</p></li><li><p>chore: 构建工程或者辅助工具的变动</p></li></ul><p>subject:</p><ul><li><p>以动词开头，使用<strong>第一人称现在时</strong></p></li><li><p>第一个字母小写</p></li><li><p>结尾不加符号</p></li></ul></li><li><p>Body</p></li><li><p>Footer</p><p>适用情况:</p><ul><li><p>不兼容变动</p><p>当前代码和上一个版本不兼容，则以<code>BREAKING CHANGE</code>开头</p></li><li><p>关闭issue</p><p>Closes #123</p><p>关闭123号issue</p></li><li><p>revert</p><p>撤销以前的commit，以<code>revert:</code>开头，后面紧跟着被撤销Commit的Header</p></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪吃蛇</title>
    <link href="/2019/7/13/%E8%B4%AA%E5%90%83%E8%9B%87/"/>
    <url>/2019/7/13/%E8%B4%AA%E5%90%83%E8%9B%87/</url>
    
    <content type="html"><![CDATA[<h2 id="任务描述"><a class="header-anchor" href="#任务描述">⚡</a>任务描述:</h2><p>用C++写一个贪吃蛇游戏,用wasd控制蛇头进行上左下右的移动，<a id="more"></a>当没有键入时，蛇沿当前所在方向继续向前走。吃到食物之后蛇的身体会变长.蛇头碰到墙壁或者蛇身则游戏结束。</p><p>蛇头用<code>@</code>表示,蛇身用<code>*</code>表示,食物用<code>$</code>表示，空白处用‘ ’表示。</p><hr><h2 id="提示"><a class="header-anchor" href="#提示">⚡</a>提示:</h2><ol><li><p>写一个游戏类，游戏环境使用二位数组array[][]生成，蛇用两个一维数组sx[],sy[]存储蛇的头部和身体的行下标和列下标。</p></li><li><p>初始蛇头和食物用随机函数rand生成下标值，将array[][]相应部分置为<code>@</code>和<code>$</code>。</p></li><li><p>每当蛇头<code>@</code>碰到食物<code>$</code>时，随机在空格处产生一个食物。</p></li><li><p>dx[],dy[]数组控制蛇的移动方向。例如：dx[0]=-1,dy[0]=0,代表向上移动。当用户键入<code>w</code>时，蛇向上移动，即sx[i]=sx[i]+dx[0],sy[i]+=dy[0]</p></li><li><p>蛇头放到sx，sy数组的尾部，蛇移动分为两种情况:</p><ol><li>没有吃到食物:<br>sx，sy从前往后依次更新，sx[i]=sx[i+1]</li><li>吃到食物了:<br>sx，sy数组长度加一，蛇头直接变为食物的位置。</li></ol></li><li><p>要用到的库：</p><ul><li><p>windows.h:</p><p>会用到system(“cls”)清屏</p></li><li><p>conio.h</p><p>kbhit()检测键盘键入(非阻塞)</p></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>chore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+Github Pages搭建博客指南</title>
    <link href="/2019/7/12/hexo-Github%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    <url>/2019/7/12/hexo-Github%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<ol><li><h2 id="hexo-ndoejs安装"><a class="header-anchor" href="#hexo-ndoejs安装">⚡</a>hexo+ndoejs安装</h2><p>hexo:</p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">具体说明请看官方文档</a></p><p>node + npm:</p> <div class="hljs"><pre><code class="hljs shell">sudo pacman -S nodejs npm</code></pre></div><p><a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">npm 权限问题</a></p></li><li><h2 id="主题配置"><a class="header-anchor" href="#主题配置">⚡</a>主题配置</h2><ol><li><p>选择一个主题克隆下来</p><p>例如：<a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">alpha-dust</a></p> <div class="hljs"><pre><code class="hljs shell">git clone https://github.com/klugjo/hexo-theme-alpha-dust themes/alpha-dustgit clone</code></pre></div></li><li><p>修改所需配置</p><ol><li><p>author，discription等等</p></li><li><p>修改favicon</p><ol><li><p><a href="http://www.faviconico.org/favicon" target="_blank" rel="noopener">在线生成ico</a></p></li><li><p>把生成的文件放到 blog/source目录下</p><p>并修改文件名为favicon.ico</p></li><li><p>(并没有效果) 修改blog/_config.yml</p> <div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 增加一行</span><span class="hljs-string">favicon:/favicon.ico</span></code></pre></div></li></ol></li></ol></li><li><p>使用hexo</p><ol><li><p>生成草稿或者新的markdown文件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 生成草稿</span>hexo new draft test<span class="hljs-meta">#</span><span class="bash"> 生成markdown文件</span>hexo new post blog</code></pre></div></li><li><p>将draft草稿发布</p> <div class="hljs"><pre><code class="hljs shell">hexo publish post test</code></pre></div></li><li><p>部到 git</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装插件</span>npm install hexo-deployer-git  --save</code></pre></div></li></ol></li><li><p>插件</p><ul><li><p>live2d</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo npm install hexo-helper-live2d --save</span><span class="hljs-meta">#</span><span class="bash"> shizaku是model的名字</span><span class="hljs-meta">$</span><span class="bash"> sudo npm install live2d-widget-model-shizuku --save</span></code></pre></div><p>_config.yml加入如下配置</p>  <div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># Live2D</span><span class="hljs-comment">## https://github.com/EYHN/hexo-helper-live2d</span><span class="hljs-attr">live2d:</span><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">jsdelivr</span> <span class="hljs-comment"># 默认</span><span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span> <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span> <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span> <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><span class="hljs-comment"># scriptFrom: jsdelivr # jsdelivr CDN</span><span class="hljs-comment"># scriptFrom: unpkg # unpkg CDN</span><span class="hljs-comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span><span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><span class="hljs-attr">model:</span><span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-shizuku</span> <span class="hljs-comment"># npm-module package name</span>    <span class="hljs-attr">scale:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">hHeadPos:</span> <span class="hljs-number">0.5</span>    <span class="hljs-attr">vHeadPos:</span> <span class="hljs-number">0.618</span><span class="hljs-attr">display:</span>    <span class="hljs-attr">superSample:</span> <span class="hljs-number">2</span>    <span class="hljs-attr">width:</span> <span class="hljs-number">125</span>    <span class="hljs-attr">height:</span> <span class="hljs-number">125</span>    <span class="hljs-attr">position:</span> <span class="hljs-string">left</span>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">30</span>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-20</span><span class="hljs-attr">mobile:</span>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">scale:</span> <span class="hljs-number">0.05</span><span class="hljs-attr">react:</span>    <span class="hljs-attr">opacityDefault:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">opacityOnHover:</span> <span class="hljs-number">0.2</span></code></pre></div><p>想要其他的model可以去<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">官方博客找</a></p></li><li><p>Browsersync 实时预览编辑</p>  <div class="hljs"><pre><code class="hljs shell">npm install hexo-browsersync --save</code></pre></div></li><li><p>hexo-deployer-shell 同步服务器</p>  <div class="hljs"><pre><code class="hljs shell">npm install hexo-deployer-shell --save</code></pre></div><p>修改 root 的 _config.yml</p>  <div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">shell</span>  <span class="hljs-attr">command:</span> <span class="hljs-string">&lt;your</span> <span class="hljs-string">deploy</span> <span class="hljs-string">command&gt;</span>  <span class="hljs-attr">options:</span>  <span class="hljs-attr">timeout:</span> <span class="hljs-number">2000</span></code></pre></div></li><li><p><a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">置顶</a></p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm uninstall hexo-generator-index --save</span><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-index-pin-top --save</span></code></pre></div><p>如果要置顶,就在文章首的 font-matter 里面添加:<br>top: True</p></li><li><p>markdown 脚注</p><p><a href="https://github.com/hexojs/hexo-renderer-markdown-it" target="_blank" rel="noopener">换新的引擎</a></p>  <div class="hljs"><pre><code class="hljs shell">npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save</code></pre></div><p>可选的配置</p>  <div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">markdown:</span>    <span class="hljs-attr">render:</span>        <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span>        <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">linkify:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">typographer:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">quotes:</span> <span class="hljs-string">'“”‘’'</span>    <span class="hljs-attr">plugins:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-ins</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span>    <span class="hljs-attr">anchors:</span>    <span class="hljs-attr">level:</span> <span class="hljs-number">2</span>    <span class="hljs-attr">collisionSuffix:</span> <span class="hljs-string">'v'</span>    <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">permalinkClass:</span> <span class="hljs-string">'header-anchor'</span>    <span class="hljs-attr">permalinkSide:</span> <span class="hljs-string">'left'</span>    <span class="hljs-attr">permalinkSymbol:</span> <span class="hljs-string">'⚡'</span>    <span class="hljs-attr">case:</span> <span class="hljs-number">0</span>    <span class="hljs-attr">separator:</span> <span class="hljs-string">''</span></code></pre></div><p>换了引擎还要 clean 一下</p><p><a href="https://zhanghuimeng.github.io/post/add-footnote-plugin-for-hexo-blog/" target="_blank" rel="noopener">参考博客</a></p></li><li><p><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">RSS</a></p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install hexo-generator-feed --save</span></code></pre></div><p>对于 fluid 主题,我们可以在关于页里面修改 icons 支持 rss,link 就写 <code>/atom.xml</code></p></li><li><p><a href="https://github.com/HCLonely/hexo-online-server" target="_blank" rel="noopener">hexo-online-server</a></p><p>在线编辑</p><p>坑(2020.4.17版本):</p><ol><li><p>展示的配置注释要删</p></li><li><p>配置里面的 secret 要随便输一些东西,否则会报错:</p><p>Error: secret option required for sessions</p></li></ol></li></ul></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用指令</title>
    <link href="/2019/7/11/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2019/7/11/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ol><li><p>从本地上传文件到服务器</p> <a id="more"></a> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> scp -r /home/yysir/dist java@218.199.68.208:/tmp</span></code></pre></div><p>即可将本地dist文件夹上传到服务器的tmp文件夹下，</p><p>然后即可连接服务器将文件移动到相应文件夹中【因为目标文件夹可能没有写入权限，所以先放入具有全部权限的tmp文件夹下，再进行移动】</p></li><li><p>从服务器下载文件到另一服务器或者本机</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">注意：这是在服务器端，要求必须要有公网ip才能传到对应电脑，否则，只能先退出服务器，在本机然后再从服务器上下载文件。</span><span class="hljs-meta">$</span><span class="bash"> scp java@218.199.68.208:/tmp/test.txt yysir@ip:/home/yysir/Download</span></code></pre></div></li><li><p>查看服务器图片</p><p>python3:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python -m http.server 8080</span></code></pre></div><p>python2:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python -m simpleHTTPServer 8080</span></code></pre></div><p>如果服务器8080端口防火墙打开了的话，在浏览器输入服务器的ip地址和端口，即可在本地查看服务器的图片。</p> <!-- more --></li><li><p>rar解压</p><p>linux没有直接解压rar的功能，先去<a href="https://www.rarlab.com/download.htm" target="_blank" rel="noopener">rarlab下载</a></p><p>解压到/opt目录下，进入rar文件夹，<code>sudo make</code>即可</p><p>语法：</p><p>unrar x [fileName] 解压</p><p>rar a [rarName.rar] fileName</p></li><li><p>ubuntu下开启防火墙端口</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo su</span><span class="hljs-meta">#</span><span class="bash">开启8080端口</span><span class="hljs-meta">$</span><span class="bash"> iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /etc/network/</span><span class="hljs-meta">#</span><span class="bash">目录下如果没有iptables.up.rules</span>iptables-save &gt;/etc/network/iptables.up.rules<span class="hljs-meta">$</span><span class="bash"> vim iptables.up.rules</span><span class="hljs-meta">#</span><span class="bash">把新加入的8080端口新加入的那一行移动到合适位置【其实直接将第一行命令加到这里相应位置就可以】</span><span class="hljs-meta">#</span><span class="bash"> accept一定要放到reject的前面!!</span><span class="hljs-meta">$</span><span class="bash"> iptables-apply</span><span class="hljs-meta">#</span><span class="bash">检查程序是否运行中，端口是否开启</span><span class="hljs-meta">#</span><span class="bash">特别的，在沸点的项目需要向学校申请开放端口</span></code></pre></div></li><li><p>命令行下查看wifi</p> <div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有wifi</span>$ nmcli device wifi list<span class="hljs-comment"># 连接wifi</span>$ nmcli device wifi connect <span class="hljs-string">'SSID'</span> password <span class="hljs-string">'password'</span><span class="hljs-comment"># 显示一个所有连接过网络的UUID列表</span>$ nmcli connection show<span class="hljs-comment"># 查看所有的网络设备和状态</span>$ nmcli device</code></pre></div></li><li><p>查看端口</p><ol><li><p>查看端口是否被占用：【注意<strong>root权限</strong>】</p><ul><li>netstat -anp |grep 8080</li><li>lsof -i:8080</li></ul></li><li><p>查看端口是否在防火墙放行</p><ul><li><p>netstat -ntpl【tcp类型端口】</p></li><li><p>netstat -nupl【udp类型端口】</p></li><li><p>/sbin/iptables -L -n</p></li><li><p>telnet ip【ip地址】 port【端口】</p></li><li><p>可以连接则显示</p>  <div class="hljs"><pre><code class="hljs bash">Trying ip ...Connected to ip...Escape character is <span class="hljs-string">'^]'</span>.</code></pre></div><p>输入’]'后，进入telnet,键入quit退出</p></li><li><p>不能连接则显示</p>  <div class="hljs"><pre><code class="hljs bash">Trying ip...telnet: connect to address ip: No route to host</code></pre></div></li></ul></li></ol></li><li><p>内网穿透</p><p>我如果连接外网时连接内网的主机,输入192.168.1.110这样的内网ip肯定是无法连接的,这样就需要内网穿透</p><ol><li><p>方案一:</p><p>用有公网ip的服务器,搭建ngrok进行内网穿透,这个就需要买服务器,然后自己搭ngrok了。我现在暂时还用不到服务器,就没有采取这个方案。</p></li><li><p>方案二:</p><p>用ngrok现成的，<a href="https://dashboard.ngrok.com/get-started" target="_blank" rel="noopener">官网</a> 注册一个帐号，下载zip文件，解压到opt</p> <div class="hljs"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /opt<span class="hljs-comment"># 安装screen使ngrok可以在后台运行</span>$ sudo pacman -S screen<span class="hljs-comment"># 启动screen,-S 后面的ngrok就是一个名字而已</span>$ screen -S ngrok<span class="hljs-comment"># 开启ssh默认的22端口</span>./ngrok tcp 22<span class="hljs-comment"># 记下端口和host</span><span class="hljs-comment"># 看到启动成功后，按下 ctl+A+D，使ngrok在后台运行</span><span class="hljs-comment"># 连接外网测试ssh</span>$ ssh -p prot yysir@0.tcp.ngrok.io</code></pre></div><hr><p>更新：</p><p>我必须在本机的命令行开一个命令行界面才能连上，否则有迷之网络连接失败</p></li></ol></li><li><p>在服务器上后台运行程序</p><blockquote><p>前些时候（大概四到五月份）做帐号中心的项目，才开始真正熟悉Linux的各种操作和Spring Boot的学习。具体踩过的坑一时半会都说不完。不过今天又发现了一些新的问题值得记录一下⬇</p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 之前仅仅是用 &gt;file 来重定向输出文件，还有 &amp; 来保持程序后台运行，具体命令如下：</span><span class="hljs-meta">$</span><span class="bash"> java -jar demo-SNAPSHOT.jar &gt;accountcenter.out &amp;</span></code></pre></div><p>可是最近发现每过一段时间(大概一个月左右)，程序就会自动停止，然后我就又不得不重新连服务器，把后台提起来。</p><p>今天上网查了查，找到一个可能的疏漏：要用nohup来保持程序后台运行<br>（具体不确定，站坑，等过一个月再来答）</p><p>(过了好久，终于填坑，果然是需要nohup)</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nohup java -jar demo-SNAPSHOT.jar &gt;accountcenter.out &amp;</span></code></pre></div></li><li><p>nginx</p><ol><li><p>安装：</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S nginx</span></code></pre></div></li><li><p>开启服务&amp;测试</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl status nginx</span><span class="hljs-meta">$</span><span class="bash"> sudo systemctl start nginx</span><span class="hljs-meta">$</span><span class="bash"> sudo nginx -t</span></code></pre></div><p>如果测试出现如下错误：</p><blockquote><p>nginx: [warn] could not build optimal types_hash, you should increase either types_hash_max_size: 2048 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size</p></blockquote><p>解决方案：</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/nginx/nginx.conf</span></code></pre></div><p>在http模块下，server子模块前，添加如下配置:</p><blockquote><p>types_hash_max_size 2048;<br>server_names_hash_max_size 2068;<br>types_hash_bucket_size 1024;</p></blockquote> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重启</span><span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart ngxin</span><span class="hljs-meta">#</span><span class="bash">测试</span><span class="hljs-meta">$</span><span class="bash"> sudo nginx -t</span><span class="hljs-meta">#</span><span class="bash">出现以下提示即可：</span><span class="hljs-meta">#</span><span class="bash">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><span class="hljs-meta">#</span><span class="bash">nginx: configuration file /etc/nginx/nginx.conf <span class="hljs-built_in">test</span> is successful</span></code></pre></div><p><a href="http://127.0.0.1" target="_blank" rel="noopener">本地nginx主页</a></p></li><li><p>配置反向代理</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/nginx/nginx.conf</span></code></pre></div><p>&lt;一、通过域名访问&gt;<br>添加如下配置</p> <div class="hljs"><pre><code class="hljs xml">server &#123;    listen 80;    server_name yinchao;    root /opt/BlogFile/.deploy_git    location /&#123;        index index.html;        try_files $uri $uri/ /index.html;    &#125;&#125;</code></pre></div><p>&lt;二、通过端口访问&gt;</p> <div class="hljs"><pre><code class="hljs xml">server &#123;    listen 8888;    server_name localhost;    root ~;    location / &#123;        index ~;        try_files $uri $uri/ ~;    &#125;&#125;</code></pre></div> <div class="hljs"><pre><code class="hljs shell">sudo systemctl restart nginx</code></pre></div><p>即可通过http://yinchao/ 或localhost:8888访问。</p></li></ol><ul><li><p>前端部署的坑：</p><ul><li><p>如果是vue等可以用</p>   <div class="hljs"><pre><code class="hljs shell">npm run build</code></pre></div><p>命令打包为dis文件的，直接就可以了</p></li><li><p>如果是原生的html+css+javascript</p><p>就要把文件归类，html平行的就是css和js</p><p>而且nginx的配置文件要配置好</p><blockquote><p>从昨天22：30到夜里1点多，再从今天早上9：20到下午1点，终于把这个原生页面部署上去了😩</p></blockquote></li></ul></li></ul></li><li><p>查看文件编码</p><div class="hljs"><pre><code class="hljs shell">file fileName<span class="hljs-meta">#</span><span class="bash"> 还可以错略通过换行符判断Windows/Unix系统</span></code></pre></div></li><li><p>数据库备份和还原</p><p>备份：</p><div class="hljs"><pre><code class="hljs shell">mysqldump -uroot -proot databaseName &gt; databasesName.sql;</code></pre></div><p>还原的前提：必须先建立database，然后才能在其中添加数据,否则会报错</p><div class="hljs"><pre><code class="hljs shell">mysql -uroot -proot databaseName &lt; databaseName.sql;</code></pre></div></li><li><p>网络相关</p><ol><li><p>www和不加www域名的区别：</p><p>前者是后者的子域名</p><p>后者被称为裸域名,好处是简短容易记忆，常见于个人博客等。坏处是不能把裸域设定为另外域名的别名等<a href="https://www.zhihu.com/question/20414602" target="_blank" rel="noopener">详情见知乎</a>。</p></li></ol></li><li><p>ls命令</p><ul><li><p>按文件大小进行排序</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls -hlSa</span></code></pre></div><p>-a: --all</p><p><code>-h</code>:–human-readable，显示人类可读的文件大小</p><p><code>-S</code>:以文件大小降序方式排序</p><p><strong><code>-r</code></strong>:–reverse，反向排序</p></li><li><p>按文件时间顺序排序</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls -hlta</span></code></pre></div><p><code>-t</code>: sort by modification time,newest first，即按修改时间对文件进行<strong>降序</strong>排序</p></li></ul></li><li><p>命令记录</p><ul><li><p><code>ldd</code> [path]: 查看依赖库</p>  <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ldd /usr/bin/mysqld</span></code></pre></div><p>注意要写<strong>完整路径</strong>,如果写成<br>$ ldd mysql<br>会提示mysql NOT FOUND</p></li><li><p><code>LD_DEBUG=libs</code> [path]:</p><blockquote><p>LD_DEBUG 是 glibc 中的 loader 为了方便自身调试而设置的一个环境变量。<br>通过设置这个环境变量，可以方便的看到 loader 的加载过程,使用ldd命令可以知道程序依赖于哪些库。<br>在找不到这些库的时候，使用LD_DEBUG可以知道系统在哪些路径下进行了尝试</p></blockquote></li></ul></li><li><p>gitlab</p><p>昨天（2019.8.18）程时坤重启了 gitlab 500的错误，但是没办法用ssh克隆导致我晚上调了很久，最后发现是url不对!!!</p><p>应该是 <a href="http://xn--rcaaa.edu.cn" target="_blank" rel="noopener">×××.edu.cn</a>，结果现在的url为 <a href="http://xn--rcaaa.edu.cn.com" target="_blank" rel="noopener">×××.edu.cn.com</a>，然后用ssh克隆就一直提示需要使用密码。</p><p>解决办法：</p><div class="hljs"><pre><code class="hljs ssh"># 登上服务器,获取超级用户权限$ ssh feidian$ sudo su# 进入gitlab配置目录,进行相应配置$ cd &#x2F;etc&#x2F;gitlab$ vim gitlab.rb# 发现external_url是&#39;http:&#x2F;&#x2F;git.feidian.hzau.edu.cn.com&#39;# 修改,把最后的.com去掉即可# 更坑的来了,之前在网上找到的命令是 gitlab-ctl reconfigure,执行之发现刚刚修改的gitlab.rb的数据被重置了!!!# 尝试多次发现show-config才是正确的$ gitlab-ctl show-config# 成功</code></pre></div></li><li><p>banner</p><ul><li><p>生成banner</p></li><li><p>登录前banner:</p></li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/issue</span></code></pre></div><div class="hljs"><pre><code class="hljs properties"><span class="hljs-attr">Manjaro</span> <span class="hljs-string">Linux \r  </span><span class="hljs-attr">server</span> <span class="hljs-string">name: (\n) </span><span class="hljs-attr">user</span>: <span class="hljs-string">(\l)</span><span class="hljs-attr">version</span>: <span class="hljs-string">(\v)</span><span class="hljs-attr">OS</span> <span class="hljs-string">Name:(\s)</span><span class="hljs-attr">time</span>: <span class="hljs-string">(\t)</span><span class="hljs-attr">hard</span> <span class="hljs-string">ware level: (\m)</span></code></pre></div><ul><li>登录后banner</li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/motd</span></code></pre></div><div class="hljs"><pre><code class="hljs properties">  <span class="hljs-attr">___</span>    <span class="hljs-string">___  ___      ________           ________      ___  ___      ________      ________     </span> <span class="hljs-meta">|\ </span> <span class="hljs-string">\  /  /||\  \    |\   ___  \        |\   ____\    |\  \|\  \    |\   __  \    |\   __  \    </span> <span class="hljs-attr">\ \ </span> <span class="hljs-string">\/  / /\ \  \   \ \  \\ \  \       \ \  \___|    \ \  \\\  \   \ \  \|\  \   \ \  \|\  \   </span>  <span class="hljs-attr">\ \ </span>   <span class="hljs-string">/ /  \ \  \   \ \  \\ \  \       \ \  \        \ \   __  \   \ \   __  \   \ \  \\\  \  </span>   <span class="hljs-attr">\/</span>  <span class="hljs-string">/  /    \ \  \   \ \  \\ \  \       \ \  \____    \ \  \ \  \   \ \  \ \  \   \ \  \\\  \ </span> <span class="hljs-meta">__/</span>  <span class="hljs-string">/ /       \ \__\   \ \__\\ \__\       \ \_______\   \ \__\ \__\   \ \__\ \__\   \ \_______\</span><span class="hljs-meta">|\___/</span> <span class="hljs-string">/         \|__|    \|__| \|__|        \|_______|    \|__|\|__|    \|__|\|__|    \|_______|</span><span class="hljs-attr">\|___|/</span></code></pre></div></li><li><p>根据端口号直接杀死进程</p><div class="hljs"><pre><code class="hljs shell">fuser -k -n tcp 8099</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>shellCommand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro安装手记</title>
    <link href="/2019/7/11/Manjaro%E5%AE%89%E8%A3%85%E6%89%8B%E8%AE%B0/"/>
    <url>/2019/7/11/Manjaro%E5%AE%89%E8%A3%85%E6%89%8B%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="安装-设置"><a class="header-anchor" href="#安装-设置">⚡</a>安装&amp;设置</h2></li></ul><ol><li><p>安装manjaro</p> <a id="more"></a><ol><li><p>在官网下载<strong>gnome</strong>版本.iso文件</p></li><li><p>用rufus刻录</p><p><strong>注意</strong>:在开始刻录是选择刻录方式为<strong>DD模式!</strong>,而不是一般的iso!</p></li><li><p>进入安装,在grub界面将</p><p><code>语言</code>为中文</p><p><code>Driver</code>设置<strong>no-free</strong></p><p>在<code>boot</code>那一行按<code>e</code> 确认nouveau.modeset=0来禁用开源nouveau驱动</p><p>如果进不去桌面,还要在quit 后面 加上</p> <div class="hljs"><pre><code class="hljs shell">acpi_osi=! acpi_osi='Windows 2009'</code></pre></div><p>否则无法驱动独立显卡</p></li><li><p>等待安装</p></li><li><p>安装完成,重启进入manjaro时注意也要在grub界面修改acpi</p></li><li><p>进入桌面</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">排列并选择软件源</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman-mirrors -i -c China -m rank</span><span class="hljs-meta">#</span><span class="bash">排列源</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman-mirrors -g</span><span class="hljs-meta">#</span><span class="bash"> 安装archlinuxcn-keyring</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S archlinuxcn-keyring</span><span class="hljs-meta">#</span><span class="bash">更新系统</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -Syu</span><span class="hljs-meta">#</span><span class="bash">安装vim</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S vim</span><span class="hljs-meta">#</span><span class="bash">修改grub</span><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/default/grub</span><span class="hljs-meta">#</span><span class="bash">修改为</span>GRUB_CMDLINE_LINUX_DEFAULT="quiet nouveau.modeset=0 systemd.show_status=1 acpi_osi=! acpi_osi='Windows 2009'"<span class="hljs-meta">#</span><span class="bash">查看驱动</span><span class="hljs-meta">$</span><span class="bash"> glxgears</span><span class="hljs-meta">$</span><span class="bash"> mhwd</span><span class="hljs-meta">$</span><span class="bash"> sudo optirun nvidia-settings -c :8</span></code></pre></div></li><li><p>grub rescure</p><p>这次可能是分区位置或者顺序或者方案不对,导致删掉之前预留的20G硬盘里存了manjaro的引导,在windows删除这个预留空间再进入linux显示没找到引导,以下是修复过程</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ls查看设备和磁盘分区</span><span class="hljs-meta">$</span><span class="bash"> ls</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span>查看路径和分区</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">set</span></span><span class="hljs-meta">#</span><span class="bash"> 接下来就是一个个用ls (hdx,gptx)试验,找到Manjaro的引导,这次运气很好,虽然都显示是unknown filesystem,而没有显示住文件夹,但是我没有放弃.我就先试着把root定在了hd2的gpt5下,结果一次就成功了</span><span class="hljs-meta">#</span><span class="bash"> root 指定启动系统分区</span><span class="hljs-meta">$</span><span class="bash"> root=(hd2,gpt5)</span><span class="hljs-meta">#</span><span class="bash"> prefix 设置grub启动路路径</span><span class="hljs-meta">$</span><span class="bash"> prefix=(hd2,gpt5)/boot/grub</span><span class="hljs-meta">#</span><span class="bash"> insmod加载制定模块</span><span class="hljs-meta">$</span><span class="bash"> insmoe normal</span><span class="hljs-meta">$</span><span class="bash"> normal</span><span class="hljs-meta">#</span><span class="bash"> 自动重启,之后就可以看到之前的grub界面了</span><span class="hljs-meta">#</span><span class="bash"> 当然,不能每次都这样吧,进入正常图形界面后,输入一下命令</span><span class="hljs-meta">$</span><span class="bash"> sudo update-grub</span><span class="hljs-meta">#</span><span class="bash"> 当然,这个nvme0n1p5应该是对应上面的gpt5,但是我也不知道到底对不对,好在这次运气真的好,猜的没错,重启之后就没有grub rescure了</span><span class="hljs-meta">$</span><span class="bash"> grub-install /dev/nvme0n1p5</span></code></pre></div></li></ol></li><li><p>解决连接有限网络连接失败问题<code>「玄学」</code></p><ol><li><p>安装以使用ifconfig</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 首先查看网线接口名称,若没有网线插口应该是网卡驱动问题</span><span class="hljs-meta">$</span><span class="bash"> ifconfig</span><span class="hljs-meta">#</span><span class="bash"> 连接网络失败可能是获取不到ip</span><span class="hljs-meta">$</span><span class="bash"> sudo dhclinet enp2s0f1</span></code></pre></div><p>不知道发生了什么就解决了? !</p></li><li><p>快捷键设置</p><ol><li><p>进入设置-&gt;设备-&gt;keyboard,最后添加快捷键</p></li><li><p>名称 terminal ,命令 gnome-terminal ,快捷键<code>Ctrl</code>+<code>Alt</code>+<code>T</code></p><p>名称文件管理器,命令nautilus,快捷键<code>win</code>+<code>e</code></p><p>找到隐藏所有选项,设置快捷键<code>win</code>+<code>D</code></p></li></ol></li><li><p>美化</p><ol><li><p><a href="https://www.gnome-look.org/p/1276072/" target="_blank" rel="noopener">grub主题1:Cyber Security theme</a></p><p>注意Manjaro的grub文件<strong>注释和配置写在一起</strong>,不要以为下面的都是注释!</p></li><li><p>将解压后的文件移动到/boot/grub/themes</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改grub文件</span><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/default/grub</span><span class="hljs-meta">#</span><span class="bash">这一行改为grub界面15秒的选择时间</span><span class="hljs-meta">$</span><span class="bash"> GRUB_TIMEOUT=15</span><span class="hljs-meta">#</span><span class="bash">主题文件路径</span><span class="hljs-meta">$</span><span class="bash"> GRUB_THEME=<span class="hljs-string">"/boot/grub/themes/Cyber-Security/theme.txt"</span></span>        <span class="hljs-meta">#</span><span class="bash">这个分辨率修改为1280x1024是因为作者说明这是最好的分辨率</span><span class="hljs-meta">$</span><span class="bash"> GRUB_GFXMODE=1280x1024</span>        <span class="hljs-meta">#</span><span class="bash">注释掉这一行，否则不会有图形界面</span><span class="hljs-meta">#</span><span class="bash">GRUB_TERMINAL_OUTPUT=<span class="hljs-string">"console"</span></span><span class="hljs-meta">#</span><span class="bash"> 更新grub</span><span class="hljs-meta">$</span><span class="bash"> grub-mkconfig -o /boot/grub/grub.cfg</span><span class="hljs-meta">#</span><span class="bash"> 或者</span><span class="hljs-meta">$</span><span class="bash"> sudo update-grub</span><span class="hljs-meta">#</span><span class="bash">注意如果是是grub2引导，用这个命令</span>grub2-mkconfig -o /boot/efi/EFI/Manjaro/grub.cfg<span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div><p><a href="https://www.opendesktop.org/p/1228974/" target="_blank" rel="noopener">grub主题2链接</a></p></li><li><p><a href="https://www.gnome-look.org/p/1013714/" target="_blank" rel="noopener">shell和gnome苹果主题:Sierra</a></p><p>下载解压到/usr/share/themes即可</p></li><li><p><a href="https://www.gnome-look.org/p/999988/" target="_blank" rel="noopener">鼠标主题arch cursor theme</a></p><p>下载解压到/usr/share/icons</p></li></ol></li><li><p>修改中文文件夹名</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span>=en_US</span><span class="hljs-meta">$</span><span class="bash"> xdg-user-dirs-gtk-update</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> LANG=zh_CN.UTF-8</span><span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div></li><li><p>解决没声音问题</p><p><a href="https://blog.csdn.net/juncoder/article/details/39269595" target="_blank" rel="noopener">CSDN</a></p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试是否静音,以及声卡驱动,如果没有异常输出,则证明驱动没有问题</span><span class="hljs-meta">$</span><span class="bash"> amixer sset Master unmute</span><span class="hljs-meta">#</span><span class="bash"> 调整试一下</span><span class="hljs-meta">$</span><span class="bash"> alsamixer</span><span class="hljs-meta">#</span><span class="bash"> 测试有没有声音,能听到分别左右的两个声道的声音就是正常的</span><span class="hljs-meta">$</span><span class="bash"> speaker-test 1.1.3</span><span class="hljs-meta">#</span><span class="bash"> 查看设备,正常输出则驱动正常</span><span class="hljs-meta">$</span><span class="bash"> aplay -l</span><span class="hljs-meta">$</span><span class="bash"> amixer scontrols</span><span class="hljs-meta">#</span><span class="bash"> 如果上面输出没有<span class="hljs-string">"master"</span>,则没有配置</span><span class="hljs-meta">$</span><span class="bash"> amixer -c 0 scontrols</span><span class="hljs-meta">#</span><span class="bash"> 出现<span class="hljs-string">"Master"</span>则正确</span><span class="hljs-meta">$</span><span class="bash"> vim .asoundrc</span>pcm.!default &#123;    type hw    card 0&#125;ctl.!default &#123;    type hw    card 0&#125;<span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div></li><li><p>加入sysrq</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /etc/sysctl.d/</span><span class="hljs-meta">$</span><span class="bash"> sudo vim 99-sysctl.conf</span><span class="hljs-meta">#</span><span class="bash"> 加入内容为:</span><span class="hljs-meta">$</span><span class="bash"> kernel.sysrq = 1</span><span class="hljs-meta">#</span><span class="bash"> 保存重启后,即可用<span class="hljs-string">"busier"</span>命令强制重启</span></code></pre></div></li><li><p>配置默认编辑器</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 用ranger发现默认文本编辑器是nano,想修改为vim</span><span class="hljs-meta">$</span><span class="bash"> vim ~/.zshrc</span>export EDITOR=vim<span class="hljs-meta">#</span><span class="bash"> 重启即可</span></code></pre></div></li><li><p>解决windows双系统时间不一致问题</p><p>(占坑,具体不记得了,只记得点击设置一下就好)</p></li></ol></li></ol><ul><li><h2 id="软件"><a class="header-anchor" href="#软件">⚡</a>软件</h2></li></ul><ol><li><p>输入法:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">安装谷歌拼音</span>sudo pacman -S fcitx-im fcitx-configtool fcitx-googlepinyin<span class="hljs-meta">#</span><span class="bash">创建.xprofile文件</span>vim ~/.xprofile<span class="hljs-meta">#</span><span class="bash">复制加入以下内容</span>export LC_ALL=zh_CN.UTF-8export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx"<span class="hljs-meta">#</span><span class="bash"> 添加emoji表情</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ~/.config/fxitx/data</span><span class="hljs-meta">$</span><span class="bash"> curl -<span class="hljs-comment">#C - -O https://raw.githubusercontent.com/levinit/fcitx-emoji/master/QuickPhrase.mb &amp;&amp; cat ./QuickPhrase.mb &gt;&gt; ~/.config/fcitx/data/QuickPhrase.mb &amp;&amp; rm ./QuickPhrase.mb</span></span><span class="hljs-meta">#</span><span class="bash"> 添加颜文字</span><span class="hljs-meta">$</span><span class="bash"> wget https://raw.githubusercontent.com/rainlime/fcitx-quick-phrase-emoji/master/QuickPhrase.mb &amp;&amp; cat ./QuickPhrase.mb &gt;&gt; ~/.config/fcitx/data/QuickPhrase.mb &amp;&amp; rm ./QuickPhrase.mb</span><span class="hljs-meta">#</span><span class="bash"> 将下载的QuickPhrase.mb.1文件中的数据复制到QuickPhrase.mb，重启即可</span></code></pre></div><p><a href="https://blog.felixc.at/2012/05/kitty-for-fcitx-quickphrase/" target="_blank" rel="noopener">颜文字对照表</a></p></li><li><p>常用软件</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S vim zsh ranger htop cmatrix yay oneko etronic-wechat typora netease-cloud-music tmux aria2 oneDriveLinux tree go rust ruby</span><span class="hljs-meta">#</span><span class="bash"> 图片查看器</span>nomacs</code></pre></div></li><li><p>解决.vimrc E488:多余的换行符问题:</p><p>不要用<code>#</code>写注释,而要用<code>&quot;</code></p></li><li><p>thefuck</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 没有pip先安装pip</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S python-pip</span><span class="hljs-meta">#</span><span class="bash"> 安装thefuck</span><span class="hljs-meta">$</span><span class="bash"> sudo pip install thefuck</span><span class="hljs-meta">#</span><span class="bash"> 配置</span><span class="hljs-meta">$</span><span class="bash"> fuck</span><span class="hljs-meta">#</span><span class="bash"> root用户安装</span><span class="hljs-meta">$</span><span class="bash"> sudo su</span><span class="hljs-meta">$</span><span class="bash"> pip insall thefuck</span><span class="hljs-meta">$</span><span class="bash"> fuck</span></code></pre></div></li><li><p>java</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看openjdk版本</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -Q |grep jdk</span><span class="hljs-meta">#</span><span class="bash"> 卸载openjdk</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -R jre*</span><span class="hljs-meta">#</span><span class="bash"> 查看是否删除</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -Q |grep jdk</span><span class="hljs-meta">$</span><span class="bash"> java -version</span><span class="hljs-meta">#</span><span class="bash"> 安装:去官网下载jdk8,解压到/opt</span><span class="hljs-meta">$</span><span class="bash"> sudo ln -s /opt/jdk-8u212-linux-x64/jdk1.8.0_212/bin/java /usr/bin/java</span><span class="hljs-meta">#</span><span class="bash"> 如果创建符号链接失败,则是之前的openjdk的影响,删除/usr/bin/java即可</span><span class="hljs-meta">$</span><span class="bash"> java -version</span></code></pre></div></li><li><p>软件安装</p><p>直接在软件搜索deepin.com.qq.office, idea, mysql安装</p></li><li><p>electron-ssr</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 从githb上下载pacman安装包到/opt下</span><span class="hljs-meta">#</span><span class="bash"> pacman本地安装</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -U electron-ssr-0.2.6.pacman</span></code></pre></div></li><li><p>codeblocks配置:</p><ol><li><p>下载完之后，cd ~/.config/codeblocks/ ，在官网复制主题代码，修改default.conf文件，保存。</p></li><li><p>进入/usr/include/bits文件夹下，sudo vim stdc++，将代码复制，保存。</p></li><li><p>在settings-&gt;environment-&gt;Gerneral settings-&gt;Terminal to launch console programs:-&gt;下拉单选择gnome-terminal -t $TITLE -x，变更控制台。</p></li><li><p>进行start和splash页面，utf-8，字体[monospace bold]等设置……</p></li></ol></li><li><p>mysql</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在软件直接搜mysql,安装</span><span class="hljs-meta">#</span><span class="bash"> 初始化</span><span class="hljs-meta">$</span><span class="bash"> sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><span class="hljs-meta">#</span><span class="bash">上面初始化失败,提示libicu63没找到:</span><span class="hljs-meta">$</span><span class="bash"> mysqld: error <span class="hljs-keyword">while</span> loading shared libraries: libicuuc.so.63: cannot open shared object file: No such file or directory</span><span class="hljs-meta">#</span><span class="bash"> 进入/usr/lib/icu,发现只有64版本</span><span class="hljs-meta">#</span><span class="bash"> 安装icu63</span><span class="hljs-meta">$</span><span class="bash"> yay -S icu63</span><span class="hljs-meta">#</span><span class="bash"> 等待缓慢的下载和安装</span><span class="hljs-meta">#</span><span class="bash"> 完成后再看/usr/lib/icu,发现已经有icu63了</span><span class="hljs-meta">#</span><span class="bash"> 再次初始化</span><span class="hljs-meta">$</span><span class="bash"> sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><span class="hljs-meta">#</span><span class="bash"> 记住临时密码登录,或者修改配置文件免密登录,后者修改/etc/mysql/my.cnf,在最后一行加上</span>skip-grant-tables<span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart mysqld</span><span class="hljs-meta">#</span><span class="bash"> 如果又出现初始化失败的问题,重装即可</span><span class="hljs-meta">$</span><span class="bash"> mysql -u root -p</span><span class="hljs-meta">#</span><span class="bash"> 不用密码[回车]即可</span></code></pre></div> <div class="hljs"><pre><code class="hljs mysql">use mysql;flush privileges ;alter user&#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;</code></pre></div><p><code>ctrl</code>+<code>d</code>退出mysql</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 如果是免密登录,删除加入的那行</span><span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart mysqld</span><span class="hljs-meta">#</span><span class="bash"> 输入root进入mysql</span>mysql -u root -p</code></pre></div><hr><p>二更:</p><p>重新装mysql时，没有出现上面的libicu63没找到，而是libevent_core-2.1.so.6没有找到……</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查找mysqld可能缺失的依赖库</span><span class="hljs-meta">$</span><span class="bash"> ldd /usr/bin/mysqld</span><span class="hljs-meta">#</span><span class="bash"> 结果显示，libevent_core-2.1.so.6 NOT FOUND</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/lib</span><span class="hljs-meta">#</span><span class="bash"> 发现只有.7的版本，没有.6,依赖库的版本太新了</span><span class="hljs-meta">$</span><span class="bash"> cp libevent_core-2.1.so.7 libevent_core-2.1.so.6</span><span class="hljs-meta">#</span><span class="bash"> 直接复制.7为.6</span><span class="hljs-meta">#</span><span class="bash"> 接下来就和上面的一样，重新初始化，再进行下面的步骤即可。</span></code></pre></div></li><li><p>解决tim无法使用中文输入法:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /opt/deepinwine/apps/Deepin-TIM</span><span class="hljs-meta">$</span><span class="bash"> sudo vim run.sh</span><span class="hljs-meta">#</span><span class="bash"> 添加三行:</span>export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=”@im=fcitx”<span class="hljs-meta">$</span><span class="bash"> reboot</span></code></pre></div></li><li><p>命令行使用代理</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改 ~/.zshrc</span>vim .zshrc<span class="hljs-meta">#</span><span class="bash"> 最下面加入两行</span>export http_proxy="http://127.0.0.1:12333"export https_proxy="http://127.0.0.1:12333"</code></pre></div></li><li><p>jetbrains全软件代理</p><p>在Settings-&gt;Apperance -&gt;System Settings-&gt;HTTP Proxy</p><p>设置Manual proxy,选择HTTP,Host name:127.0.0.1,Port number:<strong>12333</strong></p><blockquote><p>注意：</p></blockquote><p>如果electron-ssr设置了局域网内代理（默认1080端口），则端口号改为1080</p><p>还有：使用idea的同步功能时，确保File-&gt;Settings-&gt;System settings-&gt;Passwords-&gt;In KeePass勾选上</p><p>否则账户同步功能会报错</p></li><li><p>安装vscode</p><p>在软件包里安装bin文件,然后</p> <div class="hljs"><pre><code class="hljs shell">yaourt -S visual-studio-code-bin</code></pre></div><p>解决安装完成后打开文件夹自动打开vscode问题:</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 首先查看默认文件管理器</span><span class="hljs-meta">$</span><span class="bash"> xdg-mime query default inode/directory</span><span class="hljs-meta">#</span><span class="bash"> 不出意外的话,会输出visual-studio-code.desktop</span><span class="hljs-meta">#</span><span class="bash"> 修改默认文件管理器</span><span class="hljs-meta">$</span><span class="bash"> xdg-mime default org.gnome.Nautilus.desktop inode/directory</span><span class="hljs-meta">#</span><span class="bash"> 再执行query命令</span>xdg-mime query default inode/directory<span class="hljs-meta">#</span><span class="bash"> 显示org.gnome.Nautilus.desktop即正确</span></code></pre></div><p>解决vscode格式化失败:libtinfo.so.5:cannot open</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 先检查有没有</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/lib</span><span class="hljs-meta">#</span><span class="bash"> 不完全打出全称,看看有哪些是以libtinfo开头的</span><span class="hljs-meta">$</span><span class="bash"> vim libtinfo. [+`tab`]</span><span class="hljs-meta">#</span><span class="bash"> 此时我看到了libtinfo.so libtinfo.so.6,的确缺少libtinfo.so.5</span><span class="hljs-meta">#</span><span class="bash"> 安装之即可</span><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S libtinfo5</span></code></pre></div><p><strong>注意：<strong>不要打开设置中的</strong>Auto Guess Encoding</strong>!!!</p></li><li><p>配置ranger</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ranger --copy-config=all</span><span class="hljs-meta">#</span><span class="bash"> 此命令将ranger的配置生成到 ~/.config/ranger文件夹下</span><span class="hljs-meta">#</span><span class="bash"> rc.config:选项设置和快捷键</span><span class="hljs-meta">#</span><span class="bash"> rifle.conf:指定文件的默认打开程序</span><span class="hljs-meta">#</span><span class="bash"> command.py:设置通过<span class="hljs-string">":"</span>执行的命令</span><span class="hljs-meta">$</span><span class="bash"> vim rc.conf</span>set show_hidden trueset colorscheme solarizedset draw_borders bothset line_numbers true</code></pre></div><p>vscode 插件</p> <div class="hljs"><pre><code class="hljs json">daily reminder,coding tracker,leetcode,netease music,power mode</code></pre></div></li><li><p>安装redis</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo pacman -S redis</span><span class="hljs-meta">#</span><span class="bash"> 安装完成后检查能否运行</span>redis-serverredis-cli<span class="hljs-meta">#</span><span class="bash"> 修改配置使其能在后台运行</span>sudo vim /etc/redis.conf<span class="hljs-meta">#</span><span class="bash"> 把daemonize no改为yes</span>deamonize yes<span class="hljs-meta">#</span><span class="bash"> 以刚刚的配置文件运行</span><span class="hljs-meta">$</span><span class="bash"> redis-server /etc/redis.conf</span><span class="hljs-meta">#</span><span class="bash"> 这次的输出应该和前次的不一样</span><span class="hljs-meta">#</span><span class="bash"> 启动</span><span class="hljs-meta">$</span><span class="bash"> redis-cli</span></code></pre></div></li><li><p>安装mycli</p> <div class="hljs"><pre><code class="hljs shell">pip install mycli</code></pre></div></li><li><p>idea生成javadoc文档</p><p>Tools-&gt;Generate JavaDoc(快捷键可以设置为<code>CTL</code>+<code>ALT</code>+<code>D</code>)</p><p>选择OutPut_directroy</p><p>选择package</p><p>Local制定 zh_CN</p><p>Other command line arguments:</p> <div class="hljs"><pre><code class="hljs shell">-encoding utf-8 -charset utf-8 -version -windowtitle "JShell" -tag Date:a:"Date"</code></pre></div><p>在生成的文件夹中点击index.html即可。</p></li><li><p>WPS 默认英文设置</p> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装中文语言包</span>sudo pacman -S wps-office-mui-zh-cn</code></pre></div><p>进入 WPS 文字,点击右上方的 <code>A</code> 符号,选择中文,推出软件,重进即可</p></li><li><p>截图工具 flameshot</p> <div class="hljs"><pre><code class="hljs shell">sudo pacman -S flameshot</code></pre></div><p>打开设置-&gt;键盘快捷键,设置名称,快捷键 <code>ctrl+alt+A</code>,命令是 <code>flameshot gui</code></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2019/7/11/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/7/11/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>算法思想:</p><ol><li>将数组中的数据建立成所有根结点大于其左右子树的<em>完全二叉树</em>，即<strong>大根堆</strong></li></ol> <a id="more"></a><ol start="2"><li>然后将第一个堆顶结点，即root结点，也是当前未排序的最大数据，和最后未排序的数据的位置交换，结果类似冒泡排序排好了一个数据，那么现在那个最后未排序的位置就是当前的最大的数据，也就排好了一个数据</li><li>但是因为交换数据，现在的root结点的数据不一定就是最大的，那么就还需要调整堆，使其满足大根堆条件。</li><li>重复上述过程，就可以得到升序序列;反之，建立小根堆可以得到降序序列。</li></ol> <!-- more --></li><li><p>代码：</p> <div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//k 是要调整的结点在数组中的下标，在createHeap中传入的值是从最后一个非叶子结点的下标依次递减到0,表现为从中点处依次向上调整堆</span><span class="hljs-comment">//但是在HeapSort循环中，根据上述算法，每次调整的都是堆顶的root结点，即第一个结点，k=0。</span><span class="hljs-comment">//n 是还要排序n个数，第n个数也要排序，所以while循环里的条件，注意判断j等于n的情况</span><span class="hljs-comment">//j 是i的左子树结点,为2*k+1的原因是数组下标从0开始，经过试验规律得到i的左子树下标为2*k+1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = k, temp;<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>;<span class="hljs-comment">//如果j的值已经大于要排序的最后一个值的下标，说明i不存在左子树，根据完全二叉树的定义，肯定没有右子树，那么这个i结点一定是满足大根堆的，无需调整。</span><span class="hljs-keyword">while</span> (j &lt;= n)&#123;<span class="hljs-comment">//如果j+1的值小于等于要排序的最后一个值的下标，那么i不仅有左子树，还有右子树，那么就要比较右子树的数据是否大于左子树，如果是的话，j++，使j的值为i的最大子树的下标。</span><span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= n &amp;&amp; <span class="hljs-built_in">array</span>[j] &lt; <span class="hljs-built_in">array</span>[j + <span class="hljs-number">1</span>])j++;<span class="hljs-comment">//如果从i向下检查时，满足这个条件，就说明从这个结点开始往下的子树一定满足大根堆条件，就可以不用再检查，可以直接结束循环了。</span><span class="hljs-comment">//[当然，原因分两种情况。第一：是在创建堆时，i是最后一个非叶子结点，其后一定的都是叶子结点，一定满足大根堆，而i以前的非叶子结点进行判断时，因为后面一定已经调整好了，也一定满足大根堆。第二：在HeapSort循环里调整的话，和上面其实一样，每次交换可能只破坏了一个局部的大根堆，当把这个局部的调整回来时，其后面的结点就和之前一样，不受影响了。]</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &gt;= <span class="hljs-built_in">array</span>[j])<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果当前根结点i的值不是其左右字数中最大的，那么就和那个最大的数交换，使其满足大根堆条件</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &lt; <span class="hljs-built_in">array</span>[j])&#123;temp = <span class="hljs-built_in">array</span>[i];<span class="hljs-built_in">array</span>[i] = <span class="hljs-built_in">array</span>[j];<span class="hljs-built_in">array</span>[j] = temp;<span class="hljs-comment">//因为交换了值，可能破坏大根堆的条件，那么就要循环向下判断大根堆条件是否满足</span><span class="hljs-comment">//这里还有技巧，只需要检查与i交换的j往下的子结点即可，不用检查那个没有发生交换的结点。</span>i = j;j = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//从当前的最后一个非叶子结点开始,从后往前[以数组的形式看]，从下到上[以二叉树的形式看]创建堆</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)adjustHeap(<span class="hljs-built_in">array</span>, i, n);   &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">   </span>&#123;<span class="hljs-keyword">int</span> temp;createHeap(<span class="hljs-built_in">array</span>, n);<span class="hljs-comment">//创建好大根堆后，先把最大的数据(n-1)换到最后面，再将被破坏的大根堆调整，使其满足大根堆条件。</span><span class="hljs-comment">//再重复上述步骤</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123;temp = <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = <span class="hljs-built_in">array</span>[i];<span class="hljs-built_in">array</span>[i] = temp;adjustHeap(<span class="hljs-built_in">array</span>, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);&#125;&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
